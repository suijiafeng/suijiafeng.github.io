<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>眭加凤的博客</title>
  
  <subtitle>和你一起终生学习</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://suijiafeng.com/"/>
  <updated>2018-12-14T01:58:53.745Z</updated>
  <id>http://suijiafeng.com/</id>
  
  <author>
    <name>suijiafeng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://suijiafeng.com/2018/12/14/hello-world/"/>
    <id>http://suijiafeng.com/2018/12/14/hello-world/</id>
    <published>2018-12-14T01:58:53.744Z</published>
    <updated>2018-12-14T01:58:53.745Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>tags</title>
    <link href="http://suijiafeng.com/2018/12/14/tags/"/>
    <id>http://suijiafeng.com/2018/12/14/tags/</id>
    <published>2018-12-14T01:22:34.000Z</published>
    <updated>2018-12-14T01:49:13.413Z</updated>
    
    <content type="html"><![CDATA[<p>12344</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;12344&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>我现在新加的内容</title>
    <link href="http://suijiafeng.com/2018/12/11/%E6%88%91%E7%8E%B0%E5%9C%A8%E6%96%B0%E5%8A%A0%E7%9A%84%E5%86%85%E5%AE%B9/"/>
    <id>http://suijiafeng.com/2018/12/11/我现在新加的内容/</id>
    <published>2018-12-11T05:19:55.000Z</published>
    <updated>2018-12-14T01:58:53.759Z</updated>
    
    <content type="html"><![CDATA[<p>最近在一点一点学习koa源码和深入浅出Node.js那本书，因为现在egg也是基于koa2的，而且自己以前做毕设的时候也用过，async/await真的是太好用了；现在新的中间层用egg搭建，所以想彻底把这部分的东西好好系统看一遍。</p><p>从开始看先看到了koa的一个构造函数，然后根据Node原生的写法看，它的真正创建服务的代码在listen()当中:</p><a id="more"></a><!-- more  --><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>constructor() {<br>    super();</p><pre><code>this.proxy = false;this.middleware = [];this.subdomainOffset = 2;this.env = process.env.NODE_ENV || &apos;development&apos;;this.context = Object.create(context);this.request = Object.create(request);this.response = Object.create(response);console.log(this)</code></pre><p>}</p><p>listen(…args) {<br>    debug(‘listen’);<br>    const server = http.createServer(this.callback());<br>    return server.listen(…args);<br>}<br>在看深入浅出Node.js那本书里面，知道具体的request和response都是在这个callback里面执行，所以就看这个函数：</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>callback() {<br>   const fn = compose(this.middleware);</p><p>   if (!this.listeners(‘error’).length) this.on(‘error’, this.onerror);</p><p>   const handleRequest = (req, res) =&gt; {<br>     const ctx = this.createContext(req, res);<br>     return this.handleRequest(ctx, fn);<br>   };</p><p>   return handleRequest;<br> }<br>在这里其实就是返回了一个handleRequest(),继续看：</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>handleRequest(ctx, fnMiddleware) {<br>  const res = ctx.res;<br>  res.statusCode = 404;<br>  const onerror = err =&gt; ctx.onerror(err);<br>  const handleResponse = () =&gt; respond(ctx);<br>  onFinished(res, onerror);<br>  return fnMiddleware(ctx).then(handleResponse).catch(onerror);<br>}<br>到这里基本就能看出来它首先执行的就是这个fn，而这个fn又是怎么执行的？</p><p>大家都知道它是洋葱式的处理，然后看了一下是放在一个koa-compose的模块当中，这个模块就仅仅几行代码：</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br> function compose (middleware) {<br>  if (!Array.isArray(middleware)) throw new TypeError(‘Middleware stack must be an array!’)<br>  for (const fn of middleware) {<br>    if (typeof fn !== ‘function’) throw new TypeError(‘Middleware must be composed of functions!’)<br>  }</p><p>  /**</p><ul><li>@param {Object} context</li><li>@return {Promise}</li><li><p>@api public<br>*/</p><p>return function (context, next) {<br>// last called middleware #<br>let index = -1<br>return dispatch(0)<br>function dispatch (i) {<br> if (i &lt;= index) return Promise.reject(new Error(‘next() called multiple times’))<br> index = i<br> let fn = middleware[i]<br> if (i === middleware.length) fn = next<br> if (!fn) return Promise.resolve()<br> try {<br>   return Promise.resolve(fn(context, function next () {</p><pre><code>return dispatch(i + 1)</code></pre><p>   }))<br> } catch (err) {<br>   return Promise.reject(err)<br> }<br>}<br>}<br>}<br>上面几行都是异常处理，真正的逻辑都在这个return的dispatch(0)当中，然后你发现它就是第一个中间件，首先先去做完一部分第一个中间件的事情，然后到了await next()就要去执行第二个，最终就是一个类似洋葱的模型：</p></li></ul><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>Promise.resolve(function(context, next){<br>    //中间件一第一部分代码<br>    await/yield Promise.resolve(function(context, next){<br>        //中间件二第一部分代码<br>        await/yield Promise.resolve(function(context, next){<br>                //中间件三第一部分代码<br>                await/yield next() // …n个<br>                //中间件三第二部分代码<br>        }())<br>         //中间件二第二部分代码<br>    }())<br>    //中间件一第二部分代码<br>}())<br>显而易见这个就是一个洋葱模型，这就是一个简单的koa的中间件调用的实现方式，感觉就可以理解成一个Promise.all()</p><p>感觉看完这个，也就对koa的中间件有了一个彻底的认知和理解，那么直接去学习中间件的源码也轻松了很多。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在一点一点学习koa源码和深入浅出Node.js那本书，因为现在egg也是基于koa2的，而且自己以前做毕设的时候也用过，async/await真的是太好用了；现在新的中间层用egg搭建，所以想彻底把这部分的东西好好系统看一遍。&lt;/p&gt;
&lt;p&gt;从开始看先看到了koa的一个构造函数，然后根据Node原生的写法看，它的真正创建服务的代码在listen()当中:&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ES6语法常用特性总结</title>
    <link href="http://suijiafeng.com/2018/08/20/ES6%E8%AF%AD%E6%B3%95%E5%B8%B8%E7%94%A8%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93/"/>
    <id>http://suijiafeng.com/2018/08/20/ES6语法常用特性总结/</id>
    <published>2018-08-20T15:18:06.000Z</published>
    <updated>2018-12-12T04:36:13.331Z</updated>
    
    <content type="html"><![CDATA[<p>ECMAScript6在保证向下兼容的前提下，提供大量新特性，目前浏览器兼容情况如下：</p><p>ES6特性如下：</p><h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>关键字let,<br>常量const</p><p>blogexcerpt:123456789</p><h3 id="对象字面量的属性赋值简写"><a href="#对象字面量的属性赋值简写" class="headerlink" title="对象字面量的属性赋值简写"></a>对象字面量的属性赋值简写</h3><pre><code>var obj = {    // __proto__    __proto__: theProtoObj,    // Shorthand for ‘handler: handler’    handler,    // Method definitions    toString() {    // Super calls    return &quot;d &quot; + super.toString();    },    // Computed (dynamic) property names    [ &apos;prop_&apos; + (() =&gt; 42)() ]: 42};</code></pre><h3 id="赋值解构"><a href="#赋值解构" class="headerlink" title="赋值解构"></a>赋值解构</h3><pre><code>let singer = { first: &quot;Bob&quot;, last: &quot;Dylan&quot; };let { first: f, last: l } = singer; // 相当于 f = &quot;Bob&quot;, l = &quot;Dylan&quot;let [all, year, month, day] =  /^(\d\d\d\d)-(\d\d)-(\d\d)$/.exec(&quot;2015-10-25&quot;);let [x, y] = [1, 2, 3]; // x = 1, y = 2</code></pre><p>4.函数参数（Default 、Rest 、Spread）</p><pre><code>//Defaultfunction findArtist(name=&apos;lu&apos;, age=&apos;26&apos;) {    ...}//Restfunction f(x, ...y) {  // y is an Array  return x * y.length;}f(3, &quot;hello&quot;, true) == 6//Spreadfunction f(x, y, z) {  return x + y + z;}// Pass each elem of array as argumentf(...[1,2,3]) == 6</code></pre><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><ol><li>简化了代码形式，默认return表达式结果。</li></ol><ol><li>自动绑定语义this，即定义函数时的this。如上面例子中，forEach的匿名函数参数中用到的this。</li></ol><h4 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h4><pre><code>var name = &quot;Bob&quot;, time = &quot;today&quot;;`Hello ${name}, how are you ${time}?`// return &quot;Hello Bob, how are you today?&quot;</code></pre><h4 id="Iterators（迭代器）-for-of"><a href="#Iterators（迭代器）-for-of" class="headerlink" title="Iterators（迭代器）+ for..of"></a>Iterators（迭代器）+ for..of</h4><p>迭代器有个next方法，调用会返回：</p><ol><li><p>返回迭代对象的一个元素：{ done: false, value: elem }</p></li><li><p>如果已到迭代对象的末端：{ done: true, value: retVal }</p></li></ol><p><code>for (var n of [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]) {      console.log(n);    }    // 打印a、b、c</code></p><h4 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h4><p>Class，有constructor、extends、super，但本质上是语法糖（对语言的功能并没有影响，但是更方便程序员使用）。</p><pre><code>class Artist {    constructor(name) {        this.name = name;    }    perform() {        return this.name + &quot; performs &quot;;    }}class Singer extends Artist {    constructor(name, song) {        super.constructor(name);        this.song = song;    }    perform() {        return super.perform() + &quot;[&quot; + this.song + &quot;]&quot;;    }}let james = new Singer(&quot;Etta James&quot;, &quot;At last&quot;);james instanceof Artist; // truejames instanceof Singer; // truejames.perform(); // &quot;Etta James performs [At last]&quot;</code></pre><h4 id="Map-Set-WeakMap-WeakSet"><a href="#Map-Set-WeakMap-WeakSet" class="headerlink" title="Map + Set + WeakMap + WeakSet"></a>Map + Set + WeakMap + WeakSet</h4><p>四种集合类型，WeakMap、WeakSet作为属性键的对象如果没有别的变量在引用它们，则会被回收释放掉。</p><pre><code>// Setsvar s = new Set();s.add(&quot;hello&quot;).add(&quot;goodbye&quot;).add(&quot;hello&quot;);s.size === 2;s.has(&quot;hello&quot;) === true;// Mapsvar m = new Map();m.set(&quot;hello&quot;, 42);m.set(s, 34);m.get(s) == 34;//WeakMapvar wm = new WeakMap();wm.set(s, { extra: 42 });wm.size === undefined// Weak Setsvar ws = new WeakSet();ws.add({ data: 42 });//Because the added object has no other references, it will not be held in the set12.Math + Number + String + Array + Object APIs</code></pre><p>一些新的API</p><pre><code>Number.EPSILONNumber.isInteger(Infinity) // falseNumber.isNaN(&quot;NaN&quot;) // falseMath.acosh(3) // 1.762747174039086Math.hypot(3, 4) // 5Math.imul(Math.pow(2, 32) - 1, Math.pow(2, 32) - 2) // 2&quot;abcde&quot;.includes(&quot;cd&quot;) // true&quot;abc&quot;.repeat(3) // &quot;abcabcabc&quot;Array.from(document.querySelectorAll(&apos;*&apos;)) // Returns a real ArrayArray.of(1, 2, 3) // Similar to new Array(...), but without special one-arg behavior[0, 0, 0].fill(7, 1) // [0,7,7][1, 2, 3].find(x =&gt; x == 3) // 3[1, 2, 3].findIndex(x =&gt; x == 2) // 1[1, 2, 3, 4, 5].copyWithin(3, 0) // [1, 2, 3, 1, 2][&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].entries() // iterator [0, &quot;a&quot;], [1,&quot;b&quot;], [2,&quot;c&quot;][&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].keys() // iterator 0, 1, 2[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].values() // iterator &quot;a&quot;, &quot;b&quot;, &quot;c&quot;Object.assign(Point, { origin: new Point(0,0) })</code></pre><h4 id="Proxies"><a href="#Proxies" class="headerlink" title="Proxies"></a>Proxies</h4><p>使用代理（Proxy）监听对象的操作，然后可以做一些相应事情。</p><pre><code>var target = {};var handler = {  get: function (receiver, name) {    return `Hello, ${name}!`;  }};var p = new Proxy(target, handler);p.world === &apos;Hello, world!&apos;;</code></pre><p>可监听的操作：</p><p> get、set、has、deleteProperty、apply、construct、getOwnPropertyDescriptor、defineProperty、getPrototypeOf、setPrototypeOf、enumerate、ownKeys、preventExtensions、isExtensible。</p><h4 id="Symbols"><a href="#Symbols" class="headerlink" title="Symbols"></a>Symbols</h4><p>Symbol是一种基本类型。Symbol 通过调用symbol函数产生，它接收一个可选的名字参数，该函数返回的symbol是唯一的。</p><pre><code>var key = Symbol(&quot;key&quot;);var key2 = Symbol(&quot;key&quot;);key == key2  //false</code></pre><h4 id="Promises"><a href="#Promises" class="headerlink" title="Promises"></a>Promises</h4><p>Promises是处理异步操作的对象，使用了 Promise 对象之后可以用一种链式调用的方式来组织代码，让代码更加直观（类似jQuery的deferred 对象）。</p><pre><code>function fakeAjax(url) {  return new Promise(function (resolve, reject) {    // setTimeouts are for effect, typically we would handle XHR    if (!url) {      return setTimeout(reject, 1000);    }    return setTimeout(resolve, 1000);  });}// no url, promise rejectedfakeAjax().then(function () {  console.log(&apos;success&apos;);},function () {  console.log(&apos;fail&apos;);});</code></pre><p>总结<br>对于ES6，在某些方式是不是重蹈ES4的覆辙，变得复杂了；又或许几年后大家的接受能力变强了，觉得是应该这样了。我觉得还是不错的，因为它们是向下兼容的，即使复杂语法不会用，也能用自己熟知的方式，提供的语法糖也都挺实际。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ECMAScript6在保证向下兼容的前提下，提供大量新特性，目前浏览器兼容情况如下：&lt;/p&gt;
&lt;p&gt;ES6特性如下：&lt;/p&gt;
&lt;h3 id=&quot;块级作用域&quot;&gt;&lt;a href=&quot;#块级作用域&quot; class=&quot;headerlink&quot; title=&quot;块级作用域&quot;&gt;&lt;/a&gt;块级作用
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue3.0快速创建项目</title>
    <link href="http://suijiafeng.com/2018/08/13/vue3.0%E5%BF%AB%E9%80%9F%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE/"/>
    <id>http://suijiafeng.com/2018/08/13/vue3.0快速创建项目/</id>
    <published>2018-08-13T14:45:36.000Z</published>
    <updated>2018-12-12T04:36:13.346Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h4><p>更新npm到最新版本<br>命令行运行: </p><pre><code>npm install -g npm </code></pre><p>npm就自动为我们更新到最新版本</p><p>使用 npm 全局安装 vue-cli ：</p><pre><code>npm i -g @vue/cli</code></pre><h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><p>执行：</p><pre><code>vue create my-project   // my-project是要创建的文件夹</code></pre><p>此处有两个选择：</p><p><code>default (babel, eslint)</code>    // 默认套餐，提供babel和eslint支持</p><p><code>Manually select features</code>  // 自己去选择需要的功能，提供更多的特性选择。</p><p>比如如果想要支持 TypeScript ，就应该选择这一项。</p><p>可以使用上下方向键来切换选项。</p><p>如果只需要 babel 和 eslint 支持，那么选择第一项，就完事了，静静等待 vue 初始化项目。</p><p>vue-cli 内置支持了8个功能特性，可以多选：使用方向键在特性选项之间切换，使用空格键选中当前特性，使用 a 键切换选择所有，使用 i 键翻转选项。</p><p>对于每一项的功能，此处做个简单描述：</p><pre><code>TypeScript                //支持使用 TypeScript 书写源码Progressive Web App (PWA) //Support PWA 支持。Router                    //支持 vue-router 。Vuex 支持 vuex 。CSS Pre-processors        //支持 CSS 预处理器。Linter / Formatter        //支持代码风格检查和格式化。Unit Testing              //支持单元测试。E2E Testing               //支持 E2E 测试。</code></pre><p>我选择了 Router，Vuex，CSS Pre-processors，Linter / Formatter</p><p>按住enter进入下一步，接下来都是对之前每项选项的更详细的选择。<br>css选择SCSS/SASS</p><p>Linter / Formatter选择prettier</p><p>这一步就是要选择配置文件的位置了。</p><p>对于<code>Babel 、 PostCSS</code> 等，都可以有自己的配置文件：<code>.babelrc 、 .postcssrc</code> 等等，同时也可以把配置信息放在 package.json 里面。此处出于对编辑器（ Visual Studio Code ）的友好支持（编辑器一般默认会在项目根目录下寻找配置文件），选择把配置文件放在外面，选择 <code>In dedicated config files</code><br>待补充<br>Save this as a preset for future projects?</p><p>这个就是问要不要把当前的这一系列选项配置保存起来，方便下一次创建项目时复用。选择y。</p><p>选完之后， vue-cli 就根据前面选择的内容，开始初始化项目了。</p><h4 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h4><p>初始完之后，进入到项目根目录： <code>cd my-project</code> 启动项目： <code>npm run serve</code> 稍等一会儿，可以看到自动在浏览器中打开了</p><p>安装PostCSS插件<br>通过Vue-cli构建的项目，在项目的根目录下有一个.postcssrc.js，默认情况下已经有了：</p><pre><code>module.exports = {        plugins: {          autoprefixer: {}        }}</code></pre><p>5<br>配置成</p><pre><code>module.exports = {        plugins: {          &quot;postcss-import&quot;:{},          &quot;postcss-url&quot;:{},          &quot;autoprefixer&quot;: {}        }}</code></pre><p>安装postcss-import和postcss-url插件 </p><p><code>$ npm install postcss-import</code>和$ <code>npm install postcss-urlpostcss-import</code>相关配置点击这里。主要功有是解决@import引入路径问题。使用这个插件，可以让你很轻易的使用本地文件、node_modules或者web_modules的文件。这个插件配合postcss-url让你引入文件变得更轻松。</p><p><code>postcss-url</code>相关配置可以点击这里。该插件主要用来处理文件，比如图片文件、字体文件等引用路径的处理。在Vue项目中，vue-loader已具有类似的功能，只需要配置中将vue-loader配置进去。<br><code>autoprefixe</code>r插件是用来自动处理浏览器前缀的一个插件。如果你配置了<code>postcss-cssnext</code>，其中就已具备了autoprefixer的功能。</p><p>在配置的时候，未显示的配置相关参数的话，表示使用的是Browserslist指定的列表参数，你也可以像这样来指定last 2 versions 或者 &gt; 5%。如此一来，你在编码时不再需要考虑任何浏览器前缀的问题，可以专心撸码。这也是PostCSS最常用的一个插件之一。</p><h4 id="配置插件"><a href="#配置插件" class="headerlink" title="配置插件"></a>配置插件</h4><p>我们要完成vw的布局兼容方案，或者说让我们能更专心的撸码，还需要配置下面的几个PostCSS插件：</p><pre><code>postcss-aspect-ratio-minipostcss-px-to-viewportpostcss-write-svgpostcss-cssnextcssnanopostcss-viewport-units</code></pre><p>要使用<br>安装成功后，在项目根目录下的package.json文件中，可以看到新安装的依赖包：</p><pre><code>&quot;dependencies&quot;: {    &quot;cssnano&quot;: &quot;^3.10.0&quot;,    &quot;postcss-aspect-ratio-mini&quot;: &quot;^0.0.2&quot;,    &quot;postcss-cssnext&quot;: &quot;^3.1.0&quot;,    &quot;postcss-import&quot;: &quot;^11.1.0&quot;,    &quot;postcss-px-to-viewport&quot;: &quot;^0.0.3&quot;,    &quot;postcss-url&quot;: &quot;^7.3.2&quot;,    &quot;postcss-viewport-units&quot;: &quot;^0.1.4&quot;,    &quot;postcss-write-svg&quot;: &quot;^3.0.1&quot;,    &quot;vue&quot;: &quot;^2.5.16&quot;,    &quot;vue-router&quot;: &quot;^3.0.1&quot;,    &quot;vuex&quot;: &quot;^3.0.1&quot;  },</code></pre><p>接下来在.postcssrc.js文件对新安装的PostCSS插件进行配置：</p><pre><code>module.exports = {  plugins: {    &quot;postcss-import&quot;: {},    &quot;postcss-url&quot;: {},    //&quot;autoprefixer&quot;: {},    &quot;postcss-aspect-ratio-mini&quot;: {},    &quot;postcss-write-svg&quot;: {      utf8: false    },    &quot;postcss-cssnext&quot;: {},    &quot;postcss-px-to-viewport&quot;: {      viewportWidth: 750, //视窗的宽度，对应的是我们设计稿的宽度，一般是750      viewportHeight: 1334, //视窗的高度，根据750设备的宽度来置顶，一般指定1334，也可以不配置      unitPrecision: 3, //指定&apos;px&apos;转换为视窗单位值的小数位数（很多时候无法整除）      viewportUnit: &apos;vw&apos;, //指定需要转换成的视窗单位，建议使用vw      selectorBlackList: [&apos;.ignore&apos;, &apos;.hairlines&apos;, &apos;.g-vw-no&apos;], //指定不转行为视窗单位的类，可以自定义，可以无限添加，建议定义一至两个通用的类名      minPixeValue: 1, //小于或等于&apos;1px&apos;不转换为视窗单位，你也可以设置为你想要的值      mediaQuery: false //允许在媒体查询中转换&apos;px&apos;    },    &quot;postcss-viewport-units&quot;: {},    &quot;cssnano&quot;: {      preset: &quot;advanced&quot;,      autoprefixer: false,      &quot;postcss-zindex&quot;: false    }  }}</code></pre><p>特别声明：由于cssnext和cssnano都具有autoprefixer,事实上只需要一个，所以把默认的autoprefixer删除掉，然后把cssnano中的autoprefixer设置为false。对于其他的插件使用，稍后会简单的介绍。</p><p>由于配置文件修改了，所以重新跑一下npm run dev。</p><p>项目就可以正常看到了。接下来简单的介绍一下后面安装的几个插件的作用。</p><h4 id="打包上线"><a href="#打包上线" class="headerlink" title="打包上线"></a>打包上线</h4><p>在开发完项目之后，就应该打包上线了。 vue-cli 也提供了打包的命令，在项目根目录下执行： </p><pre><code>npm run build </code></pre><p>执行完之后，可以看到在项目根目录下多出了一个 dist 目录，该目录下就是打包好的所有静态资源，直接部署到静态资源服务器就好了。</p><p>下面作个总结</p><p> Vue3.0 与 Vue2.0 区别：</p><h4 id="一、创建项目命令的变化。"><a href="#一、创建项目命令的变化。" class="headerlink" title="一、创建项目命令的变化。"></a>一、创建项目命令的变化。</h4><pre><code>vue create my-project //vue3.0创建方式vue init webpack my-project   //Vue2.0 创建方式 </code></pre><p>同时3.0 版本包括默认预设配置 和 用户自定义配置</p><ul><li>TypeScript</li><li>Progressive Web App (PWA) Support</li><li>Router</li><li>Vuex</li><li>CSS Pre-processors</li><li>Linter / Formatter</li><li>Unit Testing</li><li>E2E Testing</li></ul><h4 id="二、-项目目录结构变化："><a href="#二、-项目目录结构变化：" class="headerlink" title="二、 项目目录结构变化："></a>二、 项目目录结构变化：</h4><p>我们对比发现 vue-cli 3.0 默认项目目录相比 2.0 来说精简了很多。</p><ul><li>移除了配置文件目录， config 和 build 文件夹。</li><li>移除了 static 文件夹，新增 public 文件夹，并且 index.html 移动到 public 中。</li><li>在 src 文件夹中新增了 views 文件夹，用于分类 视图组件 和 公共组件。</li></ul><h4 id="三-移除了配置文件目录后如何自定义配置。"><a href="#三-移除了配置文件目录后如何自定义配置。" class="headerlink" title="三.移除了配置文件目录后如何自定义配置。"></a>三.移除了配置文件目录后如何自定义配置。</h4><p>从 3.0 版本开始，在项目的根目录放置一个 vue.config.js 文件, 可以配置该项目的很多方面。</p><p>vue.config.js 应该导出一个对象，例如：</p><pre><code>module.exports = { baseUrl: &apos;/&apos;, outputDir: &apos;dist&apos;, lintOnSave: true, compiler: false, // 调整内部的 webpack 配置。 // 查阅 https://github.com/vuejs/vue-doc-zh-cn/vue-cli/webpack.md chainWebpack: () =&gt; {}, configureWebpack: () =&gt; {}, // 配置 webpack-dev-server 行为。 devServer: {  open: process.platform === &apos;darwin&apos;,  host: &apos;0.0.0.0&apos;,  port: 8080,  https: false,  hotOnly: false,  // 查阅 https://github.com/vuejs/vue-doc-zh-cn/vue-cli/cli-service.md#配置代理  proxy: null, // string | Object  before: app =&gt; {} } ....}</code></pre><p>调整 webpack 配置最简单的方式就是在 vue.config.js 中的 configureWebpack 选项提供一个对象，该对象将会被 webpack-merge 合并入最终的 webpack 配置。</p><p>示例代码：配置 webpack 新增一个插件。</p><pre><code>// vue.config.jsmodule.exports = { configureWebpack: {  plugins: [   new MyAwesomeWebpackPlugin()  ] }}</code></pre><p>修改插件选项的参数你需要熟悉 webpack-chain 的 API 并阅读一些源码以便了解如何权衡这个选项的全部配置项，但是它给了你比直接修改 webpack 配置中的值更灵活且安全的方式。</p><pre><code>// vue.config.jsmodule.exports = {  chainWebpack: config =&gt; {    config      .plugin(&apos;html&apos;)      .tap(args =&gt; {        return [/* new args to pass to html-webpack-plugin&apos;s constructor */]      })  }}</code></pre><h4 id="四-ESLint、Babel、browserslist-相关配置："><a href="#四-ESLint、Babel、browserslist-相关配置：" class="headerlink" title="四. ESLint、Babel、browserslist 相关配置："></a>四. ESLint、Babel、browserslist 相关配置：</h4><ul><li><p>Babel 可以通过 .babelrc 或 package.json 中的 babel 字段进行配置。</p></li><li><p>ESLint 可以通过 .eslintrc 或 package.json 文件中的 eslintConfig 字段进行配置。</p></li><li><p>你可能注意到了 package.json 中的 browserslist 字段指定了该项目的目标浏览器支持范围。</p></li></ul><h4 id="五-关于-public-目录的调整。"><a href="#五-关于-public-目录的调整。" class="headerlink" title="五. 关于 public 目录的调整。"></a>五. 关于 public 目录的调整。</h4><p>vue 约定 public/index.html 作为入口模板会通过 html-webpack-plugin 插件处理。在构建过程中，资源链接将会自动注入其中。除此之外，vue-cli 也自动注入资源提示( preload/prefetch ), 在启用 PWA 插件时注入 manifest/icon 链接, 并且引入(inlines) webpack runtime / chunk manifest 清单已获得最佳性能。</p><p>在 JavaScript 或者 SCSS 中通过 相对路径 引用的资源会经过 webpack 处理。放置在 public 文件的资源可以通过绝对路径引用，这些资源将会被复制，而不经过 webpack 处理。</p><p>小提示：图片最好使用相对路径经过 webpack 处理，这样可以避免很多因为修改网站根目录导致的图片404问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前置条件&quot;&gt;&lt;a href=&quot;#前置条件&quot; class=&quot;headerlink&quot; title=&quot;前置条件&quot;&gt;&lt;/a&gt;前置条件&lt;/h4&gt;&lt;p&gt;更新npm到最新版本&lt;br&gt;命令行运行: &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install -g npm 
&lt;/cod
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>webpack4的学习与填坑</title>
    <link href="http://suijiafeng.com/2018/07/12/webpack4%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%A1%AB%E5%9D%91/"/>
    <id>http://suijiafeng.com/2018/07/12/webpack4的学习与填坑/</id>
    <published>2018-07-11T16:56:00.000Z</published>
    <updated>2018-12-12T04:36:13.346Z</updated>
    
    <content type="html"><![CDATA[<p>在慕课上学习了webpack的课程，做了一些笔记，算分享也算记录吧。教程里的是webpack1和现在的webpack4有很多区别，自己也走了不少的坑，最好使用的时候去看官方文档。</p><p><a href="https://webpack.js.org/" target="_blank" rel="noopener">https://webpack.js.org/</a><br>在填坑的时候也借鉴了很多人写的文章。所以有很多部分是融合了超级多前人的经验总结，然后自己结合实际进行操作的做笔记。部分地方可能有重复，看得懂就好了。</p><p>1.全局安装webpack</p><pre><code>npm install -g webpack</code></pre><p>2.创建项目文件，初始化项目文件目录</p><pre><code>npm init</code></pre><p>到项目文件下安装webpack   </p><pre><code>npm install webpack</code></pre><p>3.安装全局的webpack-cli</p><pre><code>npm install -g webpack-cli  //获取当前webpack版本号配置文件</code></pre><p>4.配置mode </p><p>默认有production和development两种模式可以设置</p><p>命令行设置</p><p>   webpack –mode development</p><p>5.新建入口<br>在项目文件目录下新建src文件夹，新建index.js文件入口</p><p>6.文件打包命令行输入 </p><pre><code>webpack --mode development 或 webpack --mode production</code></pre><p>webpack将会默认打包，将./src/index.js文件打包成./dist/main.js文件（自动生成dist文件夹和main.js文件）</p><p>7.建立html文件，在项目目录下建立html文件，可以直接引用dist/main.js文件。</p><p>注意，我们的 script 引用的文件是 dist/main.js，而不是 index.js。</p><p>这正是前端开发领域的一个趋势：开发的源文件（例子中的 index.js）与最终部署的文件（例子中的 dist/main.js）是区分开的，之所以这样，是因为开发环境与用户的使用环境并不一致。比如我们可以在开发环境使用 ES2017 甚至 ES2018 的特性，而用户的浏览器不见得支持 - 这也是 webpack 等打包工具的一个意义，它们能够辅助我们构建出在目标用户浏览器上正常运行的代码。</p><p>8.其他参数配置<br>我们如果需要配置webpack指令的其他参数，只需要在webpack –mode production/development后加上其他参数即可，如：</p><pre><code>webpack --mode development --watch --progress --display-modules --colors --display-reasons</code></pre><p>9.监控文件,实时刷新<br>watch选项最为直观，但在默认情况下，watch选项是关闭状态。<br>启用watch选项</p><pre><code>webpack --mode development --watch</code></pre><p>10.刷新浏览器（看官方文档容易填坑，奈何英语emmmm）<br><a href="https://github.com/webpack/webpack-dev-server" target="_blank" rel="noopener">https://github.com/webpack/webpack-dev-server</a></p><p><a href="https://webpack.js.org/configuration/dev-server/#devserver" target="_blank" rel="noopener">https://webpack.js.org/configuration/dev-server/#devserver</a><br>webpack-dev-server,一个基于expressjs的开发服务器，提供实时刷新浏览器页面的功能。</p><p>安装webpack-dev-server<br>首先在项目下安装 webpack-dev-server: </p><pre><code>npm install -g webpack-dev-server</code></pre><p>然后在命令行下执行<br>    webpack-dev-server –mode development –output-public-path dist</p><p>webpack-dev-server是一个轻量级的服务器，修改文件源码后，自动刷新页面将修改同步到页面上安装webpack-dev-server：</p><blockquote><p>①全局安装：npm install webpack-dev-server -g </p><p>②在项目中安装并将依赖写在package.json文件中:npm install webpack-dev-server –save-dev</p><p>③使用命令webpack-dev-server –mode development –output-public-path src完成自动刷新，指定publicPath，这部分很容易没有实时刷新。</p><p>④默认的端口号是8080，如果需要8080端口被占用，就需要改端口，webpack-dev-server –port 3000(将端口号改为3000)，可以直接在webpack.config.js配置文件中配置devServer属性，开启热更新和port。</p><p>⑤启动服务，输入localhost:端口号，就显示发布的所有根目录，如果项目根目录中没有index.html文件，就会在浏览器中列出项目根目录中的所有的文件夹。</p><p>⑥当使用webpack-dev-server –mode development –output-public-path src命令时，在每次修改文件，是将文件打包保存在内存中并没有写在磁盘里，这种打包得到的文件和项目根目录中的index.html位于同一级。使用webpack命令将打包后的文件保存在磁盘中例如在index.html文件中引入通过webpack-dev-server –mode development  –output-public-path src打包的build.js<br><code>&lt;script src=&quot;build.js&quot;&gt;&lt;/script&gt;</code>　在index.html文件中引入通过webpack命令打包的build.js　</p><p><code>&lt;script src=&quot;./build/build.js&quot;&gt;&lt;/script&gt;</code><br>–inline 内联模式，在开发服务器的两种不同模式之间切换。默认情况下, 应用程序将被启用内嵌模式。这意味着将在包中插入一个脚本来处理实时重装, 并且生成消息将出现在浏览器控制台中。<br>–hot 启用热模块更换功能</p></blockquote><p>//////以上是搜索了各个教程里面说的，但是实际操作还是有问题，<br>index.html入口文件是在根目录下，没有进行配置content-base，因为配置了之后会只打包配置的目录文件，默认是根文件。配置了output的publicPath（很重要，删掉之后就不能自动刷新了，应该是webpack-dev-server将每次打包的文件根据output设置生成在publicPath目录下，而文件本身依旧是手动打包的，无法查看到自动刷新打包的文件），只配置了端口，没有配置hot:true和inline:true(最开始配置了，但是有报错，所以删掉莫名OK了）</p><blockquote><p>⑦webpack自带的watch命令与webpack-dev-server的区别<br>–watch是文件修改后自动打包，webpack-dev-server是修改后发布到服务器上</p><p>⑧webpack-dev-server –mode development –content-base src –inline –hot//显示只针对src路径下的文件刷新,文件修改之后浏览器自动刷新，如果要打开的文件和打包的文件不在一个文件夹内，最好不要设定文件夹</p></blockquote><p>11.打包css文件</p><p>在项目目录下安装处理css文件的loader命令行输入：</p><pre><code>npm install css-loader style-loader --save-devcss-loader //处理css文件</code></pre><p>style-loader //将css-loader处理后的文件作为样式标签<code>&lt;style&gt;</code>插入到html文件中</p><p>在处理css文件的时候要指定loader，如在index.js文件里输入</p><pre><code>require(&apos;style-loader!css-loader!./style.css&apos;)</code></pre><p>或者直接在命令行输入</p><pre><code>webpack --mode development --module-bind </code></pre><p>“css=style-loader!css-loader”<br>12–progress(查看进度)<br>13–display-modules(显示隐藏的模块)<br>14 –display-reasons(显示打包原因)</p><p>15.配置，webpack需要传入配置对象，因此进行新建配置文件webpack.config.js，或者使用node.js内置的path模块进行配置，并在它前面加上 __dirname这个全局变量。可以防止不同操作系统之间的文件路径问题，并且可以使相对路径按照预期工作。</p><p>①先写moudule.exports={};进行配置；</p><p>②入口文件配置，entry=”入口文件路径，如./src/js/main.js”;</p><p>③输出文件配置，output={path:<strong>dirname+”输出文件路径，如/dist/js/bundle.js”};//要创建dist文件夹</strong>dirname为运行时的当前路径；<br>另一种方式，先定义const path = require(“path”);//引入nodejs的path模块</p><p>然后在输出文件路径path:path.resolve(__dirname,”./dist/js/bundle.js”);</p><p>//path.resolve()方法解析了当前路径，将相对路径改为绝对路径。<br>④重新指定配置文件名</p><p>webpack –config 文件名</p><p>如webpack –config webpack.dev.config.js</p><p>16.定义执行脚本，可以在package.json中设置</p><p>在script中设置，如设置”webpack”:”webpack –mode development –config webpack.config.js –progress –display-modules –colors –display-reason”,//–colors(彩色显示)<br>直接执行上面的脚本npm run webpack</p><p>17.entry配置（chunk），</p><p>①字符串表示，单输入，所有依赖都要在入口文件中指定，如entry:”./src/js/main.js”,</p><p>②数组表示，多输入，两个需要打包到一起的文件可以在配置文件的entry中用数组表示，如entry:[“./app/entry1”, “./app/entry2”],//这两个文件将会打包到一起</p><p>③对象表示（哈希），多页面入口，entry:{page1:”./page1”,page2:[“./src/a.js”,”./src/b.js”]},</p><p>这三种方式都会把文件打包到输出文件中。</p><p>18.output配置，</p><p>①单个入口起点，就设置一个出口，如output:<br>{filename:’bundle.js’,path:’/dist/js’}</p><p>②多个入口起点，可以设置name或者hash，如output:{filename:’[name].js’,path:<strong>dirname+’/dist/js’}<br>或output:{filename:’[name]-[hash].js’,path:</strong>dirname+’/dist/js’}<br>或output:{filename:’[name]-[chunkhash].js’,path:__dirname+’/dist/js’}</p><p>hash值可以认为是版本号或者MD5值保证每个文件的唯一性，每一次修改之后生成文件的hash值不一样，文件名不一样<br>。<br>③publicPath可以理解为占位符。当需要上线的时候可以将服务器地址设置到这个参数中，output:</p><pre><code>{path:&apos;xxx&apos;,filename:&apos;xxx&apos;,publicPath:&apos;http://cdn.com/&apos;}</code></pre><p>插件（plugin）<br>插件是 webpack 的支柱功能。webpack 自身也是构建在 webpack 配置中用到的相同的插件系统之上。插件目的在于解决 loader 无法实现的其他事。</p><p>19.插件html-webpack-plugin<br>要引用之前先安装,在项目文件目录下安装 npm install html-webpack-plugin –save-dev<br>安装好之后，在webpack.config.js配置文件中对插件的引用<br>var htmlWebpackPlugin = require(‘html-webpack-plugin’);//commonJS写法<br>在module.exports中添加plugin部分进行插件初始化，<br>插件列表，当多个bundle需要共享一些相同的插件时，CommonChunkPlugin可以将这些依赖项提取到一个共享包中，以免重复。<br>plugins:[<br>    new webpack.optimize.CommonsChunkPlugin({<br>        …..<br>    }),<br>    new htmlChunkPlugin({<br>        template:’index.html’,//自定义模板<br>        filename:’index-[hash].html’,//生成文件名<br>        inject:’head’,//指定链接注入在<head>标签中还是</head><body>标签中，为false值时表示不自动注入文件中，需要手动设置<br>        title:’webpack demo’,//传递参数，可以在index.html模板中引用<br>        minify:{//压缩html文件，具体参数设置可以查看官方文档</body></p><pre><code>    }})</code></pre><p>]<br>index.html引用配置文件中的参数，JS语法模式，要使用JS语句可以使用&lt;%%&gt;将每行代码包裹起来。赋值可以使用&lt;%=xxx %&gt;，如&lt;%=htmlWebpackPlugin.options.title%&gt;就可以取到配置文件中定义的title的值。<br>在配置文件中可以任意的配置参数向html文件进行传参。<br>自定义引用的js文件可以直接写到html文件中<br>如在html文件中相对应的位置写，</p><p><code>&lt;script src=&quot;&lt;%=htmlWebpackPlugin.files.chunks.main.entry %&gt;&quot;&gt;&lt;/script&gt;    &lt;script src=&quot;&lt;%=htmlWebpackPlugin.chunks.a.entry%&gt;&quot;&gt;&lt;/script&gt;</code></p><p>chunk是文件入口<br>以上是单文件引用的示例，多文件引用则需要调用多次的html-webpack-plugin插件，设置方式相同<br>多页面使用同一个页面模板，可以定义htmlWebpackPlugin插件中的chunks参数，进行设置不同的页面引用不同的chunks，如设置chunks:[‘main’,’a’]<br>excludeChunks:[‘a’],//指出排除的chunk<br>直接将公共初始化脚本嵌入到html页面中，inline方式，在html模板中加上脚本源码引用代码，<br>如</p><p><code>&lt;script type=&quot;text/javascript&quot;&gt;    &lt;%=compilation.assets[htmlWebpackPlugin.files.chunks.main.entry.substr(htmlWebpackPlugin.files.publicPath.length)].source()%&gt;    &lt;/script&gt;</code><br>    //.substr()的作用是将删除publicPath部分的绝对路径获取文件的相对路径。</p><p>按照文件顺序引用js文件可以手动设置for循环出htmlWebpackPlugin.files.chunks的entry值插入文件中。</p><p>20.loader<br>loader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。</p><p>本质上，webpack loader 将所有类型的文件，转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。<br>loader能够import导入任何类型的模块。<br>在webpack的配置中loader有两个目标：</p><p>①.test属性，用于表示出应该被对应的loader进行转换的某个或某些文件。</p><p>②.use属性，表示进行转换时，应该使用那个loader。</p><p>使用方式：<br>①配置，在webpack.config.js中指定<br>②内联，在每个import语句中显示指定loader<br>③CLI，在shell命令中指定</p><p>在webpack.config.js中配置loader</p><p>在module.exports中添加属性module<br>如安装babel插件（js编译器），使用此插件转换ES6代码，如何安装根据官网进行安装：<br>    module:{<br>        rules:[<br>        { test:/.js$/,<br>            exclude:/node_modules/,<br>            loader:”babel-loader”<br>            }<br>        ]<br>    }</p><p>设置preset，指定preset（预配置）设置如何处理js文件</p><p>①在rules中设置query:{presets:[‘latest’]}</p><p>②在根目录下创建一个.babelrc文件,其中内容为：<br>{<br>    “presets”:[“env”]<br>}<br>③在package.json中，增加babel属性：<br>“babel”:{<br>“presets”:[“latset”]<br>}</p><p>21.优化<br>可以在配置文件中，设置打包范围，如exclude设置不处理哪些模块，include处理哪些文件下的内容。<br>具体可以看官方文档进行配置。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在慕课上学习了webpack的课程，做了一些笔记，算分享也算记录吧。教程里的是webpack1和现在的webpack4有很多区别，自己也走了不少的坑，最好使用的时候去看官方文档。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://webpack.js.org/&quot; target
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于Vue生命周期的使用与总结</title>
    <link href="http://suijiafeng.com/2018/06/19/%E5%85%B3%E4%BA%8EVue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%80%BB%E7%BB%93/"/>
    <id>http://suijiafeng.com/2018/06/19/关于Vue生命周期的使用与总结/</id>
    <published>2018-06-19T14:45:00.000Z</published>
    <updated>2018-12-12T04:36:13.346Z</updated>
    
    <content type="html"><![CDATA[<p> 所有的生命周期钩子自动绑定 this 上下文到实例中，因此可以通过其访问数据、运算等，下边会按照生命周期函数执行顺序来讲解</p><ol><li><p>beforeCreate</p><p> 实例初始化后，创建完成之前被调用</p></li><li><p>created</p><p> 实例创建完成后被立即调用，这个时候还没有开始挂载 不能访问 $el</p></li><li><p>beforeMount</p><p> 挂载开始之前调用，即将开始挂载</p><p> 对比：对应 react componentWillMount 在完成首次渲染之前调用 此时仍可以修改组件的状态</p></li><li><p>mounted</p><p> 实例挂载之后调用，但是并不是所有子组件也都一起挂载完成，如果需要整个视图渲染完毕 可以使用 this.$nextTick(function () {})</p><p> 对比：对应 react componentDidMount 完成首次渲染之后调用， 可以在这里操作DOM</p></li><li><p>beforeUpdate</p><p> 数据更新完成前调用，发生在虚拟DOM重新渲染和打补丁前，在这里进一步的更改状态，不会触发重新渲染</p><p> 对比：对应 react componentWillUpdate 接受状态的改变，进行渲染之前调用，不同的是 vue 中允许在这一步更改状态；而 react 则禁止，如果要更改状态要在 react 的 componentWillReceiveProps 声明周期中进行</p></li><li><p>updated</p><p> 更改数据重新渲染虚拟DOM后调用，在这里，组件DOM已经更新，可以执行依赖DOM的操作，但是应该避免在这里更改状态，与 mounted 一样，不能保证所有子组件都挂载完成，可以使用 this.nextTick(function () {})` 进行全部渲染完的操作</p><p> 对比：对应 react componentDidUpdate 完成渲染新的props或者state后调用，此时可以访问到新的DOM元素</p></li><li><p>beforeDestroy</p><p> 实例销毁之前调用，在这一步，实例仍然可用</p><p> 对比：对应 react componentWillUnmount 组件销毁之前调用，做一些清理工作</p></li><li><p>destroyed</p><p> 实例销毁之后调用</p><p> 对比：react 中没有这个生命周期钩子</p></li><li><p>其他</p><p> react 中有 componentWillReceiveProps 这个钩子，用来组件接受更新时调用，可以再次更新 props 或者 state, 在 vue 中虽然没有这个声明周期钩子，但是 vue 实例提供一个 watch 属性，可以用来监视状态改变，与 componentWillReceiveProps 功能类似</p><p> react 中有 shouldComponentUpdate 这个钩子，用来判断决定组件是否需要更新，以减少重新渲染，提升性能；在 vue 中组件是否需要更新，由 vue 框架主动判断，不在需要开发者在这个函数中操作了</p></li></ol><p>总结一下他们大致的用处：<img src="http://suijiafeng.com/images/bg.jpg" alt=""></p><pre><code>beforecreate : 可以在这加个loading事件created ：在这结束loading，还做一些初始化，实现函数自执行 mounted ： 在这发起axios请求，拿回数据，配合路由钩子做一些事情beforeDestory： destoryed ：当前组件已被删除，清空相关内容</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; 所有的生命周期钩子自动绑定 this 上下文到实例中，因此可以通过其访问数据、运算等，下边会按照生命周期函数执行顺序来讲解&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;beforeCreate&lt;/p&gt;
&lt;p&gt; 实例初始化后，创建完成之前被调用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;cre
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>express搭建后台服务器</title>
    <link href="http://suijiafeng.com/2018/06/08/express%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95%E7%9A%84%E5%90%8E%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://suijiafeng.com/2018/06/08/express搭建简单的后台服务器/</id>
    <published>2018-06-07T16:58:00.000Z</published>
    <updated>2018-12-12T04:36:13.346Z</updated>
    
    <content type="html"><![CDATA[<p>在实际开发的项目的过程中，有时候需要数据Api接口，但是，又因为种种原因，后端人员迟迟不能提供api接口。这个时候，<a href="http://mockjs.com/" title="mockjs" target="_blank" rel="noopener">mockjs</a>可以模拟各种随机数据。但是对于像我这样懒的小伙伴，我想给你推荐一个更好，更方便的express搭建服务端框架，废话少说，跟着下面的步骤，就可以轻松搭建一个属于自己的模拟本地服务器。</p><h4 id="安装Express-应用生成器"><a href="#安装Express-应用生成器" class="headerlink" title="安装Express 应用生成器"></a>安装Express 应用生成器</h4><p>此时，默认你已经安装了<a href="https://nodejs.org/en/" target="_blank" rel="noopener">nodejs</a></p><h4 id="运行这个命令装一下Express-应用生成器。"><a href="#运行这个命令装一下Express-应用生成器。" class="headerlink" title="运行这个命令装一下Express 应用生成器。"></a>运行这个命令装一下Express 应用生成器。</h4><pre><code>npm install express-generator -g</code></pre><h4 id="然后创建一个应用，并安装依赖。"><a href="#然后创建一个应用，并安装依赖。" class="headerlink" title="然后创建一个应用，并安装依赖。"></a>然后创建一个应用，并安装依赖。</h4><pre><code>express myappcd myappnpm install</code></pre><p>这时候，myapp文件夹里的文件结构如下：</p><pre><code> //myapp├── app.js├── bin│   └── www├── package.json├── public│   ├── images│   ├── javascripts│   └── stylesheets│   └── style.css├── routes│   ├── index.js│   └── users.js└── views├── error.jade├── index.jade└── layout.jade</code></pre><p>将你想要模拟服务器引用的文件放在pubilc里面，<br>例如：<code>public/myJSON.json</code><br>最后，还有配置一个跨域名的访问的权限，</p><pre><code>`// app.jsvar app = express();app.all(&apos;*&apos;, function(req, res, next) {res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);  //这里的“*”，指的是来访者白名单。res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;X-Requested-With&quot;);res.header(&quot;Access-Control-Allow-Methods&quot;,&quot;PUT,POST,GET,DELETE,OPTIONS&quot;);res.header(&quot;X-Powered-By&quot;,&apos; 3.2.1&apos;)res.header(&quot;Content-Type&quot;, &quot;application/json;charset=utf-8&quot;);next();});`</code></pre><h4 id="启动express服务器"><a href="#启动express服务器" class="headerlink" title="启动express服务器"></a>启动express服务器</h4><pre><code>npm start</code></pre><p>然后在浏览器中打开 <a href="http://localhost:3000/myJson.json" target="_blank" rel="noopener">http://localhost:3000/myJson.json</a>,<br>就能模拟跨域服务器文件访问了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在实际开发的项目的过程中，有时候需要数据Api接口，但是，又因为种种原因，后端人员迟迟不能提供api接口。这个时候，&lt;a href=&quot;http://mockjs.com/&quot; title=&quot;mockjs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;mock
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>js 正则表达式总结</title>
    <link href="http://suijiafeng.com/2018/06/05/js%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
    <id>http://suijiafeng.com/2018/06/05/js正则表达式总结/</id>
    <published>2018-06-05T14:45:00.000Z</published>
    <updated>2018-12-12T04:36:13.346Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>正则表达式(Regular Expression) 是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个规则字符串，这个规则字符串用来表达对字符串的一种过滤逻辑。</p><p>简单来说就是：按照某种规则去匹配符合条件的字符串。正则表达式的规则是/ pattern / flags</p><p>可以使用字面量形式或者new的方式来创建正则表达式</p><pre><code>// 使用直接字面量创建，推荐使用，性能更好，注意这里pattern不能为空，不然以为是注释var exp1 = /\d/g// 使用RegExp对象创建var exp2 = new RegExp(&apos;\d&apos;, &apos;g&apos;);</code></pre><p>模式中使用的所有元字符都建议在之前加\转义，正则表达式中的元字符包括：</p><pre><code>( [ { \ ^ $ | ) ? * + . ] }</code></pre><h2 id="2-内容"><a href="#2-内容" class="headerlink" title="2. 内容"></a>2. 内容</h2><h3 id="2-1-匹配模式"><a href="#2-1-匹配模式" class="headerlink" title="2.1 匹配模式"></a>2.1 匹配模式</h3><p>修饰符表示正则表达式的匹配模式</p><pre><code>修饰符    描述i    执行对大小写不敏感的匹配g    执行全局匹配，查找所有匹配而非在找到第一个匹配后停止m    执行多行匹配，会改变^和$的行为u    可以匹配4字节的unicode编码加了u修饰符，会正确处理大于\uFFFF的unicode，比如4字节的?\uD83D\uDC2A/^\uD83D/.test(&apos;\uD83D\uDC2A&apos;)                // true/^\uD83D/u.test(&apos;\uD83D\uDC2A&apos;)                // false</code></pre><h3 id="2-2-类"><a href="#2-2-类" class="headerlink" title="2.2 类"></a>2.2 类</h3><p>类使用[ ]来表达，用于查找某个范围内的字符</p><pre><code>表达式    描述[abc]    查找方括号之间的任何字符[0-9]    查找任何从 0 至 9 的数字还有一些预定义类方便我们直接使用：预定义类    等价    描述\s    [\t\n\x0B\f\r]    空格\S    [^\t\n\x0B\f\r]    非空格\d    [0-9]    数字\D    [^0-9]    非数字\w    [a-zA-Z_0-9]    单词字符 ( 字母、数字、下划线)\W    [^a-zA-Z_0-9]    非单词字符.    [^\r\n]    任意字符，除了回车与换行外所有字符\f    \x0c \cL    匹配一个换页符\n    \x0a \cJ    匹配一个换行符\r    \x0d \cM    匹配一个回车符\t    \x09 \cI    匹配一个制表符\v    \x0b \cK    匹配一个垂直制表符\xxx    查找以八进制数 xxx 规定的字符\xdd    查找以十六进制数 dd 规定的字符\uxxxx    查找以十六进制数 xxxx 规定的 Unicode 字符</code></pre><h3 id="2-3-量词"><a href="#2-3-量词" class="headerlink" title="2.3 量词"></a>2.3 量词</h3><p>量词表示匹配多少个目标对象，精确匹配长度使用{ }</p><pre><code>量词    等价    描述n*    {0,}    匹配零个或多个nn+    {1,}    匹配至少一个 n 的字符串n?    {0,1}    匹配零个或一个n{n}    匹配n次{n,m}    匹配n到m次{n,}    至少匹配n次</code></pre><h3 id="2-4-边界"><a href="#2-4-边界" class="headerlink" title="2.4 边界"></a>2.4 边界</h3><pre><code>边界    描述^    以xx开始，在类[ ]中表示非$    以xx结束\b    单词边界\B    非单词边界 ^ 匹配字符串开始位置，也就是位置0，如果设置了 RegExp 对象的 Multiline 属性 m ，^ 也匹配 &apos;n&apos; 或 &apos;r&apos; 之后的位置 $ 一般匹配字符串结束位置，如果设置了 RegExp 对象的 Multiline 属性m ，$  也匹配 &apos;n&apos; 或 &apos;r&apos; 之前的位置 \b 匹配一个单词边界，也就是指单词和空格间的位置，如er\b可以匹配&quot;never&quot; 中的 &apos;er&apos;，但不能匹配 &quot;verb&quot; 中的 &apos;er&apos; \B 匹配非单词边界。如er\B能匹配 &quot;verb&quot; 中的 &apos;er&apos;，但不能匹配 &quot;never&quot; 中的 &apos;er&apos;</code></pre><h3 id="2-5-分组"><a href="#2-5-分组" class="headerlink" title="2.5 分组"></a>2.5 分组</h3><p>分组使用( )，作用是提取相匹配的字符串，使量词作用于分组<br>比如hehe{3}是把e匹配了3次而不是单词，如果希望作用于单词，可以使用分组(hehe){3}</p><p>或<br>分组中使用 | 可以达到或的效果<br>比如：T(oo|ii)m可以匹配 Toom 和 Tiim</p><pre><code>`abToomhaTiimmm`.replace(/T(oo|ii)m/g, &apos;-&apos;) // ab-ha-mm</code></pre><p>反向引用<br>使用( )后可以使用$1-$9等来匹配</p><pre><code>&apos;2018-02-11&apos;.replace(/(\d{4})\-(\d{2})\-(\d{2})/g, &apos;$2/$3/$1&apos;) // 02/11/2018</code></pre><p>后向引用<br>\n 表示后向引用，\1是指在正则表达式中，从左往右数第1个( )中的内容；以此类推，\2表示第2个( )，0表示整个表达式。</p><pre><code>//匹配日期格式，表达式中的\1代表重复(\-|\/|.)var rgx = /\d{4}(\-|\/|.)\d{1,2}\1\d{1,2}/rgx.test(&quot;2016-03-26&quot;)             // truergx.test(&quot;2016-03.26&quot;)             // false</code></pre><p>后向引用和反向引用的区别是：\n只能用在表达式中，而$n只能用在表达式之外的地方。</p><p>忽略分组<br>如果不希望捕获某些分组，在分组内加上?:即可<br>比如(?:tom).(ok)那么这里$1指的就是ok</p><p>前瞻<br>前瞻是RegExp匹配到规则的时候，向后检查是否符合断言，后顾JS目前不支持</p><pre><code>名称    正则    描述正向前瞻    (?= )    后面要有xx负向前瞻    (?! )    后面不能有xx&apos;1a2bc*456v8&apos;.replace(/\w(?=\d)/g, &apos;-&apos;)        // 1-2bc*--6-8   匹配后面是数字的单词字符&apos;1a2bc*456v8&apos;.replace(/\w(?!\d)/g, &apos;-&apos;)            // -a---*45-v-   匹配后面不是数字的单词字符(?=exp)匹配一个位置，这个位置的右边能匹配表达式exp，注意这个表达式仅仅匹配一个位置，只是它对于这个位置的右边有要求，而右边的东西是不会被放进结果的，比如用read(?=ing)去匹配&quot;reading&quot;，结果是&quot;read&quot;，而&quot;ing&quot;是不会放进结果的。举个栗子，对密码应用以下限制：其长度必须介于 4 到 8 个字符之间，并且必须至少包含一个数字，正则是/^(?=.*\d).{4,8}$/</code></pre><h3 id="2-6-贪婪模式-与-非贪婪模式"><a href="#2-6-贪婪模式-与-非贪婪模式" class="headerlink" title="2.6 贪婪模式 与 非贪婪模式"></a>2.6 贪婪模式 与 非贪婪模式</h3><p>正则表达式在匹配的时候默认会尽可能多的匹配，叫贪婪模式。通过在限定符后加? 可以进行非贪婪匹配</p><pre><code>比如\d{3,6}默认会匹配6个数字而不是3个，在量词{ }后加一个? 就可以修改成非贪婪模式，匹配3次    `12345678`.replace(/\d{3,6}/, &apos;-&apos;)                // -78`12345678`.replace(/\d{3,6}?/, &apos;-&apos;)                // -45678&apos;abbbb&apos;.replace(/ab+?/, &apos;-&apos;)                // -bbb</code></pre><h3 id="2-7-优先级"><a href="#2-7-优先级" class="headerlink" title="2.7 优先级"></a>2.7 优先级</h3><p>优先级从高到低：</p><pre><code>转义 \括号( )、(?: )、(?= )、[ ]字符和位置或 |</code></pre><h2 id="3-常用属性与方法"><a href="#3-常用属性与方法" class="headerlink" title="3. 常用属性与方法"></a>3. 常用属性与方法</h2><p>3.1 RegExp构造函数属性<br>RegExp构造函数上也包含一些属性，这些属性适用于作用域中所有的正则表达式，并且基于所执行的最近一次正则表达式操作而变化，这些属性分别有一个长属性名和短属性名</p><pre><code>长属性名    短属性名    描述input    $_    返回执行规范表述查找的字符串。只读lastMatch    $&amp;    返回任何正则表达式搜索过程中的最后匹配的字符。只读lastParen    $+    如果有的话，返回任何正则表达式查找过程中最后括的子(分组)匹配。只读leftContext    $`    返回被查找的字符串中从字符串开始位置到最后匹配之前的位置之间的字符。只读rightContext    $&apos;    返回被搜索的字符串中从最后一个匹配位置开始到字符串结尾之间的字符。只读</code></pre><h3 id="3-2-RegExp实例上的属性"><a href="#3-2-RegExp实例上的属性" class="headerlink" title="3.2 RegExp实例上的属性"></a>3.2 RegExp实例上的属性</h3><p>属性    描述<br>    global    是否全文搜索，默认false，对应修饰符的g，只读<br>    ignoreCase    是否大小写敏感，默认false，对应修饰符i，只读<br>    multiline    是否多行搜索，默认false，对应修饰符m，只读<br>    flags    返回修饰符，只读<br>    lastIndex    当前表达式匹配内容的最后一个字符的下一个位置<br>    source    正则表达式的文本字符串</p><h3 id="3-3-常用方法"><a href="#3-3-常用方法" class="headerlink" title="3.3 常用方法"></a>3.3 常用方法</h3><p>方法详细的探究可以看一下文章JS 进阶- test, exec, match, replace</p><p>RegExp.prototype.test(str)<br>测试字符串参数中是否存在匹配正则表达式的字符串，使用.test的时候如果修饰符有g，那么会正则会记住lastIndex并在下一次执行的时候从lastIndex处开始检测，如果只是为了测试是否符合正则，可以不用g或者每次都重新实例化正则表达式</p><pre><code>const reg=/\w/greg.test(&apos;a&apos;)                        // truereg.test(&apos;a&apos;)                        // falseRegExp.prototype.exec(str)</code></pre><p>使用正则表达式对字符串执行搜索，并将更新全局RegExp对象的属性以反映匹配结果<br>如果匹配失败，exec() 方法返回 null<br>如果匹配成功，exec() 方法返回一个数组，并更新正则表达式对象的属性</p><p>数组索引0：匹配的全部字符串<br>数组索引1,2..n：括号中的分组捕获<br>index：属性是匹配文本的第一个字符的位置<br>input：存放被检索的字符串<br>要注意的是：</p><p>exec()永远只返回一个匹配项（指匹配整个正则的）</p><p>如果设置了g修饰符，每次调用exec()会在字符串中继续查找新匹配项，不设置g修饰符，对一个字符串每次调用exec()永远只返回第一个匹配项。所以如果要匹配一个字符串中的所有需要匹配的地方，那么可以设置g修饰符，然后通过循环不断调用exec方法。</p><pre><code>//匹配所有ing结尾的单词const str=&quot;Reading and Writing&quot;const pattern=/\b([a-zA-Z]+)ing\b/glet matcheswhile(matches=pattern.exec(str)){  console.log(matches.index +&apos; &apos;+ matches[0] + &apos; &apos; + matches[1]);}// 0 Reading Read// 12 Writing WritString.prototype.search(reg)</code></pre><p>search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串<br>方法返回第一个匹配结果的index，查找不到返回-1<br>search() 方法不执行全局匹配，它将忽略修饰符g，并且总是从字符串的开始进行检索</p><p>String.prototype.split(reg)<br>split() 方法一般用来分割字符串成数组，也可以传入正则表达式，使用正则可以避免一些传入字符串解决不了的问题</p><pre><code>&apos;a1b2c3d4e&apos;.split(/\d/)            // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]&apos;a b   c&apos;.split(&apos; &apos;)               // [&apos;a&apos;, &apos;b&apos;, &apos;&apos;, &apos;&apos;, &apos;c&apos;]   无法识别连续空格&apos;a b   c&apos;.split(/\s*/)             // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]String.prototype.match(reg)</code></pre><p>match() 方法将检索字符串，以找到一个或多个与reg相匹配的文本，reg是否有修饰符g影响很大<br>返回值与RegExp.prototype.exec的返回类似，不过只返回匹配的字符串数组</p><pre><code>&apos;cdbbdbsdbdbzddzdbbbd&apos;.match(/d(b+)d/g)     //  [&quot;dbbd&quot;, &quot;dbd&quot;, &quot;dbbbd&quot;]&apos;cdbbdbsdbdbzddzdbbbd&apos;.match(/d(b+)d/)     //  [&quot;dbbd&quot;, &quot;bb&quot;, index: 1, input: &quot;cdbbdbsdbdbzddzdbbbd&quot;]</code></pre><p>如果修饰符有g 则匹配出所有匹配的数组，如果不是，则出第一个匹配的字符串，以及相应的捕获内容</p><pre><code>String.prototype.replace(reg, str | num | function)</code></pre><p>找到匹配并替换，传入string、number比较常见，这里传入回调function是比较高级的用法，这里可以参考MDN</p><p>比如一个场景，把手机号的中间4位换成*</p><pre><code>function validateMobile(str) {  return /^[1][0-9]{10}$/.test(str) &amp;&amp; str.replace(/(\d{3})(\d{4})(\d{4})/, (rs, $1, $2, $3) =&gt; `${$1}****${$3}`)}</code></pre><p>也可以不返回值，用回调来遍历，比如一个在面试中会遇到的问题：找出重复最多的字符</p><pre><code>let str = &apos;asss23sjdssskssa7lsssdkjsssdss&apos;const arr = str.split(/\s*/)   // 把字符串转换为数组const str2 = arr.sort().join(&apos;&apos;)      // 首先进行排序，这样结果会把相同的字符放在一起，然后再转换为字符串let value = &apos;&apos;let index = 0str2.replace(/(\w)\1*/g, function($0, $1) {         //匹配字符  if (index &lt; $0.length) {    index = $0.length              // index是出现次数    value = $1                 // value是对应字符  }})console.log(`最多的字符: ${value} ,重复的次数: ${index}`)         // s 17</code></pre><p>商业转载请联系作者获得授权,非商业转载请注明出处。<br>原文: <a href="https://mp.weixin.qq.com/s/_ub6XtBuL4ouJFfZ96cfwg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/_ub6XtBuL4ouJFfZ96cfwg</a>  著作权归 © 微信公众号 “前端大杂烩” 作者所有。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h2&gt;&lt;p&gt;正则表达式(Regular Expression) 是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue项目里前后端接口联调总结</title>
    <link href="http://suijiafeng.com/2018/06/02/vue%E9%A1%B9%E7%9B%AE%E9%87%8C%E5%89%8D%E5%90%8E%E7%AB%AF%E6%8E%A5%E5%8F%A3%E8%81%94%E8%B0%83%E6%80%BB%E7%BB%93/"/>
    <id>http://suijiafeng.com/2018/06/02/vue项目里前后端接口联调总结/</id>
    <published>2018-06-01T17:02:00.000Z</published>
    <updated>2018-12-12T04:36:13.346Z</updated>
    
    <content type="html"><![CDATA[<p>如何实现前后端接口联调</p><p>首先，我们已经知道，目前的前后端分离的架构应用分为两种情况：</p><ol><li>前后端完全分离，前后端分别拥有自己的域名和服务器。</li><li>前后端开发分离，但是部署时是一个域名和一台服务器。</li></ol><p>虽然架构可以采用前后端分离，但是部署有可能就不一样了，这和项目的大小，公司的情况等等都有关系了，一个百八十人用的小系统，还得两台服务器两个域名，你不觉着浪费吗？</p><p>两种不同的部署情况直接导致了前期在设计联调方案的时候就不同了。</p><p>如果你们公司的项目在部署时是两台服务器对应两个域名，恭喜你，这是最nice的方案，也是联调最舒服的方式。</p><p>公司是一家刚起步的小公司，肯定是怎么节省成本怎么来，问过后端，才知道他们公司是属于第二种情况，也就是开发时前后端分离，部署时是一个域名和一台服务器。知道这个之后，就明白接下来该怎么操作了。</p><p>在此之前在项目根目录static文件夹下新建了一个mock文件夹，里面写了一些json文件，当我们做联调的时候，这些mock数据就没用了，我们要把mock数据切换成后端提供给我们的真实的数据。</p><p>当把static文件夹下的mock数据删除之后，在运行项目，发现报错了，浏览器提示，你访问的mock下面的index.json文件找不到404。</p><p>我们平时本地前端开发环境dev地址大多是 localhost:8080，而后台服务器的访问地址就有很多种情况了，比如 后端程序猿本地IP（127.0.0.1:8889），或者外网域名，当前端与后台进行数据交互时，自然就出现跨域问题（后台服务没做处理情况下）。axios不支持jsonp, 所以我们就要使用http-proxy-middleware中间件做代理。</p><p>现在通过在前端修改 vue-cli 的配置可解决：<br>vue-cli中的 config/index.js 下配置 dev选项的 {proxyTable}:</p><p>proxyTable: {<br>    ‘/api’: {<br>        target: ‘127.0.0.1:8889’,  // 真实请求的地址<br>        changeOrigin: true,  // 是否跨域<br>        pathRewrite: {<br>            ‘^/api’: ‘/static/mock’<br>        }<br>    }<br>}</p><p>如果你想在公司的vue项目中实现前后端联调，不需要再使用类似于fiddler charles的抓包代理工具了，你只需要使用proxyTable这个配置项，把你需要请求的后端的服务器地址写在target值里就OK了。</p><p>解决完跨域问题后，接下来王小闰该想想怎么在一台服务器一个域名下进行联调的问题了。比较常见的做法是前端在本地修改，本地查看，测试好了以后上传到服务器，看看线上环境可不可以，OK的话一切都好；不行就本地接着改，然后在上传。</p><p>联调完之后，如何将前端打包的项目文件发给后端，这里也需要注意两点：</p><p>（1）css、js和图片等静态文件</p><p>这时候的静态文件在开发阶段不需要任何考虑，按照你喜欢的相对路径或者相对于项目的根路径的形式写就行了，因为早晚还得交给后端。但是，需要注意：</p><p>如果你采用 相对项目根路径的书写方式来写你的静态文件路径 时，一定要先和后端商量好，将来项目部署的时候他会把你的前端整个项目放在哪里？如果不是根目录下，你就挂了。比如：你的reset.css的路径是 /exports/styles/common/reset.css ，后端把你前端项目放在了根目录下的 frontEnd 文件夹下， reset.css 文件就报404了。</p><p>如果后端采用的java，你需要特别注意的是， tomcat的根目录 并不是 webapps 文件，而后端项目默认是部署在 webapps/ROOT 文件下的，所以你如果使用了相对项目根路径的书写方式来写你的静态文件路径时，对不起又是404了。</p><p>（2）ajax后端数据</p><p>因为现在唯一的一台服务器还是在后端程序猿那里，所以此时你还是可以写绝对路径（域名+请求路径），利用shost文件来改变域名映射实现联调。</p><p>最后，不管是在大公司还是在小公司，都需要知道，并不是说你将dist文件打包发给后端就完事了，就不需要了解leader后面操作的点击部署、合并分支的事儿了，技术时时刻刻在更新，固步自封，迟早的要被淘汰的。</p><p>另外，像基础命令、拉取分支、构建编译包、copy生产包到服务器、备份资料、启动脚本、灰度发布、等等流程其实都是很有必要了解的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如何实现前后端接口联调&lt;/p&gt;
&lt;p&gt;首先，我们已经知道，目前的前后端分离的架构应用分为两种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;前后端完全分离，前后端分别拥有自己的域名和服务器。&lt;/li&gt;
&lt;li&gt;前后端开发分离，但是部署时是一个域名和一台服务器。&lt;/li&gt;
&lt;/ol&gt;
&lt;p
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue2.0 引入 jQurey 的方式</title>
    <link href="http://suijiafeng.com/2018/05/28/vue2-0-%E5%BC%95%E5%85%A5-jQurey-%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <id>http://suijiafeng.com/2018/05/28/vue2-0-引入-jQurey-的方式/</id>
    <published>2018-05-27T17:03:00.000Z</published>
    <updated>2018-12-12T04:36:13.346Z</updated>
    
    <content type="html"><![CDATA[<p>最近学习vue，习惯性的通过<code>&lt;script&gt;</code>标签引入jquery，写完后报错才想起来，这种方式在vue是不适用的。</p><p>1：因为已经安装了vue脚手架，所以需要在webpack中全局引入jquery</p><p>打开<code>package.json</code>文件，在里面的dependencies加入这行代码，jquery后面的是版本，根据你自己需求更改。</p><pre><code> dependencies:{&quot;jquery&quot;:&quot;^2.2.3&quot; }</code></pre><p>然后在命令行中<code>npm install jquery –save-dev</code></p><p>大多人应该都是使用的淘宝镜像，所以使用cnpm，如果你不是 ，可以使用npm安装。</p><p>2：找到build文件夹下的<code>webpack.base.conf.js</code>文件中加入一行代码</p><pre><code>var webpack=require(&quot;webpack&quot;)</code></pre><p>3：然後在webpack.base.conf.js中module.exports的最后加入这行代码，</p><pre><code>  plugins: [new webpack.optimize.CommonsChunkPlugin(&apos;common.js&apos;),new webpack.ProvidePlugin({jQuery: &quot;jquery&quot;,$: &quot;jquery&quot;})]</code></pre><p>4：在main.js中引入,加入下面这行代码</p><pre><code>import $ from &apos;jquery&apos;</code></pre><p>5：最后一步，重新跑一边就好，<code>npm run dev</code></p><p>6.验证方法 在APP.vue里进行验证</p><pre><code>  //app.vue  &lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;img src=&quot;./assets/logo.png&quot;&gt;    &lt;a class=&quot;alert&quot; href=&quot;javascript:;&quot;&gt;點我 &lt;/a&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {  name:&quot;app&quot;,}$(document).ready(function(){  $(&quot;a&quot;).click(function(){    $(this).hide();    alert(&quot;這就對了&quot;)  });});&lt;/script&gt;&lt;style&gt;&lt;/style&gt;</code></pre><p>能夠弹出 alert 内容，就说明jQuery 能正常使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近学习vue，习惯性的通过&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签引入jquery，写完后报错才想起来，这种方式在vue是不适用的。&lt;/p&gt;
&lt;p&gt;1：因为已经安装了vue脚手架，所以需要在webpack中全局引入jquery&lt;/p&gt;
&lt;p&gt;打开&lt;cod
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>項目中常用到的Emmet语法</title>
    <link href="http://suijiafeng.com/2018/05/13/%E9%A0%85%E7%9B%AE%E4%B8%AD%E5%B8%B8%E7%94%A8%E5%88%B0%E7%9A%84Emmet%E8%AF%AD%E6%B3%95/"/>
    <id>http://suijiafeng.com/2018/05/13/項目中常用到的Emmet语法/</id>
    <published>2018-05-13T14:45:00.000Z</published>
    <updated>2018-12-12T04:36:13.362Z</updated>
    
    <content type="html"><![CDATA[<p>Emmet (前身为 Zen Coding) 是一个能大幅度提高前端开发效率的一个工具，基本上，大多数的文本编辑器都会允许你存储和重用一些代码块，我们称之为“片段”。虽然片段能很好地推动你得生产力，但大多数的实现都有这样一个缺点：你必须先定义你得代码片段，并且不能再运行时进行拓展。</p><p>Emmet把片段这个概念提高到了一个新的层次：你可以设置CSS形式的能够动态被解析的表达式，然后根据你所输入的缩写来得到相应的内容。Emmet是很成熟的并且非常适用于编写HTML/XML 和 CSS 代码的前端开发人员，但也可以用于编程语言。<br>下面介紹幾種常見的Emmet語法：</p><h4 id="后代：-gt"><a href="#后代：-gt" class="headerlink" title="后代：&gt;"></a>后代：&gt;</h4><p>缩写：nav&gt;ul&gt;li</p><pre><code>&lt;nav&gt;    &lt;ul&gt;        &lt;li&gt;&lt;/li&gt;    &lt;/ul&gt;&lt;/nav&gt;</code></pre><p>兄弟：+<br>缩写：div+p+bq</p><pre><code>&lt;div&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;/blockquote&gt;</code></pre><p>上级：^<br>缩写：div+div&gt;p&gt;span+em^bq</p><pre><code>&lt;div&gt;&lt;/div&gt;&lt;div&gt;    &lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;    &lt;blockquote&gt;&lt;/blockquote&gt;&lt;/div&gt;</code></pre><p>分组：()<br>缩写：div&gt;(header&gt;ul&gt;li*2&gt;a)+footer&gt;p</p><pre><code>&lt;div&gt;    &lt;header&gt;        &lt;ul&gt;            &lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt;        &lt;/ul&gt;    &lt;/header&gt;    &lt;footer&gt;        &lt;p&gt;&lt;/p&gt;    &lt;/footer&gt;&lt;/div&gt;</code></pre><p>乘法：<em><br>缩写：ul&gt;li</em>5</p><pre><code>&lt;ul&gt;    &lt;li&gt;&lt;/li&gt;    &lt;li&gt;&lt;/li&gt;    &lt;li&gt;&lt;/li&gt;    &lt;li&gt;&lt;/li&gt;    &lt;li&gt;&lt;/li&gt;&lt;/ul&gt;</code></pre><p>自增符号：$<br>缩写：h$[title=item$]{Header $}*3</p><pre><code>&lt;h1 title=&quot;item1&quot;&gt;Header 1&lt;/h1&gt;&lt;h2 title=&quot;item2&quot;&gt;Header 2&lt;/h2&gt;&lt;h3 title=&quot;item3&quot;&gt;Header 3&lt;/h3&gt;</code></pre><h4 id="ID和类属性"><a href="#ID和类属性" class="headerlink" title="ID和类属性"></a>ID和类属性</h4><p>缩写：#header</p><pre><code>&lt;div id=&quot;header&quot;&gt;&lt;/div&gt;</code></pre><p>缩写：.title</p><pre><code>&lt;div class=&quot;title&quot;&gt;&lt;/div&gt;</code></pre><p>缩写：form#search.wide</p><pre><code>&lt;form id=&quot;search&quot; class=&quot;wide&quot;&gt;&lt;/form&gt;</code></pre><p>缩写：p.class1.class2.class3</p><pre><code>&lt;p class=&quot;class1 class2 class3&quot;&gt;&lt;/p&gt;</code></pre><p>自定义属性<br>缩写：p[title=”Hello world”]</p><pre><code>&lt;p title=&quot;Hello world&quot;&gt;&lt;/p&gt;</code></pre><p>文本：{}<br>缩写：a{Click me}</p><pre><code>&lt;a href=&quot;&quot;&gt;Click me&lt;/a&gt;</code></pre><p>缩写：p&gt;{Click }+a{here}+{ to continue}</p><pre><code>&lt;p&gt;Click &lt;a href=&quot;&quot;&gt;here&lt;/a&gt; to continue&lt;/p&gt;</code></pre><p>隐式标签<br>缩写：.class</p><pre><code>&lt;div class=&quot;class&quot;&gt;&lt;/div&gt;</code></pre><p>缩写：em&gt;.class</p><pre><code>&lt;em&gt;&lt;span class=&quot;class&quot;&gt;&lt;/span&gt;&lt;/em&gt;</code></pre><p>缩写：ul&gt;.class</p><pre><code>&lt;ul&gt;     &lt;li class=&quot;class&quot;&gt;&lt;/li&gt;&lt;/ul&gt;</code></pre><p>缩写：table&gt;.row&gt;.col</p><pre><code>&lt;table&gt;    &lt;tr class=&quot;row&quot;&gt;        &lt;td class=&quot;col&quot;&gt;&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;</code></pre><h4 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h4><p>缩写：link:css</p><pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;&quot; /&gt;</code></pre><p>缩写：link:favicon</p><pre><code>&lt;link rel=&quot;shortcut icon&quot; type=&quot;image/x-icon&quot; href=&quot;favicon.ico&quot; /&gt;</code></pre><p>缩写：link:touch</p><pre><code>&lt;link rel=&quot;apple-touch-icon&quot; href=&quot;favicon.png&quot;&gt;</code></pre><p>缩写：script:src</p><pre><code>&lt;script src=&quot;&quot;&gt;&lt;/script&gt;</code></pre><p>别名：input:radio</p><pre><code>&lt;input type=&quot;radio&quot; name=&quot;&quot; id=&quot;&quot; /&gt;</code></pre><p>缩写：input:submit</p><pre><code>&lt;input type=&quot;submit&quot; value=&quot;&quot; /&gt;</code></pre><p>缩写：input:s</p><pre><code>&lt;input type=&quot;submit&quot; value=&quot;&quot; /&gt;</code></pre><p>缩写：input:image</p><pre><code>&lt;input type=&quot;image&quot; src=&quot;&quot; alt=&quot;&quot; /&gt;</code></pre><p>商业转载请联系作者获得授权,非商业转载请注明出处。<br>原文: <a href="https://www.w3cplus.com/tools/emmet-cheat-sheet.html" target="_blank" rel="noopener">https://www.w3cplus.com/tools/emmet-cheat-sheet.html</a> © w3cplus.com著作权归作者所有。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Emmet (前身为 Zen Coding) 是一个能大幅度提高前端开发效率的一个工具，基本上，大多数的文本编辑器都会允许你存储和重用一些代码块，我们称之为“片段”。虽然片段能很好地推动你得生产力，但大多数的实现都有这样一个缺点：你必须先定义你得代码片段，并且不能再运行时进
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux 常用命令简单总结</title>
    <link href="http://suijiafeng.com/2018/05/06/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/"/>
    <id>http://suijiafeng.com/2018/05/06/Linux-常用命令简单总结/</id>
    <published>2018-05-06T05:06:10.000Z</published>
    <updated>2018-12-12T04:36:13.346Z</updated>
    
    <content type="html"><![CDATA[<h2 id="包管理器"><a href="#包管理器" class="headerlink" title="包管理器"></a>包管理器</h2><p>apt-get Debian/Ubuntu系统包管理器<br>apt-get 是Debian/Ubuntu系统中 一个用于快速下载/安装的简单命令行管理工具！</p><p>使用示例：</p><pre><code># 检索 新的包列表apt-get update# 升级 可更新的所有软件包（注意这个命令会升级所有的软件包，所以会升级很长时间）apt-get upgrade# 安装 Nginx 软件包apt-get install nginx# 卸载 Nginx 软件包apt-get remove nginx# 卸载 Nginx 软件包 并删除所有相关配置文件apt-get remove --purge nginx# 在安装软件和卸载的时候，为了避免误操作，都会询问是否继续，每次都要输入 y 来确定会很麻烦，可以加上 -y 参数# 安装 Nginx 软件包 并不显示确定提示apt-get install nginx -y# 卸载 Nginx 软件包，删除所有相关配置文件 并不显示提示apt-get remove --purge nginx -y# 清除 旧的/无用 的软件包apt-get clean &amp;&amp; apt-get autoclean# 下载 Nginx 二进制软件包到当前目录，但不解压和安装apt-get download nginx -d# 更多的命令可以用 apt-get --help 查看。</code></pre><p>yum CentOS系统包管理器<br>yum 是CentOS系统中 一个用于快速下载/安装的简单命令行管理工具！</p><pre><code>使用示例：# 检索 新的包列表yum update# 安装 Nginx 软件包yum install nginx# 安装 Development Tools 软件包组（这个软件包组中包含了编译所需的软件）# 注意：当软件包或者软件包组的名字中包含空格的时候，请把 软件包或软件包组 加上双引号！yum groupinstall &quot;Development Tools&quot;# 卸载 Nginx 软件包yum erase nginx / yum remove nginx# 卸载 Development Tools 软件包组yum groupremove &quot;Development Tools&quot;# 升级 所有可更新的软件包yum upgrade# 升级 Nginx 可更新的软件包yum upgrade nginx# 在安装软件和卸载的时候，为了避免误操作，都会询问是否继续，每次都要输入 y 来确定会很麻烦，可以加上 -y 参数# 安装 Nginx 软件包 并不显示确定提示yum install nginx -y# 卸载 Nginx 软件包 并不显示确定提示yum erase nginx -y / yum remove nginx -y# 搜索 Nginx 软件包是否存着yum search nginx# 列出 可用的软件包yum list# 列出 可用的软件包组yum grouplist# 清除 缓存目录中的所有软件包yum clean# 清除 缓存目录中的 Nginx 软件包yum clean nginx# 重装 Nginx 软件包yum reinstall nginx</code></pre><h2 id="文件-文件夹-操作"><a href="#文件-文件夹-操作" class="headerlink" title="文件/文件夹 操作"></a>文件/文件夹 操作</h2><p>以下除特殊说明，都以当前目录为 /root 示例。</p><p>mkdir 新建 文件夹<br>点击展开 查看 mkdir命令说明</p><pre><code># 在当前文件夹新建一个 bash 文件夹，完整的绝对路径就是 /root/bashmkdir bash# 更多的命令可以用 mkdir --help 查看。cd 进入 文件夹点击展开 查看 cd命令说明# 你当前在 /root目录中，使用这个命令会进入 /root/bash目录，这是相对路径cd bash# 如果你不在 /root目录中的话，就不能用上面的相对路径了，就需要绝对路径cd /root/bash————————————————————————————————————————————————————————————————————————————# 假设你当前在 /root/bash目录中，使用相对路径，你可以用这个命令进入上一级 /root目录， .. 代表相对路径 上级目录cd ..# 当然你也可以用绝对路径来进入上一级 /root目录cd /root</code></pre><p>cp 复制或重命名 文件/文件夹<br> 查看 cp命令说明</p><pre><code># 复制当前目录内的 log.txt文件到 /var目录cp log.txt /var/log.txt# 复制当前目录内的 bash文件夹到 /home目录cp -R bash /home/bash————————————————————————————————————————————————————————————————————————————# 复制当前目录内的所有.txt后缀的文件到 /var/log目录cp *.txt /var/log# 复制当前目录内的所有以 doubi开头的文件到 /var/log目录cp doubi* /var/log# 复制当前目录内的所有以 doubi开头 以.txt后缀结尾的文件到 /var/log目录cp doubi*.txt /var/log————————————————————————————————————————————————————————————————————————————# 假设当前目录是 /root/doubi/log，要把这个目录中的所有.txt后缀的文件复制到上一级目录 /root/doubi，那么这样做cp *.txt ..# .. 就是相对路径，代表上一级目录，当然你也可以用绝对路径，这样更不容易出错cp *.txt /root/doubi————————————————————————————————————————————————————————————————————————————# 重命名当前目录内的 log.txt文件为 log2.txtcp log.txt log2.txt# 复制当前目录内的 log.txt文件到 /var目录并重命名为 log1.txtcp log.txt /var/log1.txt# 复制当前目录内的 bash文件夹到 /home目录并重命名为 bash2cp -R bash /home/bash2————————————————————————————————————————————————————————————————————————————# 复制当前目录内的 log.txt文件到 /var目录，但是 /var 目录中已经存着 log.txt，那么会提示 cp: overwrite `/var/log.txt&apos;? 可以用 -f 强制覆盖cp -f log /var/log.txt# 复制当前目录内的 log.txt log1.txt log2.txt文件和 log233目录到 /home/log目录中cp -R log.txt log1.txt log2.txt log233 /home/log# 更多的命令可以用 cp --help 查看。</code></pre><p>mv 移动或重命名 文件/文件夹<br> 查看 mv命令说明</p><pre><code># 关于 mv 命令，可以参考上面 cp 的使用方法，没什么区别，只是一个是复制，一个是移动，把上面 cp 命令改成 mv 就能套用了。# 移动当前目录内的 log.txt文件到 /var目录mv log.txt /var/log.txt# 移动当前目录内的 bash文件夹到 /home目录mv bash /home/bash————————————————————————————————————————————————————————————————————————————# 重命名当前目录内的 log.txt文件为 log2.txtmv log.txt log2.txt# 复制当前目录内的 log.txt文件到 /var目录并重命名为 log1.txtmv log.txt /var/log1.txt# 复制当前目录内的 bash文件夹到 /home目录并重命名为 bash2mv bash /home/bash2# 更多的命令可以用 mv --help 查看。</code></pre><p>rm 删除 文件/文件夹<br> 查看 rm命令说明</p><pre><code># 删除当前目录下的 log.txt文件rm log.txt# 删除当前目录下所有.txt后缀的文件rm *.txt# 使用 rm 命令删除时，会提示你是否确定删除，输入 y 即删除，输入 n 则取消# rm: remove regular file `log.txt&apos;? y————————————————————————————————————————————————————————————————————————————# 删除当前目录下所有.txt后缀的文件rm *.txt# 删除当前目录下所有以 doubi开头的文件rm doubi*# 删除当前目录下所有以 doubi开头 以.txt后缀结尾的文件rm doubi*.txt————————————————————————————————————————————————————————————————————————————# 当你用 rm 删除目录的时候会发现提示这不是一个文件# rm bash# rm: cannot remove `bash&apos;: Is a directory# 可以加上 -r 来归递删除目录及其目录下的内容rm -r bash————————————————————————————————————————————————————————————————————————————# 因为为了避免手误删除错误，所以 rm默认是加上了 -i 的参数，也就是每一次删除文件/目录都会提示，如果觉得烦可以用 -rf 参数rm -rf bash# rm -rf 这个命令请慎重使用，而且千万不要使用 rm -rf / 或者 rm -rf /* 之类的命令(系统自杀)，可能会让你系统爆炸，所以使用请慎重！# 更多的命令可以用 rm --help 查看。</code></pre><h2 id="查看-编辑文件-操作"><a href="#查看-编辑文件-操作" class="headerlink" title="查看/编辑文件 操作"></a>查看/编辑文件 操作</h2><p>ls 显示目录中文件<br> 查看 ls命令说明</p><pre><code># 显示当前目录下的所有文件ls -a————————————————————————————————————————————————————————————————————————————# 命令后面加上 绝对路径/相对路径 就会显示指定文件夹内的所有文件ls -a bash/log# 相对路径，当前目录是 /root ，欲查看的目录是 /root/bash/logls -a /root/bash/log# 绝对路径， 当前目录是 /root ，欲查看的目录是 /root/bash/log# 更多的命令可以用 ls --help 来查看。</code></pre><p>du 查看 文件/文件夹 占用磁盘空间的大小<br> 查看 du命令说明</p><pre><code>使用示例：# 显示 /root 文件夹的大小，但不显示其子目录和文件的大小du -sh# 显示 /root 文件夹的大小，并显示其子目录和文件的大小du -ah# 待写...# 更多的命令可以用 du --help 来查看。</code></pre><p>cat 查看文件内容<br>     查看 cat命令说明</p><pre><code>假设 log.txt文件的内容为：doubi233doubidoubi666doubi2366doubi8888查看文件：# 查看 log.txt文件的所有内容cat log.txt# 输出示例如下doubi233doubidoubi666doubi2366doubi8888# 查看 log.txt文件的所有内容，并对所有行编号cat -n log.txt# 输出示例如下：     1    doubi233     2    doubi     3         4         5    doubi666     6         7    doubi2366     8    doubi8888# 查看 log.txt文件的所有内容，并对非空行编号cat -b log.txt# 输出示例如下：     1    doubi233     2    doubi     3    doubi666     4    doubi2366     5    doubi8888# 查看 log.txt文件的所有内容，并对非空行编号，且不输出多行空行cat -bs log.txt# 输出示例如下：     1    doubi233     2    doubi     3    doubi666     4    doubi2366     5    doubi8888清空文件：# 清空当前目录中的 log.txt 文件cat /dev/null &gt; log.txt# 清空 /var目录中的 log.txt 文件cat /dev/null &gt; /var/log.txt写入文件：# 写入文本到当前目录中的 log.txt文件中(加入文本到文件内容最后)cat &gt;&gt; log.txt &lt;&lt;-EOFdoubidoubi233doubi666EOF# 清空文件并写入文本到 /var目录中的 log.txt文件中(先清空后写入)cat &gt; /var/log.txt &lt;&lt;-EOFdoubidoubi233doubi666EOF# 更多的命令可以用 cat --help 来查看。</code></pre><p>head 查看文件内容（主要用于正查）</p><pre><code>使用示例：假设 log.txt 文件内容为：doubi1doubi2doubi3doubi4doubi5# 查看 log.txt文件的全部内容head log.txt# 查看 log.txt文件的前 4字节的内容head -c 4 log.txt# 输出示例doub# 查看 log.txt文件的前 2行的内容head -n 2 log.txt# 输出示例doubi1doubi2# 查看 log.txt文件的从倒数第2行到行首的内容head -n -2 log.txt# 输出示例doubi1doubi2doubi3# 查看 log.txt log1.txt log2.txt文件的前 3行内容head -n 3 log.txt log1.txt log2.txt# 更多的命令可以用 head --help 来查看。</code></pre><p>tail 查看文件内容（主要用于倒查）</p><pre><code>使用示例：假设 log.txt 文件内容为：doubi1doubi2doubi3doubi4doubi5# 查看 log.txt文件的全部内容tail log.txt# 查看 log.txt文件从行首 第25字节到最后的内容tail -c +25 log.txt# 输出示例bi4doubi5# 查看 log.txt文件从行尾 第4字节到最前面的内容tail -c -4 log.txt# 输出示例bi5# 查看 log.txt文件的从第2行到最后一行的内容tail -n +2 log.txt# 输出示例doubi2doubi3doubi4doubi5# 查看 log.txt文件的后 2行的内容tail -n -2 log.txt# 输出示例doubi4doubi5# 持续查看（监视） log.txt文件的变化内容（新增加的内容），使用 Ctrl＋C 终止tail -f log.txt# 查看 log.txt log1.txt log2.txt文件的前 3行内容tail -n 3 log.txt log1.txt log2.txt# 更多的命令可以用 tail --help 来查看。</code></pre><p>sed 查看/编辑文件内容<br> 查看 sed命令说明</p><pre><code>参数介绍：-i ：操作后应用保存到原文件（如果不加这个参数，那么任何修改都不会影响原文件里的内容，只会把结果输出）# 待写...# 更多的命令可以用 sed --help 来查看。使用示例：# 查看 log.txt 第3行的内容sed &apos;3p&apos; log.txt# 查看 log.txt 第2-8行的内容sed &apos;2,8p&apos; log.txt# 删除 log.txt 第4行sed -i &apos;4d&apos; log.txt# 删除 log.txt 第3-7行sed -i &apos;3,7d&apos; log.txt# 删除 log.txt 第1行sed -i &apos;1d&apos; log.txt# 删除 log.txt 最后1行sed -i &apos;$d&apos; log.txt# 删除 log.txt 文件中所有包含 233内容的行sed -i &apos;/233/d&apos; log.txt# 替换 log.txt 文件中所有 233为666sed -i &apos;s/233/666/&apos; log.txt# 替换 log.txt 文件中所有 /ver 为 doubi/，因为有斜杠，所以需要使用 \ 转义，但是单引号会导致无法转义，所以要改成双引号。sed -i &quot;s/\/ver/doubi\//&quot; log.txt# 待写...# 更多的命令可以用 sed --help 来查看。</code></pre><h2 id="vim-编辑文件内容"><a href="#vim-编辑文件内容" class="headerlink" title="vim 编辑文件内容"></a>vim 编辑文件内容</h2><p> 查看 vim 命令说明</p><p>vim 介绍</p><p>vim 相当于 vi的扩展或者加强版，一些系统只安装了 vi，所以想要用 vim还需要手动安装( yum install vim -y / apt-get install vim -y)，安装 vim后，会自动替换或者说整合 vi。</p><p>当你使用 vi 命令的时候，首先进入的是 命令行模式，这个模式就是 vi 自身的功能，而点击 I 键 后就会进入编辑模式(插入模式)，这时候就可以直接输入字符了，这个就是 vim的扩展功能了。当修改完成后，按 ESC键 即可退出编辑模式回到命令行模式，这时候输入 :wq 并回车代表保存并退出，如果不想保存可以使用 :q! 不保存强制退出。</p><p>vim的命令行 命令很多，我也没打算都写出来，只写出最常用的好了。</p><pre><code># 打开当前目录下的 log.txt文件，如果没有那么会新建 log.txt文件（安装vim后，使用 vi和 vim打开文件没区别）vi log.txtvim log.txt# 在命令行模式下，直接输入以下 符号和字母(区分大小写)## 进入编辑模式（插入模式，按 Esc键 即可返回命令行模式）i## 删除光标当前所在的一行dd## 删除文件内所有内容dddG## 复制光标当前所在的一行yy## 粘贴刚才复制的一行内容p## 撤销上个操作（误操作可以用这个恢复）u## 保存当前文件（ : 是英文的冒号）:w## 另存当前文件内容为 log2.txt:w log2.txt## 退出当前文件:q## 不保存 并强制退出当前文件:q!## 保存并退出当前文件:wq# 更多的命令可以用 vi --help / vim --help 来查看。</code></pre><h2 id="解压缩-操作"><a href="#解压缩-操作" class="headerlink" title="解压缩 操作"></a>解压缩 操作</h2><p>在Linux中经常会下载到压缩文件，而压缩文件的格式有很多，比如 zip、rar、gz、xz、tar.gz、tar.xz等。</p><p>tar gz zip等 解压 压缩包 示例<br> 查看 解压压缩包说明</p><pre><code># 解压后缀为 .tar 的压缩包tar -xf log.tar————————————————————————————————————————————————————————————————————————————# 解压后缀为 .tar.xz 的压缩包tar -xJf log.tar.xz————————————————————————————————————————————————————————————————————————————# 解压后缀为 .tar.gz 的压缩包，有两个方法tar -xzf log.tar.gz————————————————————————————————————————————————————————————————————————————# 解压后缀为 .gz 的压缩包，有两个方法，如提示命令不存在，请安装 yum install gzip -y / apt-get install gzip -ygzip -d log.gzgunzip log.gz————————————————————————————————————————————————————————————————————————————# 解压后缀为 .bz / .bz2 / tar.bz2 的压缩包，有两个方法bzip2 -d log.bzbunzip2 log.bztar -jxf log.tar.bzbzip2 -d log.bz2bunzip2 log.bz2tar -jxf log.tar.bz2————————————————————————————————————————————————————————————————————————————# 解压后缀为 .Z / tar.Z 的压缩包，有两个方法uncompress log.Z log.txtuncompress log.Z log————————————————————————————————————————————————————————————————————————————tar xZf log.tar.Z log.txttar xZf log.tar.Z log————————————————————————————————————————————————————————————————————————————# 解压后缀为 .rar 的压缩包，如提示命令不存在，请安装 yum install unrar -y / apt-get install unrar -y ，注意 rar 和 unrar 是分开的unrar x log.rar————————————————————————————————————————————————————————————————————————————# 解压后缀为 .zip 的压缩包，如提示命令不存在，请安装 yum install unzip -y / apt-get install unzip -y，注意 zip 和 unzip 是分开的unzip log.zip# 更多的命令可以用 tar --help / gzip --help / unrar --help / unzip --help 来查看。压缩 文件/文件夹 示例点击展开 查看 压缩文件/文件夹说明# 分别压缩当前目录下的 log.txt文件 / log文件夹为 log.tar 压缩包tar -cf log.tar log.txttar -cf log.tar log————————————————————————————————————————————————————————————————————————————# 如果要压缩多个文件和文件夹，那么只需要在后面一直加下去即可tar -cf log.tar log.txt doub.txt log bash————————————————————————————————————————————————————————————————————————————# 分别压缩当前目录下的 log.txt文件 / log文件夹为 log.tar.xz 压缩包，以下的其他后缀压缩命令都是一样tar -cJf log.tar.xz log.txttar -cJf log.tar.xz log————————————————————————————————————————————————————————————————————————————# 分别压缩当前目录下的 log.txt文件 / log文件夹为 log.tar.gz 压缩包tar -czf log.tar.gz log.txttar -czf log.tar.gz log————————————————————————————————————————————————————————————————————————————# 分别压缩当前目录下的 log.txt文件 / log文件夹为 log.gz 压缩包gzip log.gz log.txtgzip log.gz log————————————————————————————————————————————————————————————————————————————# 分别压缩当前目录下的 log.txt文件 / log文件夹为 log.tar.bz 压缩包暂时没查到————————————————————————————————————————————————————————————————————————————# 分别压缩当前目录下的 log.txt文件 / log文件夹为 log.bz / log.tar.bz / log.bz2 / log.tar.bz2压缩包bzip2 -z log.txtbzip2 -z logtar cjf log.tar.bz2 log.txttar cjf log.tar.bz2 log————————————————————————————————————————————————————————————————————————————# 分别压缩当前目录下的 log.txt文件 / log文件夹为 log.Z / log.tar.Z 压缩包compress log.txtcompress logtar cZf log.tar.Z log.txttar cZf log.tar.Z log————————————————————————————————————————————————————————————————————————————# 分别压缩当前目录下的 log.txt文件 / log文件夹为 log.rar 压缩包，如提示命令不存在，请安装 yum install rar -y / apt-get install rar -y ，注意 rar 和 unrar 是分开的unrar a log.rar log.txtunrar a log.rar log————————————————————————————————————————————————————————————————————————————# 分别压缩当前目录下的 log.txt文件 / log文件夹为 log.zip 压缩包，如提示命令不存在，请安装 yum install zip -y / apt-get install zip -y ，注意 zip 和 unzip 是分开的zip log.zip log.txtzip log.zip log# 更多的命令可以用 tar --help / gzip --help / rar --help / zip --help 来查看。</code></pre><h2 id="网络工具"><a href="#网络工具" class="headerlink" title="网络工具"></a>网络工具</h2><p>wget 下载工具<br>wget 是Linux系统最常用的工具之一，命令行方式的多功能下载工具，支持HTTP，HTTPS和FTP协议。</p><p> 查看 wget命令说明</p><pre><code>使用示例：# 下载一个文件到当前目录wget https://softs.fun/100MB.bin# 下载文件到当前目录并重命名为 200MB.binwget -O &quot;200MB.bin&quot; https://softs.fun/100MB.bin# 下载文件到 /root目录（-P只能指定下载目录，并不能指定文件名）wget -P &quot;/root&quot; https://softs.fun/100MB.bin# 下载文件到 /root/doubi目录并重命名为 200MB.binwget -O &quot;/root/doubi/200MB.bin&quot; https://softs.fun/100MB.bin# 下载文件完成之前 wget进程结束了，那么可以使用断点续传重新下载中断的文件（前提是下载服务器支持断点续传）wget -c https://softs.fun/100MB.bin# 通过后台下载文件到 /root/doubi目录并重命名为 200MB.binwget -b -O &quot;/root/doubi/200MB.bin&quot; https://softs.fun/100MB.bin# Continuing in background, pid 2333.# Output will be written to `wget-log&apos;.# 后台下后，你可以使用以下命令来查看下载进度：tail -f wget-log# 有时候一些Linux系统中的SSL证书不完整，会导致下载一些 HTTPS网站文件的时候会验证SSL证书失败，可以这样做# 不验证服务器SSL证书，下载文件到当前目录并重命名为 200MB.binwget --no-check-certificate -O &quot;200MB.bin&quot; https://softs.fun/100MB.bin# 使用wget发送POST请求数据wget --post-data &quot;user=doubi&amp;passwd=23333&quot; https://xxx.xx/# 下载文件到当前目录 并仅通过IPv4连接 只获取比本地新的文件，限速 200KB/Swget --limit-rate=200k -N -4 https://softs.fun/100MB.bin# 下载文件到当前目录 并重试次数为 1，超时时间为 2秒wget -t1 -T2 https://softs.fun/100MB.bin# 通过 wget来获取服务器的外网IP（-qO- 代表运行完会输出下载的信息，并不会保存到本地文件）wget -qO- ipinfo.io/ip# 更多的命令可以用 wget --help 来查看。</code></pre><p>curl 下载工具<br>curl是Linux系统一个利用URL规则在命令行下工作的文件传输工具，是一款很强大的HTTP命令行工具。它支持文件的上传和下载，是综合传输工具，但习惯称curl为下载工具。<br>点击展开 查看 curl命令说明</p><p>使用示例：</p><pre><code># 获取当前服务器的外网IPcurl ipinfo.io/ip# 获取一个文件保存到当前目录中wget -O https://softs.fun/Bash/ssr.sh# 获取一个文件保存到 /root/doubi目录中 并修改文件名为 233.shcurl -o &quot;/root/doubi/233.sh&quot; https://softs.fun/Bash/ssr.sh# 下载文件完成之前 curl进程结束了，那么可以使用断点续传重新下载中断的文件（前提是下载服务器支持断点续传）curl -C -O https://softs.fun/100MB.bin# 有时候一些Linux系统中的SSL证书不完整，会导致访问/下载一些 HTTPS网站/文件的时候会验证SSL证书失败，可以这样做# 不验证服务器SSL证书，下载文件到当前目录并重命名为 233.shcurl -k -o &quot;233.sh&quot; https://softs.fun/Bash/ssr.sh# 使用curl发送GET请求数据curl https://xxx.xx/?user=doubi# 使用curl发送POST请求数据curl --data &quot;user=doubi&amp;passwd=23333&quot; https://xxx.xx/# 下载文件到当前目录 并仅通过IPv4连接，限速 200KB/Scurl --limit-rate 200K -4 https://softs.fun/100MB.bin# 下载文件到当前目录 并重试次数为 1，超时时间为 2秒curl --retry 1 -m 10 https://softs.fun/100MB.bin# 更多的命令可以用 curl --help 来查看。</code></pre><p>netstat 查看链接和端口监听等信息<br>  查看 netstat命令说明</p><pre><code>使用示例：# 显示当前服务器的所有连接信息netstat -a# 显示当前服务器的所有 TCP连接信息netstat -at# 显示当前服务器的所有 UDP连接信息netstat -au一般来说经常使用这个命令：# 显示当前服务器的所有正在监听 TCP端口的信息，并且 显示进程PID和进程名，但不显示别名（域名以IP显示），这个命令算是最常用的了。netstat -lntp# 输出示例Active Internet connections (only servers)Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program nametcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      14233/nginx.conftcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1555/sshd       tcp        0      0 0.0.0.0:443             0.0.0.0:*               LISTEN      14233/nginx.conftcp6       0      0 :::22                   :::*                    LISTEN      1555/sshd# 显示监听 80端口的进程PID和进程名，grep是匹配并显示 符合关键词的行。netstat -lntp|grep &quot;:80&quot;# 输出示例Active Internet connections (only servers)Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program nametcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      14233/nginx.conf# 显示 ssh的监听情况，grep是匹配并显示 符合关键词的行。netstat -lntp|grep &quot;ssh&quot;# 输出示例Active Internet connections (only servers)Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program nametcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1555/sshd表头解释：Proto ：连接协议（tcp/udp是IPv4，tcp6/udp6是IPv6）Recv-Q ： 接收队列（基本都是0，如果不是代表堆积）Send-Q ：发送队列（基本都是0，如果不是代表堆积）Local Address ：本地地址和端口Foreign Address ：对外地址和端口State ：连接状态PID/Program name ：进程PID/进程名# 每隔 1秒显示一次当前服务器的所有连接信息netstat -c# 每隔 1秒显示一次当前服务器的所有 TCP连接信息netstat -ct# 每隔 1秒显示一次当前服务器的所有 UDP连接信息netstat -cu# 显示当前服务器的路由表netstat -r# 显示当前服务器的网络接口信息（网卡）netstat -i# 显示当前服务器的网络统计信息netstat -s# 更多的命令可以用 netstat --help 来查看。</code></pre><p>在使用 netstat命令中，会显示一些连接状态，下面是各状态的意思：</p><pre><code>LISTEN# 监听来自远程连接的 TCP端口连接请求SYN-SENT# 在发送连接请求后，等待匹配的连接请求SYN-RECEIVED# 在收到和发送一个连接请求后，等待对方对连接请求的确认ESTABLISHED# 代表一个打开的连接FIN-WAIT-1# 等待远程 TCP连接中断请求，或先前的连接中断请求的确认FIN-WAIT-2# 从远程 TCP等待连接中断请求 CLOSE-WAIT# 等待从本地用户发来的连接中断请求 CLOSING# 等待远程TCP对连接中断的确认 LAST-ACK# 等待原来的发向远程TCP的连接中断请求的确认 TIME-WAIT# 等待足够的时间，以确保远程TCP接收到连接中断请求的确认 CLOSED# 没有任何连接状态（或者关闭了连接）系统命令</code></pre><p>date 查看/设置 系统时间<br>     查看 date命令说明</p><pre><code>使用示例：# 显示 当前系统时间date# 输出：Wed Apr 5 12:38:44 CST 2017# 显示当前系统的 UTC时间date -u# 输出：Wed Apr 5 04:30:06 UTC 2017# 显示 log.txt 文件的最后修改时间date -r log.txt# 显示 当前日期的年份date +%Y# 输出：2017# 显示 当前日期的月份date +%m# 输出：4# 显示 各种格式类型的日期date +%D# 输出：04/05/17date +%Y-%m-%d# 输出：2017-04-05date +%m/%d/%y# 输出：04/05/17date +%m/%d/%Y# 输出：04/05/2017# 显示 Unix时间戳date +%s# 输出：1491367399# 显示一个完整的时间（年、月、日、小时、分钟、秒钟、周几 时区）date &quot;+%Y-%m-%d %H:%M:%S %u %Z&quot;# 输出：2017-04-05 12:12:15 3 CST# 设置 系统时间（年、月、日）date -s &quot;2017-04-05&quot;# 设置 系统时间（小时、分钟、秒钟）date -s &quot;10:29:05&quot;# 设置 系统时间（年、月、日、小时、分钟、秒钟）date -s &quot;2017-04-05 10:29:05&quot;# 更多的命令可以用 date --help 来查看。</code></pre><p>再教你们一个修改时区为上海（北京）时区的方法：</p><p>cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime<br>然后再用 date 查看时间，就会发现时区变为 CST 了。</p><p>chmod 修改 文件/文件夹 权限<br>点击展开 查看 chmod命令说明</p><pre><code>参数介绍：-c :只输出被改变权限的文件信息-f :当chmod不能改变文件模式时，不通知文件的用户-R :可递归遍历子目录，把修改应到目录下所有文件和子目录-v :无论修改是否成功，输出每个文件的信息# 操作符号：+ :添加某个权限。- :取消某个权限。= :赋予给定权限并取消其他所有权限（如果有的话）。# 权限设置字母：r :可读w :可写x :可执行X :只有目标文件对某些用户是可执行的或该目标文件是目录时才追加x 属性s :在文件执行时把进程的属主或组ID置为该文件的文件属主。方式“u＋s”设置文件的用户ID位，“g＋s”设置组ID位t :保存程序的文本到交换设备上u :当前用户的权限g :当前用户同组的权限o :其他用户的权限# 权限设定数字：# 数字表示的属性含义：0 ：表示没有权限1 ：表示可执行权限2 ：表示可写权限4 ：表示可读权限# 然后将其相加，所以数字属性的格式应为3个从0到7的八进制数，其顺序是（u）（g）（o）。# 如果想让某个文件的属主有“读/写”二种权限，需要把4（可读）+2（可写）＝6（读/写）。# 更多的命令可以用 chmod --help 来查看。使用示例：# 当需要运行 可执行的脚本或者程序（比如 Go语言编写的软件）的时候，需要赋予执行权限chmod +x ssr.sh# 赋予 log.txt 文件可读权限chmod 444 log.txt# 赋予 /ver/log 文件夹 可读、可写权限chmod 666 log.txt# 赋予 /home/www 文件夹 可读、可写、可执行权限chmod 777 log.txt# 赋予 /home/www 文件夹极其所有子目录和文件 可读、可写、可执行权限chmod -R 777 log.txt# 更多的命令可以用 chmod --help 来查看。</code></pre><h2 id="uname-获取操作系统信息"><a href="#uname-获取操作系统信息" class="headerlink" title="uname 获取操作系统信息"></a>uname 获取操作系统信息</h2><p> 查看 uname命令说明</p><pre><code>使用示例：root@doub.date:~# uname       #在使用 uname 的时候，相当于是使用 uname -sLinuxroot@doub.date:~# uname -aLinux doub.date 2.6.32-042stab120.6 #1 SMP Thu Oct 27 16:59:03 MSK 2016 i686 GNU/Linuxroot@doub.date:~# uname -m       #输出一般是64位: x86_64 / 32位: i386 或分支 i686 i686root@doub.date:~# uname -ndoub.dateroot@doub.date:~# uname -r2.6.32-042stab120.6root@doub.date:~# uname -sLinuxroot@doub.date:~# uname -v#1 SMP Thu Oct 27 16:59:03 MSK 2016root@doub.date:~# uname -punknownroot@doub.date:~# uname -iunknownroot@doub.date:~# uname -oGNU/Linux</code></pre><p>我暂时总结到这里，我以后用到还会继续慢慢添加的，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;包管理器&quot;&gt;&lt;a href=&quot;#包管理器&quot; class=&quot;headerlink&quot; title=&quot;包管理器&quot;&gt;&lt;/a&gt;包管理器&lt;/h2&gt;&lt;p&gt;apt-get Debian/Ubuntu系统包管理器&lt;br&gt;apt-get 是Debian/Ubuntu系统中 一个用于快
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue轮播插件的快速使用</title>
    <link href="http://suijiafeng.com/2018/04/30/VUE%E8%BD%AE%E6%92%AD%E5%9B%BE%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BA%E6%96%B9%E6%B3%95/"/>
    <id>http://suijiafeng.com/2018/04/30/VUE轮播图快速构建方法/</id>
    <published>2018-04-30T02:56:00.000Z</published>
    <updated>2018-12-12T04:36:13.346Z</updated>
    
    <content type="html"><![CDATA[<p>Vue-Awesome-Swiper 基于 Swiper4、适用于 Vue 的轮播组件，支持服务端渲染和单页应用。</p><p>如果需要回退到 Swiper3，请使用 v2.6.7 版本<br>跟着下面的步骤，一起构建一个轮播图组件吧。</p><p> 1、使用NPM下载依赖包</p><pre><code>npm install vue-awesome-swiper --save</code></pre><p>2、全局注册</p><pre><code>import Vue from &apos;vue&apos;import VueAwesomeSwiper from &apos;vue-awesome-swiper&apos;// require stylesimport &apos;swiper/dist/css/swiper.css&apos;Vue.use(VueAwesomeSwiper, /* { default global options } */)</code></pre><p>3、复制插件的通用模板</p><pre><code>&lt;!-- The ref attr used to find the swiper instance --&gt;&lt;template&gt;  &lt;swiper :options=&quot;swiperOption&quot; ref=&quot;mySwiper&quot; @someSwiperEvent=&quot;callback&quot;&gt;    &lt;!-- slides --&gt;    &lt;swiper-slide&gt;I&apos;m Slide 1&lt;/swiper-slide&gt;    &lt;swiper-slide&gt;I&apos;m Slide 2&lt;/swiper-slide&gt;    &lt;swiper-slide&gt;I&apos;m Slide 3&lt;/swiper-slide&gt;    &lt;swiper-slide&gt;I&apos;m Slide 4&lt;/swiper-slide&gt;    &lt;swiper-slide&gt;I&apos;m Slide 5&lt;/swiper-slide&gt;    &lt;swiper-slide&gt;I&apos;m Slide 6&lt;/swiper-slide&gt;    &lt;swiper-slide&gt;I&apos;m Slide 7&lt;/swiper-slide&gt;    &lt;!-- Optional controls --&gt;    &lt;div class=&quot;swiper-pagination&quot;  slot=&quot;pagination&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;swiper-button-prev&quot; slot=&quot;button-prev&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;swiper-button-next&quot; slot=&quot;button-next&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;swiper-scrollbar&quot;   slot=&quot;scrollbar&quot;&gt;&lt;/div&gt;  &lt;/swiper&gt;&lt;/template&gt;&lt;script&gt;  export default {    name: &apos;carrousel&apos;,    data() {      return {        swiperOption: {  loop:true,  pagination:{    el:&quot;.swiper-pagination&quot;,    clickable:true  }          // some swiper options/callbacks          // 所有的参数同 swiper 官方 api 参数          // ...        }      }    },    computed: {      swiper() {        return this.$refs.mySwiper.swiper      }    },    mounted() {      // current swiper instance      // 然后你就可以使用当前上下文内的swiper对象去做你想做的事了      console.log(&apos;this is current swiper instance object&apos;, this.swiper)      this.swiper.slideTo(3, 1000, false)    }  }&lt;/script&gt;</code></pre><p>4、根据实际需要，设置轮播图参数，例如，自动轮播，分页器，左右切换控制箭头，滚动速度等；<br>相关配置详情请上 <a href="http://www.swiper.com.cn/api/index2.html" target="_blank" rel="noopener">swiper</a>官网</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Vue-Awesome-Swiper 基于 Swiper4、适用于 Vue 的轮播组件，支持服务端渲染和单页应用。&lt;/p&gt;
&lt;p&gt;如果需要回退到 Swiper3，请使用 v2.6.7 版本&lt;br&gt;跟着下面的步骤，一起构建一个轮播图组件吧。&lt;/p&gt;
&lt;p&gt; 1、使用NPM下载
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue中使用sass的配置的方法</title>
    <link href="http://suijiafeng.com/2018/03/02/vue%E4%B8%AD%E4%BD%BF%E7%94%A8sass%E7%9A%84%E9%85%8D%E7%BD%AE%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://suijiafeng.com/2018/03/02/vue中使用sass的配置的方法/</id>
    <published>2018-03-01T16:56:00.000Z</published>
    <updated>2018-12-12T04:36:13.346Z</updated>
    
    <content type="html"><![CDATA[<p>1、创建一个基于 webpack 模板的新项目</p><pre><code>$ vue init webpack myvue</code></pre><p>2、在当前目录下，安装依赖</p><pre><code>$ cd myvue$ npm install</code></pre><p>3、安装sass的依赖包</p><pre><code>npm install --save-dev sass-loader//sass-loader依赖于node-sassnpm install --save-dev node-sass</code></pre><p>4、在build文件夹下的webpack.base.conf.js的rules里面添加配置</p><pre><code>{  test: /\.sass$/,  loaders: [&apos;style&apos;, &apos;css&apos;, &apos;sass&apos;]}</code></pre><p>5、在APP.vue中修改style标签</p><pre><code>&lt;style lang=&quot;scss&quot;&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、创建一个基于 webpack 模板的新项目&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ vue init webpack myvue
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2、在当前目录下，安装依赖&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd myvue
$ npm install
&lt;/c
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于Ajax</title>
    <link href="http://suijiafeng.com/2017/11/22/%E5%85%B3%E4%BA%8EAjax/"/>
    <id>http://suijiafeng.com/2017/11/22/关于Ajax/</id>
    <published>2017-11-21T17:14:00.000Z</published>
    <updated>2018-12-12T04:36:13.346Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><p><strong> AJAX是异步的JavaScript和XML（Asynchronous JavaScript And XML）</strong>。简单点说，就是使用 <code>XMLHttpRequest</code> 对象与服务器通信。 它可以使用<code>JSON，XML，HTML</code>和文本等多种格式发送和接收。AJAX最吸引人的就是它的“异步”特性，也就是说他可以在不重新刷新页面的情况下与服务器通信，交换数据，更新页面。</p><p>你可以使用AJAX最主要的两个特性做下列事：</p><p>在不重新加载页面的情况下发送请求给服务器。<br>接受并使用从服务器发来的数据。</p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>Ajax的工作原理相当于在用户和服务器之间加了—个中间层,使用户操作与服务器响应异步化。并不是所有的用户请求都提交给服务器,像—些数据验证和数据处理等都交给Ajax引擎自己来做, 只有确定需要从服务器读取新数据时再由Ajax引擎代为向服务器提交请求。</p><h2 id="发送Http请求"><a href="#发送Http请求" class="headerlink" title="发送Http请求"></a>发送Http请求</h2><p> 为了使用JavaScript向服务器发送一个http请求，你需要一个包含必要函数功能的对象实例。这就是为什么会有 XMLHttpRequest 的原因。 这是IE浏览器的ActiveX对象 XMLHTTP的前身。 随后Mozilla，Safari和其他浏览器也都实现了类似的方法，被称为 XMLHttpRequest 。同时，微软也实现了XMLHttpRequest方法。</p><pre><code>// Old compatibility code, no longer needed.if (window.XMLHttpRequest) { // Mozilla, Safari, IE7+ ...    httpRequest = new XMLHttpRequest();} else if (window.ActiveXObject) { // IE 6 and older    httpRequest = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</code></pre><p>Note: 上面代码只是简单版的如何创建一个XMLHttp实例。更实际的例子，请看本篇文章下方简单例子。    </p><p>发送一个请求后，你会收到响应。在这一阶段，你要告诉XMLHttp请求对象是由哪一个JavaScript函数处理响应，在设置了对象的 onreadystatechange属性后给他命名，当请求状态改变时调用函数。</p><pre><code>httpRequest.onreadystatechange = nameOfTheFunction;</code></pre><p>要注意的是，函数名后没有参数，因为你把一个引用赋值给了函数，而不是真正的调用了它。 此外，如果不使用函数名的方式，你还可以用JavaScript的匿名函数响应处理的动作，就像下面这样：</p><pre><code>httpRequest.onreadystatechange = function(){// Process the server response here.};</code></pre><p>接下来，声明当你接到响应后要做什么，你要发送一个实际的请求，通过调用HTTP请求对象的 open() 和 send() 方法，像下面这样:</p><pre><code>httpRequest.open(&apos;GET&apos;, &apos;http://www.example.org/some.file&apos;, true);httpRequest.send();</code></pre><p><code>open()</code>的第一个参数是HTTP请求方法 - 有GET，POST，HEAD以及服务器支持的其他方法。 保证这些方法一定要是大写字母，否则其他一些浏览器（比如FireFox）可能无法处理这个请求。更多关于HTTP的请求方法，可以查看 W3C 文档哈。<br>第二个参数是你要发送的URL。由于安全原因，默认不能调用第三方URL域名。 确保你在页面中使用的是正确的域名，否则在调用 open() 方法是会有 “权限被拒绝” 错误提示。如果你真的需要向另一个域名发送请求, 可以查看 HTTP access control，跨域问题将在后期文章发布。<br>第三个参数是可选的，用于设置请求是否是异步的。如果设为 true (默认设置)，JavaScript执行会持续，并且在服务器还没有响应的情况下与页面进行交互。<br>send() 方法的参数可以是任何你想发送给服务器的内容，如果是 POST 请求的话。发送表单数据时应该用服务器可以解析的格式，像查询语句：</p><pre><code>&quot;name=value&amp;anothername=&quot;+encodeURIComponent(myVar)+&quot;&amp;so=on&quot;</code></pre><p>或者其他格式, 类似 multipart/form-data，JSON，XML等。</p><p>如果你使用 POST 数据，那就需要设置请求的MIME类型。比如，在调用 send() 方法获取表单数据前要有下面这个：</p><pre><code>httpRequest.setRequestHeader(&apos;Content-Type&apos;,&apos;application/x-www-form-urlencoded&apos;);处理服务器响应</code></pre><p>在发送请求时，你提供的JavaScript函数名负责处理响应：</p><p>httpRequest.onreadystatechange = nameOfTheFunction;</p><p>这个函数应该做什么？首先，函数要检查请求的状态。如果状态的值是 XMLHttpRequest.DONE （对应的值是4），意味着服务器响应收到了并且是没问题的，然后就可以继续执行。</p><pre><code>if (httpRequest.readyState === XMLHttpRequest.DONE) {    // Everything is good, the response was received.} else {    // Not ready yet.}</code></pre><p>全部readyState状态值可以查看书籍或者文档，如下也是：</p><p>0 (未初始化) or (请求还未初始化)<br>1 (正在加载) or (已建立服务器链接)<br>2 (加载成功) or (请求已接受)<br>3 (交互) or (正在处理请求)<br>4 (完成) or (请求已完成并且响应已准备好)</p><p>接下来，判断HTTP响应的 response code。 更多响应码可以查看W3C文档。在下面的例子中，我们通过检查响应码 200 OK 区别对待成功和不成功的AJAX调用。</p><pre><code>if (httpRequest.status === 200) {    // Perfect!  } else {    // There was a problem with the request.    // For example, the response may have a 404 (Not Found)    // or 500 (Internal Server Error) response code.}</code></pre><p>在检查完请求状态和HTTP响应码后， 你就可以用服务器返回的数据做任何你想做的了。你有两个方法去访问这些数据：</p><pre><code>httpRequest.responseText –服务器以文本字符的形式返回httpRequest.responseXML – 以 XMLDocument 对象方式返回，之后就可以使用JavaScript来处理</code></pre><p>注意上面这一步只在你发起异步请求时有效（既 open() 的第三个参数未特别指定或设为 true）。如果你你发起的是同步请求则不必使用函数，但是非常不推荐这样子做，它的用户体验很不好。</p><p> 简单的例子 </p><p> 让我们把所有的知识都集中起来做一个简单的HTTP请求。这个JavaScript会请求一个HTML文档 test.html，包含 “I’m a  test” 内容。然后我们 alert() 响应的内容。注意这个例子我们只是用了JavaScript，没有用jQuery。而且，HTML，XML和PHP文件都要放在用一个目录下。</p><pre><code>&lt;button id=&quot;ajaxButton&quot; type=&quot;button&quot;&gt;Make a request&lt;/button&gt;&lt;script&gt;(function() {  var httpRequest;  document.getElementById(&quot;ajaxButton&quot;).addEventListener(&apos;click&apos;, makeRequest);  function makeRequest() {    httpRequest = new XMLHttpRequest();    if (!httpRequest) {      alert(&apos;Giving up :( Cannot create an XMLHTTP instance&apos;);      return false;    }    httpRequest.onreadystatechange = alertContents;    httpRequest.open(&apos;GET&apos;, &apos;test.html&apos;);    httpRequest.send();  }  function alertContents() {    if (httpRequest.readyState === XMLHttpRequest.DONE) {      if (httpRequest.status === 200) {        alert(httpRequest.responseText);      } else {        alert(&apos;There was a problem with the request.&apos;);      }    }  }})();&lt;/script&gt;</code></pre><p>在这个例子中：</p><p>用户点击 “Make a request” 按钮；<br>事件处理调用 makeRequest() 函数；<br>请求已通过然后（onreadystatechange）传给 alertContents() 执行。<br>alertContents() 检查返回的响应是否OK，然后 alert() test.html 文件内容。</p><p>Note: 如果你向一个代码片段发送请求，将返回XML，而不是静态XML文件，在IE浏览器上则必须要设置响应头才能正常工作。如果不设置响应头为 Content-Type:application/xml ，IE浏览器会在你访问XML元素时抛出 “Object Expected” 错误。<br>Note 2: 如果不设置响应头 Cache-Control: no-cache 浏览器将会把响应缓存下来而且再也不无法重新提交请求。你也可以添加一个总是不同的 GET 参数，比如时间戳或者随机数 。</p><p>在通信错误的事件中（例如服务器宕机），在访问响应状态 onreadystatechange 方法中会抛出一个例外。为了缓和这种情况，则可以使用 try…catch 把 if…then 语句包裹起来。</p><pre><code>function alertContents() {  try {    if (httpRequest.readyState === XMLHttpRequest.DONE) {      if (httpRequest.status === 200) {        alert(httpRequest.responseText);      } else {        alert(&apos;There was a problem with the request.&apos;);      }    }  }  catch( e ) {    alert(&apos;Caught Exception: &apos; + e.description);  }}</code></pre><p> 处理XML相应 </p><p> 在上一个例子中，在收到HTTP请求的响应后我们会请求对象的 responseText 属性，包含 test.html 文件的内容。现在我们试试 responseXML属性。 </p><p>首先，我们创建一个稍后将要请求的有效的 XML 文档。文档（test.html）包含以下内容：</p><pre><code>&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;root&gt;    I&apos;m a test.&lt;/root&gt;</code></pre><p>在脚本里我们只需要把请求行改为：</p><pre><code>...onclick=&quot;makeRequest(&apos;test.xml&apos;)&quot;&gt;...</code></pre><p>然后在 alertContents() 里，我们把 alert(httpRequest.responseText) 改为：</p><pre><code>pRequest.responseXML;var root_node = xmldoc.getElementsByTagName(&apos;root&apos;).item(0);alert(root_node.firstChild.data);</code></pre><p>这部分代码采用 responseXML 提供的 XMLDocument 对象，并使用 DOM 方法访问 XML 文档中包含的一些数据。你可以在这里查看 test.xml 并且在这里更新测试代码。</p><p> 处理数据 </p><p>最后，我们发送一个数据给服务器并收到响应。这次我们用 JavaScript 请求动态页面，test.php  并返回一个计算后的字符串 - “Hello, [user date]”，并用 alert() 出来。</p><p>首先要添加一个文本到 HTML 中以方便用户输入名字：</p><pre><code>&lt;label&gt;Your name: &lt;input type=&quot;text&quot; id=&quot;ajaxTextbox&quot; /&gt;&lt;/label&gt;&lt;span id=&quot;ajaxButton&quot; style=&quot;cursor: pointer; text-decoration: underline&quot;&gt;  Make a request&lt;/span&gt;    还要添加事件处理程序，从表单中获取用户数据连同服务器端的UTL一并发送给 makeRequest()  函数：document.getElementById(&quot;ajaxButton&quot;).onclick = function() {       var userName = document.getElementById(&quot;ajaxTextbox&quot;).value;      makeRequest(&apos;test.php&apos;,userName);   };</code></pre><p>我们还要修改 makeRequest() 让它接受用户数据并将其发给服务器。把请求方法从 GET 改为 POST，把数据作为参数让httpRequest.send() 调用。</p><pre><code>uest(url, userName) {    ...    httpRequest.onreadystatechange = alertContents;    httpRequest.open(&apos;POST&apos;, url);    httpRequest.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded&apos;);    httpRequest.send(&apos;userName=&apos; + encodeURIComponent(userName));  }</code></pre><p> 如果这就是服务器返回的全部内容，alertContents() 函数可以使用 简单例子 中的相同函数写。可是，服务器会返回计算后的内容和原内容。所以，如果用户输入 “Jane” 在输入框中，那服务器就会返回如下内容：</p><pre><code>{&quot;userData&quot;:&quot;Jane&quot;,&quot;computedString&quot;:&quot;Hi, Jane!&quot;}</code></pre><p>为了在 alertContents() 中使用这个数据，我们可不能只是alert responseText ，我们要解析它并 alertconputedString，我们想要的属性：</p><pre><code>function alertContents() {  if (httpRequest.readyState === XMLHttpRequest.DONE) {    if (httpRequest.status === 200) {      var response = JSON.parse(httpRequest.responseText);      alert(response.computedString);    } else {      alert(&apos;There was a problem with the request.&apos;);    }  }}</code></pre><p>test.php 文件应该包含一下内容：</p><pre><code>$name = (isset($_POST[&apos;userName&apos;])) ? $_POST[&apos;userName&apos;] : &apos;no name&apos;;$computedString = &quot;Hi, &quot; . $name;$array = [&apos;userName&apos; =&gt; $name, &apos;computedString&apos; =&gt; $computedString];echo json_encode($array);</code></pre><p> 优点 </p><p>优秀的用户体验<br>减轻服务器和带宽的负担，节约空间和宽带租用成本。<br>提高Web程序的性能<br>基于标准化的并被广泛支持的技术，不需要下载插件或者小程序。 </p><p> 缺点 </p><p>破坏浏览器前进，后退按钮的正常</p><p>开发和调试工具缺乏。</p><p>对搜索引擎的支持比较弱。</p><p>破坏了程序的异常机制。</p><p>违背了url和资源定位的初衷。采用了ajax技术，真正url地址下面看到的和我在这个url地址下看到的内容是不同的</p><p>一些手持设备（如手机、PDA等）现在还不能很好的支持ajax。</p><p>浏览器对XMLHttpRequest对象的支持度不足</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Ajax&quot;&gt;&lt;a href=&quot;#Ajax&quot; class=&quot;headerlink&quot; title=&quot;Ajax&quot;&gt;&lt;/a&gt;Ajax&lt;/h1&gt;&lt;p&gt;&lt;strong&gt; AJAX是异步的JavaScript和XML（Asynchronous JavaScript And XM
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CSS 的 BEM 书写规范 </title>
    <link href="http://suijiafeng.com/2017/10/07/CSS%20%E7%9A%84%20BEM%20%E4%B9%A6%E5%86%99%E8%A7%84%E8%8C%83/"/>
    <id>http://suijiafeng.com/2017/10/07/CSS 的 BEM 书写规范/</id>
    <published>2017-10-07T08:02:00.000Z</published>
    <updated>2018-12-12T04:36:13.331Z</updated>
    
    <content type="html"><![CDATA[<p>使用 BEM 命名规范，理论上讲，每行 css 代码都只有一个选择器。</p><p>BEM代表“块（block）,元素（element）,修饰符（modifier）”,我们常用这三个实体开发组件。</p><p>在选择器中，由以下三种符合来表示扩展的关系：</p><pre><code>  -   中划线 ：仅作为连字符使用，表示某个块或者某个子元素的多单词之间的连接记号。  __  双下划线：双下划线用来连接块和块的子元素  _   单下划线：单下划线用来描述一个块或者块的子元素的一种状态type-block__element_modifier</code></pre><h3 id="块（block）"><a href="#块（block）" class="headerlink" title="块（block）"></a>块（block）</h3><p>一个块是设计或布局的一部分，它有具体且唯一地意义 ，要么是语义上的要么是视觉上的。</p><p>在大多数情况下，任何独立的页面元素（或复杂或简单）都可以被视作一个块。它的HTML容器会有一个唯一的CSS类名，也就是这个块的名字。</p><p>针对块的CSS类名会加一些前缀（ ui-），这些前缀在CSS中有类似 命名空间 的作用。</p><p>一个块的正式（实际上是半正式的）定义有下面三个基本原则：</p><p>CSS中只能使用类名（不能是ID）。<br>每一个块名应该有一个命名空间（前缀）<br>每一条CSS规则必须属于一个块。<br>例如：一个自定义列表 .list 是一个块，通常自定义列表是算在 mod 类别的，在这种情况下，一个 list 列表的block写法应该为:</p><p>.list   </p><h3 id="元素（element）"><a href="#元素（element）" class="headerlink" title="元素（element）"></a>元素（element）</h3><p>块中的子元素是块的子元素，并且子元素的子元素在 bem 里也被认为是块的直接子元素。一个块中元素的类名必须用父级块的名称作为前缀。</p><p>如上面的例子，li.item 是列表的一个子元素，</p><p>.list{}<br>.list .item{}</p><p>.list{}<br>.list__item{}</p><h3 id="修饰符（modifier）"><a href="#修饰符（modifier）" class="headerlink" title="修饰符（modifier）"></a>修饰符（modifier）</h3><p>一个“修饰符”可以理解为一个块的特定状态，标识着它持有一个特定的属性。</p><p>用一个例子来解释最好不过了。一个表示按钮的块默认有三个大小：小，中，大。为了避免创建三个不同的块，最好是在块上加修饰符。这个修饰符应该有个名字（比如：size ）和值（ small，normal 或者 big ）。</p><p>如上面的例子中，表示一个选中的列表，和一个激活的列表项</p><pre><code>.list{}.list.select{}.list .item{}.list .item.active{}.list{}.list_select{}.list__item{}.list__item_active{}</code></pre><p>LESS 书写规范<br>使用 .less 后缀的文件来存储变量、混合代码以及最终合并压缩。</p><p>子less    注解<br>lib-base.less    预定义的变量，例如颜色、字号、字体<br>lib-mixins.less    用于混合的代码，例如渐变、半透明的混合<br>lib-reset.less    初始化<br>lib-ui.less    颗粒化ui功能<br>xxx.less    模块样式<br>.less 文件的引用顺序会对最终编译的样式的作用域和优先级产生影响，请尽量按照由底层到自定义的顺序来引用。</p><p>关于风格<br>书写原则</p><ol><li><p>原则上不会出现2层以上选择器嵌套<br>使用BEM原则，用命名来解耦，所有类名都为一层，增加效率和复用性</p></li><li><p>两层选择器嵌套出现在.mod-xxx__item_current子元素的情况，如下：<br>使用推荐的嵌套写法</p></li></ol><p>常规写法：</p><pre><code>.xxx{}.xxx__item{}.xxx__item_current{}// 嵌套写法.xxx__item_current .mod-xxx__link{}推荐：.xxx{}.xxx__item{}.xxx__item_hightlight{}.xxx__product-name{}.xxx__link{}.xxx__ming-zi-ke-yi-hen-chang{}// 嵌套写法.xxx__item_current{.xxx__link{}}</code></pre><p>对应的HTML结构如下：</p><pre><code>&lt;ul class=&quot;xxx&quot;&gt;&lt;li class=&quot;xxx__item&quot;&gt;第一项&lt;div class=&quot;xxx__product-name&quot;&gt;我是名称&lt;/div&gt;&lt;span class=&quot;xxx__ming-zi-ke-yi-hen-chang&quot;&gt;看类名&lt;/span&gt;&lt;a href=&quot;#&quot; class=&quot;xxx__link&quot;&gt;我是link&lt;/a&gt;&lt;li&gt;&lt;li class=&quot;xxx__item xxx__item_current&quot;&gt;第二项 且 当前选择项&lt;div class=&quot;xxx__product-name&quot;&gt;我是名称&lt;/div&gt;&lt;a href=&quot;#&quot; class=&quot;xxx__item-link&quot;&gt;我是link&lt;/a&gt;&lt;li&gt;&lt;li class=&quot;xxx__item xxx__item_hightlight&quot;&gt;第三项 且 特殊高亮 &lt;div class=&quot;xxx__product-name&quot;&gt;我是名称&lt;/div&gt;&lt;a href=&quot;#&quot; class=&quot;xxx__item-link&quot;&gt;我是link&lt;/a&gt;&lt;li&gt;&lt;/ul&gt;</code></pre><p>BEM 解决问题<br>组件之间的完全解耦，不会造成命名空间的污染，如：.mod-xxx ul li 的写法带来的潜在的嵌套风险。</p><p>性能<br>BEM 命名会使得 Class 类名变长，但经过 gzip 压缩后这个带宽开销可以忽略不计</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用 BEM 命名规范，理论上讲，每行 css 代码都只有一个选择器。&lt;/p&gt;
&lt;p&gt;BEM代表“块（block）,元素（element）,修饰符（modifier）”,我们常用这三个实体开发组件。&lt;/p&gt;
&lt;p&gt;在选择器中，由以下三种符合来表示扩展的关系：&lt;/p&gt;
&lt;pr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>35个Jquery小技巧</title>
    <link href="http://suijiafeng.com/2017/08/04/35%E4%B8%AAJquery%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>http://suijiafeng.com/2017/08/04/35个Jquery小技巧/</id>
    <published>2017-08-03T17:07:00.000Z</published>
    <updated>2018-12-12T04:36:13.331Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-禁止右键点击"><a href="#1-禁止右键点击" class="headerlink" title="1.禁止右键点击"></a>1.禁止右键点击</h2><p>$(document).ready(function(){<br>    $(document).bind(“contextmenu”,function(e){<br>        return false;<br>    });<br>});</p><h2 id="2-隐藏搜索文本框文字"><a href="#2-隐藏搜索文本框文字" class="headerlink" title="2.隐藏搜索文本框文字"></a>2.隐藏搜索文本框文字</h2><pre><code>$(document).ready(function() {$(&quot;input.text1&quot;).val(&quot;Enter your search text here&quot;);   textFill($(&apos;input.text1&apos;));});function textFill(input){ //input focus text function var originalvalue = input.val(); input.focus( function(){      if( $.trim(input.val()) == originalvalue ){ input.val(&apos;&apos;); } }); input.blur( function(){      if( $.trim(input.val()) == &apos;&apos; ){ input.val(originalvalue); } });}</code></pre><h2 id="3-在新窗口中打开链接"><a href="#3-在新窗口中打开链接" class="headerlink" title="3.在新窗口中打开链接"></a>3.在新窗口中打开链接</h2><p>XHTML 1.0 Strict doesn’t allow this attribute in the code, so use this to keep the code valid.</p><pre><code>$(document).ready(function() {   //Example 1: Every link will open in a new window   $(&apos;a[href^=&quot;http://&quot;]&apos;).attr(&quot;target&quot;, &quot;_blank&quot;);   //Example 2: Links with the rel=&quot;external&quot; attribute will only open in a new window   (&apos;a[@rel=&apos;external&apos;]&apos;).click(function(){ this.target = &quot;_blank&quot;;</code></pre><p>   });<br>});<br>// how to use<br><a href="http://www.opensourcehunter.com" rel="noopener" target="_blank">open link</a></p><ol><li>检测浏览器</li></ol><p>注: 在版本jQuery 1.4中，$.support 替换掉了$.browser 变量</p><p>$(document).ready(function() {<br>// Target Firefox 2 and above<br>if ($.browser.mozilla &amp;&amp; $.browser.version &gt;= “1.8” ){<br>    // do something<br>}</p><p>// Target Safari<br>if( $.browser.safari ){<br>    // do something<br>}</p><p>// Target Chrome<br>if( $.browser.chrome){<br>    // do something<br>}</p><p>// Target Camino<br>if( $.browser.camino){<br>    // do something<br>}</p><p>// Target Opera<br>if( $.browser.opera){<br>    // do something<br>}</p><p>// Target IE6 and below<br>if ($.browser.msie &amp;&amp; $.browser.version &lt;= 6 ){<br>    // do something<br>}</p><p>// Target anything above IE6<br>if ($.browser.msie &amp;&amp; $.browser.version &gt; 6){<br>    // do something<br>}<br>});</p><ol><li>预加载图片</li></ol><p>This piece of code will prevent the loading of all images, which can be useful if you have a site with lots of images.</p><p>$(document).ready(function() {<br>jQuery.preloadImages = function()<br>{<br>  for(var i = 0; i<arguments.length; jquery(?<img="" {="" i++)="">“).attr(“src”, arguments[i]);<br>  }<br>}<br>// how to use<br>$.preloadImages(“image1.jpg”);<br>});</arguments.length;></p><ol><li>页面样式切换</li></ol><p>$(document).ready(function() {<br>    $(“a.Styleswitcher”).click(function() {<br>        //swicth the LINK REL attribute with the value in A REL attribute<br>        $(‘link[rel=stylesheet]’).attr(‘href’ , $(this).attr(‘rel’));<br>    });<br>// how to use<br>// place this in your header</p><p><link rel="stylesheet" type="text/css" href="default.css"><br>// the links</p><p><a class="Styleswitcher" href="#" rel="default.css">Default Theme</a></p><p><a class="Styleswitcher" href="#" rel="red.css">Red Theme</a></p><p><a class="Styleswitcher" href="#" rel="blue.css">Blue Theme</a><br>});</p><ol><li>列高度相同</li></ol><p>如果使用了两个CSS列，使用此种方式可以是两列的高度相同。</p><p>$(document).ready(function() {<br>function equalHeight(group) {<br>    tallest = 0;<br>    group.each(function() {<br>        thisHeight = $(this).height();<br>        if(thisHeight &gt; tallest) {<br>            tallest = thisHeight;<br>        }<br>    });<br>    group.height(tallest);<br>}<br>// how to use<br>$(document).ready(function() {<br>    equalHeight($(“.left”));<br>    equalHeight($(“.right”));<br>});<br>});</p><ol><li>动态控制页面字体大小</li></ol><p>用户可以改变页面字体大小</p><p>$(document).ready(function() {<br>  // Reset the font size(back to default)<br>  var originalFontSize = $(‘html’).css(‘font-size’);<br>    $(“.resetFont”).click(function(){<br>    $(‘html’).css(‘font-size’, originalFontSize);<br>  });<br>  // Increase the font size(bigger font0<br>  $(“.increaseFont”).click(function(){<br>    var currentFontSize = $(‘html’).css(‘font-size’);<br>    var currentFontSizeNum = parseFloat(currentFontSize, 10);<br>    var newFontSize = currentFontSizeNum<em>1.2;<br>    $(‘html’).css(‘font-size’, newFontSize);<br>    return false;<br>  });<br>  // Decrease the font size(smaller font)<br>  $(“.decreaseFont”).click(function(){<br>    var currentFontSize = $(‘html’).css(‘font-size’);<br>    var currentFontSizeNum = parseFloat(currentFontSize, 10);<br>    var newFontSize = currentFontSizeNum</em>0.8;<br>    $(‘html’).css(‘font-size’, newFontSize);<br>    return false;<br>  });<br>});</p><ol><li>返回页面顶部功能</li></ol><p>For a smooth(animated) ride back to the top(or any location).</p><p>$(document).ready(function() {<br>$(‘a[href*=#]’).click(function() {<br> if (location.pathname.replace(/^\//,’’) == this.pathname.replace(/^\//,’’)<br> &amp;&amp; location.hostname == this.hostname) {<br>   var $target = $(this.hash);<br>   $target = $target.length &amp;&amp; $target<br>   || $(‘[name=’ + this.hash.slice(1) +’]’);<br>   if ($target.length) {<br>  var targetOffset = $target.offset().top;<br>  $(‘html,body’)<br>  .animate({scrollTop: targetOffset}, 900);<br>    return false;<br>   }<br>  }<br>  });<br>// how to use<br>// place this where you want to scroll to</p><p><a name="top"></a><br>// the link</p><p><a href="#top">go to top</a><br>});</p><ol><li>获得鼠标指针ＸＹ值</li></ol><p>Want to know where your mouse cursor is?</p><p>$(document).ready(function() {<br>   $().mousemove(function(e){<br>     //display the x and y axis values inside the div with the id XY<br>    $(‘#XY’).html(“X Axis : “ + e.pageX + “ | Y Axis “ + e.pageY);<br>  });<br>// how to use</p><div id="XY"></div><p>});<br>11.返回顶部按钮</p><p>你可以利用 animate 和 scrollTop 来实现返回顶部的动画，而不需要使用其他插件。</p><p>// Back to top<br>$(‘a.top’).click(function () {<br>  $(document.body).animate({scrollTop: 0}, 800);<br>  return false;<br>});<br><!-- Create an anchor tag --><br><a class="top" href="#">Back to top</a><br>改变 scrollTop 的值可以调整返回距离顶部的距离，而 animate 的第二个参数是执行返回动作需要的时间(单位：毫秒)。</p><p>12.预加载图片</p><p>如果你的页面中使用了很多不可见的图片（如：hover 显示），你可能需要预加载它们：</p><p>$.preloadImages = function () {<br>  for (var i = 0; i &lt; arguments.length; i++) {<br>    $(‘<img>‘).attr(‘src’, arguments[i]);<br>  }<br>};</p><p>$.preloadImages(‘img/hover1.png’, ‘img/hover2.png’);<br>13.检查图片是否加载完成</p><p>有时候你需要确保图片完成加载完成以便执行后面的操作：</p><p>$(‘img’).load(function () {<br>  console.log(‘image load successful’);<br>});<br>你可以把 img 替换为其他的 ID 或者 class 来检查指定图片是否加载完成。</p><p>14.自动修改破损图像</p><p>如果你碰巧在你的网站上发现了破碎的图像链接，你可以用一个不易被替换的图像来代替它们。添加这个简单的代码可以节省很多麻烦：</p><p>$(‘img’).on(‘error’, function () {<br>  $(this).prop(‘src’, ‘img/broken.png’);<br>});<br>即使你的网站没有破碎的图像链接，添加这段代码也没有任何害处。</p><p>15.鼠标悬停(hover)切换 class 属性</p><p>假如当用户鼠标悬停在一个可点击的元素上时，你希望改变其效果，下面这段代码可以在其悬停在元素上时添加 class 属性，当用户鼠标离开时，则自动取消该 class 属性：</p><p>$(‘.btn’).hover(function () {<br>  $(this).addClass(‘hover’);<br>  }, function () {<br>    $(this).removeClass(‘hover’);<br>  });<br>你只需要添加必要的CSS代码即可。如果你想要更简洁的代码，可以使用 toggleClass 方法：</p><p>$(‘.btn’).hover(function () {<br>  $(this).toggleClass(‘hover’);<br>});<br>注：直接使用CSS实现该效果可能是更好的解决方案，但你仍然有必要知道该方法。</p><p>16.禁用 input 字段</p><p>有时你可能需要禁用表单的 submit 按钮或者某个 input 字段，直到用户执行了某些操作（例如，检查“已阅读条款”复选框）。可以添加 disabled 属性，直到你想启用它时：</p><p>$(‘input[type=”submit”]’).prop(‘disabled’, true);<br>你要做的就是执行 removeAttr 方法，并把要移除的属性作为参数传入：</p><p>$(‘input[type=”submit”]’).removeAttr(‘disabled’);<br>17.阻止链接加载</p><p>有时你不希望链接到某个页面或者重新加载它，你可能希望它来做一些其他事情或者触发一些其他脚本，你可以这么做：</p><p>$(‘a.no-link’).click(function (e) {<br>  e.preventDefault();<br>});<br>18.切换 fade/slide</p><p>fade 和 slide 是我们在 jQuery 中经常使用的动画效果，它们可以使元素显示效果更好。但是如果你希望元素显示时使用第一种效果，而消失时使用第二种效果，则可以这么做：</p><p>// Fade<br>$(‘.btn’).click(function () {<br>  $(‘.element’).fadeToggle(‘slow’);<br>});<br>// Toggle<br>$(‘.btn’).click(function () {<br>  $(‘.element’).slideToggle(‘slow’);<br>});<br>19.简单的手风琴效果</p><p>这是一个实现手风琴效果快速简单的方法：</p><p>// Close all panels<br>$(‘#accordion’).find(‘.content’).hide();<br>// Accordion<br>$(‘#accordion’).find(‘.accordion-header’).click(function () {<br>  var next = $(this).next();<br>  next.slideToggle(‘fast’);<br>  $(‘.content’).not(next).slideUp(‘fast’);<br>  return false;<br>});</p><p>20.让两个 DIV 高度相同</p><p>有时你需要让两个 div 高度相同，而不管它们里面的内容多少。可以使用下面的代码片段：</p><p>var $columns = $(‘.column’);<br>var height = 0;<br>$columns.each(function () {<br>  if ($(this).height() &gt; height) {<br>    height = $(this).height();<br>  }<br>});<br>$columns.height(height);<br>这段代码会循环一组元素，并设置它们的高度为元素中的最大高。</p><ol><li>验证元素是否为空</li></ol><p>This will allow you to check if an element is empty.</p><p>$(document).ready(function() {<br>  if ($(‘#id’).html()) {<br>   // do something<br>   }<br>});</p><ol><li>替换元素</li></ol><p>Want to replace a div, or something else?</p><p>$(document).ready(function() {<br>   $(‘#id’).replaceWith(‘</p><div>I have been replaced</div><p>‘);<br>});</p><ol><li>jQuery延时加载功能</li></ol><p>Want to delay something?</p><p>$(document).ready(function() {<br>   window.setTimeout(function() {<br>     // do something<br>   }, 1000);<br>});</p><ol><li>移除单词功能</li></ol><p>Want to remove a certain word(s)?</p><p>$(document).ready(function() {<br>   var el = $(‘#id’);<br>   el.html(el.html().replace(/word/ig, “”));<br>});</p><ol><li>验证元素是否存在于jquery对象集合中</li></ol><p>Simply test with the .length property if the element exists.</p><p>$(document).ready(function() {<br>   if ($(‘#id’).length) {<br>  // do something<br>  }<br>});</p><ol><li>使整个DIV可点击</li></ol><p>Want to make the complete div clickable?</p><p>$(document).ready(function() {<br>    $(“div”).click(function(){<br>      //get the url from href attribute and launch the url<br>      window.location=$(this).find(“a”).attr(“href”); return false;<br>    });<br>// how to use</p><div><a href="index.html">home</a></div><p>});</p><ol><li>ID与Class之间转换</li></ol><p>当改变Window大小时，在ID与Class之间切换</p><p>$(document).ready(function() {<br>   function checkWindowSize() {<br>    if ( $(window).width() &gt; 1200 ) {<br>        $(‘body’).addClass(‘large’);<br>    }<br>    else {<br>        $(‘body’).removeClass(‘large’);<br>    }<br>   }<br>$(window).resize(checkWindowSize);<br>});</p><ol><li>克隆对象</li></ol><p>Clone a div or an other element.</p><p>$(document).ready(function() {<br>   var cloned = $(‘#id’).clone();<br>// how to use</p><div id="id"></div><p>});</p><ol><li>使元素居屏幕中间位置</li></ol><p>Center an element in the center of your screen.</p><p>$(document).ready(function() {<br>  jQuery.fn.center = function () {<br>      this.css(“position”,”absolute”);<br>      this.css(“top”, ( $(window).height() - this.height() ) / 2+$(window).scrollTop() + “px”);<br>      this.css(“left”, ( $(window).width() - this.width() ) / 2+$(window).scrollLeft() + “px”);<br>      return this;<br>  }<br>  $(“#id”).center();<br>});</p><ol><li>写自己的选择器</li></ol><p>Write your own selectors.</p><p>$(document).ready(function() {<br>   $.extend($.expr[‘:’], {<br>       moreThen1000px: function(a) {<br>           return $(a).width() &gt; 1000;<br>      }<br>   });<br>  $(‘.box:moreThen1000px’).click(function() {<br>      // creating a simple js alert box<br>      alert(‘The element that you have clicked is over 1000 pixels wide’);<br>  });<br>});</p><ol><li>统计元素个数</li></ol><p>Count an element.</p><p>$(document).ready(function() {<br>   $(“p”).size();<br>});</p><ol><li>使用自己的 Bullets</li></ol><p>Want to use your own bullets instead of using the standard or images bullets?</p><p>$(document).ready(function() {<br>   $(“ul”).addClass(“Replaced”);<br>   $(“ul &gt; li”).prepend(“? “);<br> // how to use<br> ul.Replaced { list-style : none; }<br>});</p><ol><li>引用Google主机上的Jquery类库</li></ol><p>Let Google host the jQuery script for you. This can be done in 2 ways.</p><p>//Example 1</p><script src="http://www.google.com/jsapi"></script><br><script type="text/javascript"><br>google.load(“jquery”, “1.2.6”);<br>google.setOnLoadCallback(function() {<br>    // do something<br>});<br></script><script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.2.6/jquery.min.js"></script><p> // Example 2:(the best and fastest way)</p><script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.2.6/jquery.min.js"></script><ol><li>禁用Jquery（动画）效果</li></ol><p>Disable all jQuery effects</p><p>$(document).ready(function() {<br>    jQuery.fx.off = true;<br>});</p><ol><li>与其他Javascript类库冲突解决方案</li></ol><p>To avoid conflict other libraries on your website, you can use this jQuery Method, and assign a different variable name instead of the dollar sign.</p><p>$(document).ready(function() {<br>   var $jq = jQuery.noConflict();<br>   $jq(‘#id’).show();<br>});</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-禁止右键点击&quot;&gt;&lt;a href=&quot;#1-禁止右键点击&quot; class=&quot;headerlink&quot; title=&quot;1.禁止右键点击&quot;&gt;&lt;/a&gt;1.禁止右键点击&lt;/h2&gt;&lt;p&gt;$(document).ready(function(){&lt;br&gt;    $(documen
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>正则表达式的类</title>
    <link href="http://suijiafeng.com/2017/05/22/JS%E7%9A%84%E4%BB%A3%E7%A0%81%E7%9A%84%E5%BC%95%E7%94%A8%E8%A7%84%E8%8C%83/"/>
    <id>http://suijiafeng.com/2017/05/22/JS的代码的引用规范/</id>
    <published>2017-05-21T17:18:00.000Z</published>
    <updated>2018-12-12T04:36:13.346Z</updated>
    
    <content type="html"><![CDATA[<p>开篇,还是得说说 ^ 和 $ 他们是分别用来匹配字符串的开始和结束，以下分别举例说明：</p><p>　　“^The”: 开头一定要有”The”字符串;</p><p>　　“of despair$”: 结尾一定要有”of despair” 的字符串;</p><p>　　那么,</p><p>　　“^abc$”: 就是要求以abc开头和以abc结尾的字符串，实际上是只有abc匹配。</p><p>　　“notice”: 匹配包含notice的字符串。</p><p>　　你可以看见如果你没有用我们提到的两个字符(最后一个例子)，就是说 模式(正则表达式) 可以出现在被检验字符串的任何地方，你没有把他锁定到两边。</p><p>　　接着,说说 ‘*’, ‘+’,和 ‘?’,</p><p>　　他们用来表示一个字符可以出现的次数或者顺序. 他们分别表示：</p><p>　　“zero or more”相当于{0,},<br>　　“one or more”相当于{1,},<br>　　“zero or one.”相当于{0,1}, 这里是一些例子:<br>　　“ab<em>“: 和ab{0,}同义,匹配以a开头,后面可以接0个或者N个b组成的字符串(“a”, “ab”, “abbb”, 等);<br>　　“ab+”: 和ab{1,}同义,同上条一样，但最少要有一个b存在 (“ab”, “abbb”, 等.);<br>　　“ab?”:和ab{0,1}同义,可以没有或者只有一个b;<br>　　“a?b+$”: 匹配以一个或者0个a再加上一个以上的b结尾的字符串.<br>　　要点, ‘</em>‘, ‘+’,和 ‘?’只管它前面那个字符.</p><p>　　你也可以在大括号里面限制字符出现的个数，比如</p><p>　　“ab{2}”: 要求a后面一定要跟两个b(一个也不能少)(“abb”);<br>　　“ab{2,}”: 要求a后面一定要有两个或者两个以上b(如”abb”, “abbbb”, 等.);<br>　　“ab{3,5}”: 要求a后面可以有2-5个b(“abbb”, “abbbb”, or “abbbbb”).<br>　　现在我们把一定几个字符放到小括号里，比如：</p><p>　　“a(bc)*”: 匹配 a 后面跟0个或者一个”bc”;<br>　　“a(bc){1,5}”: 一个到5个 “bc.”<br>　　还有一个字符 ‘│’, 相当于OR 操作:</p><p>　　“hi│hello”: 匹配含有”hi” 或者 “hello” 的 字符串;</p><p>　　“(b│cd)ef”: 匹配含有 “bef” 或者 “cdef”的字符串;</p><p>　　“(a│b)*c”: 匹配含有这样多个(包括0个)a或b，后面跟一个c的字符串;</p><p>　　一个点(‘.’)可以代表所有的单一字符,不包括”\n”</p><p>　　如果,要匹配包括”\n”在内的所有单个字符,怎么办?</p><p>　　对了,用’[\n.]’这种模式.</p><p>　　“a.[0-9]”: 一个a加一个字符再加一个0到9的数字</p><p>　　“^.{3}$”: 三个任意字符结尾 .</p><p>　　中括号括住的内容只匹配一个单一的字符</p><p>　　“[ab]”: 匹配单个的 a 或者 b ( 和 “a│b” 一样);</p><p>　　“[a-d]”: 匹配’a’ 到’d’的单个字符 (和”a│b│c│d” 还有 “[abcd]”效果一样); 一般我们都用[a-zA-Z]来指定字符为一个大小写英文</p><p>　　“^[a-zA-Z]”: 匹配以大小写字母开头的字符串</p><p>　　“[0-9]%”: 匹配含有 形如 x% 的字符串</p><p>　　“,[a-zA-Z0-9]$”: 匹配以逗号再加一个数字或字母结尾的字符串</p><p>　　你也可以把你不想要得字符列在中括号里，你只需要在总括号里面使用’^’ 作为开头 “%[^a-zA-Z]%” 匹配含有两个百分号里面有一个非字母的字符串.</p><p>　　要点:^用在中括号开头的时候,就表示排除括号里的字符。为了PHP能够解释，你必须在这些字符面前后加’’,并且将一些字符转义.</p><p>　　不要忘记在中括号里面的字符是这条规路的例外?在中括号里面, 所有的特殊字符，包括(‘’), 都将失去他们的特殊性质 “[*+?{}.]”匹配含有这些字符的字符串.</p><p>　　还有,正如regx的手册告诉我们: “如果列表里含有 ‘]’, 最好把它作为列表里的第一个字符(可能跟在’^’后面). 如果含有’-‘, 最好把它放在最前面或者最后面, or 或者一个范围的第二个结束点[a-d-0-9]中间的‘-’将有效.</p><p>　　看了上面的例子,你对{n,m}应该理解了吧.要注意的是,n和m都不能为负整数,而且n总是小于m. 这样,才能 最少匹配n次且最多匹配m次. 如”p{1,5}”将匹配 “pvpppppp”中的前五个p.</p><p>　　下面说说以\开头的</p><p>　　\b 书上说他是用来匹配一个单词边界,就是…比如’ve\b’,可以匹配love里的ve而不匹配very里有ve</p><p>　　\B 正好和上面的\b相反.例子我就不举了</p><p>　　…..突然想起来….可以到<a href="http://www.phpv.net/article.php/251" target="_blank" rel="noopener">http://www.phpv.net/article.php/251</a> 看看其它用\ 开头的语法</p><p>　　好,我们来做个应用:</p><p>　　如何构建一个模式来匹配 货币数量 的输入</p><p>　　构建一个匹配模式去检查输入的信息是否为一个表示money的数字。我们认为一个表示money的数量有四种方式： “10000.00” 和 “10,000.00”,或者没有小数部分, “10000” and “10,000”. 现在让我们开始构建这个匹配模式:</p><p>^[1-9][0-9]*$ </p><p>这是所变量必须以非0的数字开头.但这也意味着 单一的 “0” 也不能通过测试. 以下是解决的方法:<br>^(0│[1-9][0-9]*)$ </p><p>　　“只有0和不以0开头的数字与之匹配”，我们也可以允许一个负号在数字之前:</p><p>^(0│-?[1-9][0-9]*)$ </p><p>　　这就是: “0 或者 一个以0开头 且可能 有一个负号在前面的数字.” 好了,现在让我们别那么严谨，允许以0开头.现在让我们放弃 负号 , 因为我们在表示钱币的时候并不需要用到. 我们现在指定 模式 用来匹配小数部分:</p><p>^[0-9]+(.[0-9]+)?$ </p><p>　　这暗示匹配的字符串必须最少以一个阿拉伯数字开头. 但是注意，在上面模式中 “10.” 是不匹配的, 只有 “10” 和 “10.2” 才可以. (你知道为什么吗)</p><p>^[0-9]+(.[0-9]{2})?$ </p><p>　　我们上面指定小数点后面必须有两位小数.如果你认为这样太苛刻,你可以改成:</p><p>^[0-9]+(.[0-9]{1,2})?$ </p><p>　　这将允许小数点后面有一到两个字符. 现在我们加上用来增加可读性的逗号(每隔三位), 我们可以这样表示:</p><p>^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ </p><p>　　不要忘记 ‘+’ 可以被 ‘*’ 替代 如果你想允许空白字符串被输入话 (为什么?). 也不要忘记反斜杆 ’\’ 在php字符串中可能会出现错误 (很普遍的错误).</p><p>　　现在，我们已经可以确认字符串了, 我们现在把所有逗号都去掉 str_replace(“,”, “”, $money) 然后在把类型看成 double然后我们就可以通过他做数学计算了.</p><p>　　再来一个:</p><p>　　构造检查email的正则表达式</p><p>　　在一个完整的email地址中有三个部分:</p><p>　　1. 用户名 (在 ‘@’ 左边的一切),</p><p>　　2.’@’,</p><p>　　3. 服务器名(就是剩下那部分).</p><p>　　用户名可以含有大小写字母阿拉伯数字,句号 (‘.’), 减号(‘-‘), and 下划线 (‘_’). 服务器名字也是符合这个规则,当然下划线除外.</p><p>　　现在, 用户名的开始和结束都不能是句点. 服务器也是这样. 还有你不能有两个连续的句点他们之间至少存在一个字符，好现在我们来看一下怎么为用户名写一个匹配模式:</p><p>^[_a-zA-Z0-9-]+$ </p><p>　　现在还不能允许句号的存在. 我们把它加上:</p><p>^[_a-zA-Z0-9-]+(.[_a-zA-Z0-9-]+)*$ </p><p>　　上面的意思就是说: “以至少一个规范字符(除了.)开头,后面跟着0个或者多个以点开始的字符串.”</p><p>　　简单化一点, 我们可以用 eregi()取代 ereg().eregi()对大小写不敏感, 我们就不需要指定两个范围 “a-z” 和 “A-Z” ? 只需要指定一个就可以了:</p><p>^[_a-z0-9-]+(.[_a-z0-9-]+)*$ </p><p>　　后面的服务器名字也是一样,但要去掉下划线:</p><p>^[a-z0-9-]+(.[a-z0-9-]+)*$ </p><p>　　好. 现在只需要用”@”把两部分连接:</p><p>^[_a-z0-9-]+(.[_a-z0-9-]+)<em>@[a-z0-9-]+(.[a-z0-9-]+)</em>$ </p><p>　　这就是完整的email认证匹配模式了,只需要调用</p><p>eregi(‘^[_a-z0-9-]+(.[_a-z0-9-]+)<em>@[a-z0-9-]+(.[a-z0-9-]+)</em>$ ’,$eamil) </p><p>　　就可以得到是否为email了.</p><p>　　正则表达式的其他用法</p><p>　　提取字符串</p><p>　　ereg() and eregi() 有一个特性是允许用户通过正则表达式去提取字符串的一部分(具体用法你可以阅读手册). 比如说,我们想从 path/URL 提取文件名 ? 下面的代码就是你需要:</p><p>  ereg(“([^\/]*)$”, $pathOrUrl, $regs);<br>  echo $regs[1]; </p><p>　　高级的代换</p><p>　　ereg_replace() 和 eregi_replace()也是非常有用的: 假如我们想把所有的间隔负号都替换成逗号:</p><p>ereg_replace(“[ \n\r\t]+”, “,”, trim($str)); </p><p>　　最后,我把另一串检查EMAIL的正则表达式让看文章的你来分析一下.</p><p>“^[-!#$%&amp;\’<em>+\./0-9=?A-Z^_`a-z{|}~]+’.’@’.’[-!#$%&amp;\’</em>+\/0-9=?A-Z^<em>`a-z{|}~]+.‘.’[-!#$%&amp;\’*+\./0-9=?A-Z^</em>`a-z{|}~]+$” </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;开篇,还是得说说 ^ 和 $ 他们是分别用来匹配字符串的开始和结束，以下分别举例说明：&lt;/p&gt;
&lt;p&gt;　　“^The”: 开头一定要有”The”字符串;&lt;/p&gt;
&lt;p&gt;　　“of despair$”: 结尾一定要有”of despair” 的字符串;&lt;/p&gt;
&lt;p&gt;　　那么
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>js的数据类型</title>
    <link href="http://suijiafeng.com/2017/05/10/js%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://suijiafeng.com/2017/05/10/js的数据类型/</id>
    <published>2017-05-09T17:11:00.000Z</published>
    <updated>2018-12-12T04:36:13.346Z</updated>
    
    <content type="html"><![CDATA[<h3 id="特点：弱类型特性。"><a href="#特点：弱类型特性。" class="headerlink" title="特点：弱类型特性。"></a>特点：弱类型特性。</h3><p>共有5种原始类型：number String  boolean null undefined  </p><p>1中Object 类型</p><h3 id="隐士转换："><a href="#隐士转换：" class="headerlink" title="隐士转换："></a>隐士转换：</h3><h4 id="巧用-的转换逻辑"><a href="#巧用-的转换逻辑" class="headerlink" title="+ - 巧用 + - 的转换逻辑"></a>+ - 巧用 + - 的转换逻辑</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&quot;123&quot;==123</span><br><span class="line"></span><br><span class="line">0 ==false</span><br><span class="line"></span><br><span class="line">null ==undefined</span><br><span class="line"></span><br><span class="line">[1,2]==[1,2]  因为他们两个是不同的对象</span><br><span class="line"></span><br><span class="line">NaN 不等于NaN</span><br></pre></td></tr></table></figure><p>​    类型相同，同 ===</p><p>​    类型不同，尝试类型转换</p><h3 id="包装对象"><a href="#包装对象" class="headerlink" title="包装对象"></a>包装对象</h3><p>object 对象 ：Function   Data  Array</p><p>当我们尝试把基本类型当成是对象来使用的时候 </p><p>​    js内部会帮我们包装成对象，当这个动作完成后，这个对象也就被销毁了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a = &quot;string&quot;;</span><br><span class="line">undefined</span><br><span class="line">a.length</span><br><span class="line">6</span><br><span class="line">a.t=3;</span><br><span class="line">3</span><br><span class="line">a.t;//设置完 a.t 属性之后，临时被包装的对象也就被销毁了。</span><br><span class="line">undefined</span><br></pre></td></tr></table></figure><h3 id="类型检测"><a href="#类型检测" class="headerlink" title="类型检测"></a>类型检测</h3><p><img src="https://note.youdao.com/yws/public/resource/6032a8a4d7150d5aafd6a0153265cf44/xmlnote/FB4BBE59F1EA4502A382B894597A67E7/3984" alt="image"></p><h3 id="obj-instanceof-Object"><a href="#obj-instanceof-Object" class="headerlink" title="obj instanceof Object"></a>obj instanceof Object</h3><p>运行原理：判断左边obj 对象的原型链上是否有右边这个对象 Object 的protype 属性</p><p><img src="https://note.youdao.com/yws/public/resource/6032a8a4d7150d5aafd6a0153265cf44/xmlnote/41AC3A6387BF4C58B4C0A66425E10FA7/4009" alt="image"></p><p>类型检测：</p><p><img src="https://note.youdao.com/yws/public/resource/6032a8a4d7150d5aafd6a0153265cf44/xmlnote/C752C7F7F0CF4193A0F573FBB45C118C/3983" alt="image"></p><p><img src="https://note.youdao.com/yws/public/resource/6032a8a4d7150d5aafd6a0153265cf44/xmlnote/436627D93CD84BA5B105A95C5EC464D4/3976" alt="image"></p><h2 id="表达式："><a href="#表达式：" class="headerlink" title="表达式："></a>表达式：</h2><p> <img src="https://note.youdao.com/yws/public/resource/6032a8a4d7150d5aafd6a0153265cf44/xmlnote/6E53834BD4B3462CA38EBF41176871A2/4001" alt="image"></p><p> <img src="https://note.youdao.com/yws/public/resource/6032a8a4d7150d5aafd6a0153265cf44/xmlnote/31D3784199B141E0926812709C719CB7/4008" alt="image"></p><p> <img src="https://note.youdao.com/yws/public/resource/6032a8a4d7150d5aafd6a0153265cf44/xmlnote/76EB0C738F2244E297CB8BFE9EC7DD41/4007" alt="image"></p><h2 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h2><p><img src="https://note.youdao.com/yws/public/resource/6032a8a4d7150d5aafd6a0153265cf44/xmlnote/7D18A95A288643A99D24A92679056300/4004" alt="image"></p><p><img src="https://note.youdao.com/yws/public/resource/6032a8a4d7150d5aafd6a0153265cf44/xmlnote/54A02DEA8BBD4D9C96E7BE5CDB23B1FF/4000" alt="image"></p><p> <img src="https://note.youdao.com/yws/public/resource/6032a8a4d7150d5aafd6a0153265cf44/xmlnote/F9D6DD9AC2BE4761A65788A1058402B8/4011" alt="image"></p><p> <img src="https://note.youdao.com/yws/public/resource/6032a8a4d7150d5aafd6a0153265cf44/xmlnote/4818F9BEA00D434C95AD9135464A021C/4012" alt="image"></p><p> <img src="https://note.youdao.com/yws/public/resource/6032a8a4d7150d5aafd6a0153265cf44/xmlnote/31D3784199B141E0926812709C719CB7/4008" alt="image"></p><h2 id="运算符："><a href="#运算符：" class="headerlink" title="运算符："></a>运算符：</h2><p> <img src="https://note.youdao.com/yws/public/resource/6032a8a4d7150d5aafd6a0153265cf44/xmlnote/321866938F70466E8D2F8E7D63DBA93E/3991" alt="image"></p><p>1.三元运算符</p><p>2.逗号运算符   var val=(1,2,3);//3</p><p>3.delete<br><img src="https://note.youdao.com/yws/public/resource/6032a8a4d7150d5aafd6a0153265cf44/xmlnote/333B88DF0E8748AFB86585161D36C27C/4005" alt="image"></p><p>4 in </p><p><img src="https://note.youdao.com/yws/public/resource/6032a8a4d7150d5aafd6a0153265cf44/xmlnote/7B8CC053B0C74C219262FC4561286350/4014" alt="image"></p><p>5 new </p><p> <img src="https://note.youdao.com/yws/public/resource/6032a8a4d7150d5aafd6a0153265cf44/xmlnote/079255AA1ABE43ED9C6D54664CE2ECB7/3989" alt="image"></p><p>6 this </p><p>7 void</p><p><img src="https://note.youdao.com/yws/public/resource/6032a8a4d7150d5aafd6a0153265cf44/xmlnote/305B1F06510E417D97C139005F603CBE/4006" alt="image"></p><h3 id="运算优先级"><a href="#运算优先级" class="headerlink" title="运算优先级"></a>运算优先级</h3><p><img src="https://note.youdao.com/yws/public/resource/6032a8a4d7150d5aafd6a0153265cf44/xmlnote/68CCC9C97DC147B7AFF8B1301755A057/3985" alt="image"></p><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p><img src="https://note.youdao.com/yws/public/resource/6032a8a4d7150d5aafd6a0153265cf44/xmlnote/CC3CE85350AC49BAA884FC513E06C8BD/4010" alt="image"></p><p><img src="https://note.youdao.com/yws/public/resource/6032a8a4d7150d5aafd6a0153265cf44/xmlnote/D130CDE1FBA04263BC98D543EA9474E2/3999" alt="image"></p><h3 id="语句种类"><a href="#语句种类" class="headerlink" title="语句种类"></a>语句种类<img src="img\语句种类.png" alt="语句种类"></h3><p><img src="https://note.youdao.com/yws/public/resource/6032a8a4d7150d5aafd6a0153265cf44/xmlnote/594D6B06E1ED499B8A8B35E2E2E59B3E/3978" alt="image"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">浏览器把 &#123;a:1,b:2&#125;//当成了块，而不是对象字面量。</span><br></pre></td></tr></table></figure><pre><code>## var 声明语句</code></pre><p>var a;</p><p>var a,b,c;</p><h2 id="try-catch"><a href="#try-catch" class="headerlink" title="try catch"></a>try catch</h2><p> <img src="https://note.youdao.com/yws/public/resource/6032a8a4d7150d5aafd6a0153265cf44/xmlnote/9A2D2E9131384D599C8D0A77E4575B77/3997" alt="image"></p><p>1 首先执行try 中的代码，如果出现异常就由catch 捕获，但是不过有没有异常，最后都会执行finally 中的代码</p><p>2 注意点：try  后面一定要带一个catch 或finally ,或者两者皆带。</p><h2 id="function"><a href="#function" class="headerlink" title="function"></a>function</h2><p><img src="https://note.youdao.com/yws/public/resource/6032a8a4d7150d5aafd6a0153265cf44/xmlnote/CA85762E97AD42F1944B8440E8B6708A/3998" alt="image"></p><h2 id="for-in"><a href="#for-in" class="headerlink" title="for in"></a>for in</h2><p> <img src="https://note.youdao.com/yws/public/resource/6032a8a4d7150d5aafd6a0153265cf44/xmlnote/7F60F0525096436FA4C14C6A97F7BEF6/3992" alt="image"></p><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p><img src="https://note.youdao.com/yws/public/resource/6032a8a4d7150d5aafd6a0153265cf44/xmlnote/93DEF6B7D89947AD84EBD1FB4EBD497C/3977" alt="image"></p><p> ##循环</p><p> <img src="https://note.youdao.com/yws/public/resource/6032a8a4d7150d5aafd6a0153265cf44/xmlnote/0A771B6BB11B4433B978B6EFB1CB2F39/3996" alt="image"></p><h2 id="with"><a href="#with" class="headerlink" title="with"></a>with</h2><p>可以修改当前的作用域</p><p><img src="https://note.youdao.com/yws/public/resource/6032a8a4d7150d5aafd6a0153265cf44/xmlnote/DE66C7F7A6F84651AA1FE316AFBB8B3A/3986" alt="image"></p><h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><p> <img src="https://note.youdao.com/yws/public/resource/6032a8a4d7150d5aafd6a0153265cf44/xmlnote/402FB559EF664368B75A203250D89EC0/3980" alt="image"></p><h3 id="严格模式下的特点："><a href="#严格模式下的特点：" class="headerlink" title="严格模式下的特点："></a>严格模式下的特点：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SyntaxError :语法错误</span><br><span class="line">ReferenceError:引用错误</span><br></pre></td></tr></table></figure><p> <img src="https://note.youdao.com/yws/public/resource/6032a8a4d7150d5aafd6a0153265cf44/xmlnote/2C7DAA3A206D45CC8CA318D94A9F8D6F/3981" alt="image"><br> <img src="https://note.youdao.com/yws/public/resource/6032a8a4d7150d5aafd6a0153265cf44/xmlnote/9DAE9D1097764EA59F637296832083E5/3982" alt="image"><br> <img src="https://note.youdao.com/yws/public/resource/6032a8a4d7150d5aafd6a0153265cf44/xmlnote/91F5F9BC36444D37BC30F3FDA1EF7C0D/3993" alt="image"></p><p> <img src="https://note.youdao.com/yws/public/resource/6032a8a4d7150d5aafd6a0153265cf44/xmlnote/4DAAF4083AE548599AEED43A75996AB8/3987" alt="image"><br> <img src="https://note.youdao.com/yws/public/resource/6032a8a4d7150d5aafd6a0153265cf44/xmlnote/43A17FEC60E94241B5B04230098936F3/3972" alt="image"><br> <img src="https://note.youdao.com/yws/public/resource/6032a8a4d7150d5aafd6a0153265cf44/xmlnote/01EB9BB7B8604F00B12263C7092252C1/3990" alt="image"></p><p> <img src="https://note.youdao.com/yws/public/resource/6032a8a4d7150d5aafd6a0153265cf44/xmlnote/CD2D2F645F444DA98F9B8DDF35629B79/3979" alt="image"><br> <img src="https://note.youdao.com/yws/public/resource/6032a8a4d7150d5aafd6a0153265cf44/xmlnote/ADA09EEEDC534D8BBD15294F47CC2451/3994" alt="image"><br> <img src="https://note.youdao.com/yws/public/resource/6032a8a4d7150d5aafd6a0153265cf44/xmlnote/F16D3979C84F486898129F1F1C732215/3988" alt="image"></p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p><img src="https://note.youdao.com/yws/public/resource/6032a8a4d7150d5aafd6a0153265cf44/xmlnote/1EDEBD03D3444A939F562266508E921F/3995" alt="image"></p><h2 id="对象结构"><a href="#对象结构" class="headerlink" title="对象结构"></a>对象结构</h2><p><img src="https://note.youdao.com/yws/public/resource/6032a8a4d7150d5aafd6a0153265cf44/xmlnote/45D357D6CE7B42F9A03147E9F6490BFB/3973" alt="image"></p><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p><img src="https://note.youdao.com/yws/public/resource/6032a8a4d7150d5aafd6a0153265cf44/xmlnote/12011010BC4D48A5B5E79B0FFB5C3D12/4003" alt="image"></p><p><img src="https://note.youdao.com/yws/public/resource/6032a8a4d7150d5aafd6a0153265cf44/xmlnote/5B2424434354487EA567EE30A6755468/3974" alt="image"></p><p>创建对象的方式2-new 原型链–深入理解</p><p><img src="https://note.youdao.com/yws/public/resource/6032a8a4d7150d5aafd6a0153265cf44/xmlnote/5B2424434354487EA567EE30A6755468/3974" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;特点：弱类型特性。&quot;&gt;&lt;a href=&quot;#特点：弱类型特性。&quot; class=&quot;headerlink&quot; title=&quot;特点：弱类型特性。&quot;&gt;&lt;/a&gt;特点：弱类型特性。&lt;/h3&gt;&lt;p&gt;共有5种原始类型：number String  boolean null undef
      
    
    </summary>
    
    
  </entry>
  
</feed>
