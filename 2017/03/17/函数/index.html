<!DOCTYPE html>
<html lang=zh-CN>
  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="description" content="互联网前端学习">
  <meta name="keywords" content="">
  
    <link rel="icon" href="/favicon.ico">
  
    
  <title>函数 | 眭加凤的博客</title>
  <link rel="stylesheet" href="/style.css">
  <link rel="stylesheet" href="/lib/jquery.fancybox.min.css">
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
</head>

<body>
    <div class="website_bg"></div>
  <header>
  <div class="header-container">
    <a class='logo' href="/">
      <span>眭加凤的博客</span>
    </a>
    <ul class="right-header">
      
        <li class="nav-item">
          
            <a href="/" class="item-link">首页</a>
          
        </li>
      
        <li class="nav-item">
          
            <a href="/about" class="item-link">关于</a>
          
        </li>
      
        <li class="nav-item">
          
            <a href="/archives" class="item-link">归档</a>
          
        </li>
      
        <li class="nav-item">
          
            <a href="/tags" class="item-link">标签</a>
          
        </li>
      
    </ul>
  </div>
</header>

  <main id='post'>
  <div class="content">
    <article>
        <section class="content markdown-body">
          <h1>函数</h1>
          <div class='post-meta'>
            <i class="fa fa-calendar" aria-hidden="true"></i> <time>2017年03月17日</time>
            
            
          </div>
          <h2 id="为什么要使用函数，使用函数的目的"><a href="#为什么要使用函数，使用函数的目的" class="headerlink" title="为什么要使用函数，使用函数的目的"></a>为什么要使用函数，使用函数的目的</h2><p>1 程序有的时候一段一样的代码会在不同的地方多次执行，如果我们使用复制粘贴的方法，当然也可行，但是会造成<strong>代码冗余</strong>的情况发生，<strong>可维护性也差</strong>，你想啊，我一个地方改了，其他地方也要改，不能起到牵一发而动全身的效果。代码的健壮性也不好。</p>
<h2 id="什么时候使用函数"><a href="#什么时候使用函数" class="headerlink" title="什么时候使用函数"></a>什么时候使用函数</h2><pre><code>1.有些代码在不同地方，需要执行，我们可以把这些代码封装成一个函数。
2.代码复用：如果一段代码是实现一个功能，我们就可以把一段代码封装成一个函数，哪里需要这个功能，就调用这个函数。

函数是一块JavaScript中的一段代码，被定义一次，但是可执行和调用多次。
JS中的函数也是对象，所以JS函数可以像其它对象那样操作和传递，所以我们也常把函数叫做函数对象。
</code></pre><h2 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h2><pre><code>函数名最好为一个有意义的名词。
js中函数不能重名，如果重名的会话，后面的函数会把前面的函数给覆盖掉。
</code></pre><h2 id="函数体"><a href="#函数体" class="headerlink" title="函数体"></a>函数体</h2><pre><code>只要是符合js语法规范的代码，就可以称之为函数体。
</code></pre><h2 id="函数名和变量名重名的情况"><a href="#函数名和变量名重名的情况" class="headerlink" title="函数名和变量名重名的情况"></a>函数名和变量名重名的情况</h2><ul>
<li>如果变量有值，那么输出的就是标量的值</li>
<li>如果变量没有值，那么输出的就是函数的代码，注意是函数的代码，而不是输出的结果。</li>
<li>建议：变量量名最好为一个有意义的动词，函数名最好为一个有意义的名词。</li>
</ul>
<h2 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h2><pre><code>- 形参
    定义函数的时候，在小括号里面写的，叫做函数的形式参数(形参);
    形参本质上就是函数声明中的一个变量
- 实参
    调用函数的时候，小括号里面的值，调用的时候，会把实参传递给形参。
</code></pre><h2 id="函数参数的类型"><a href="#函数参数的类型" class="headerlink" title="函数参数的类型"></a>函数参数的类型</h2><pre><code>- 值类型 它里面存放的是一个值
- 引用类型 存放的是一个地址
</code></pre><h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h2><ul>
<li>是一个伪数组，里面存放的是实际是函数的参数。里面的元素和形参一一对应。</li>
<li>因为是个伪数组，所以没有数组里面的方法，可以使用下标索引</li>
<li>如果函数里面没有形参，函数调用的时候传递过来了实参，那么这个传递过来的值就存在arguments里面</li>
</ul>
<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><ul>
<li>arguments 可以模拟重载。</li>
<li>好处：a 方便程序员记忆，b 可以根据参数个数的不同，执行不同的代码。</li>
</ul>
<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><pre><code>- return语句，函数在执行完return语句后，就会停止执行并立即退出程序。
- 只能返回一个东西，如果想要返回多个东西的话，可以定一个个对象或者数组，以他们为载体返回。
- 函数有retrun 语句并且有表达式；返回的是表达式的值。
- 函数有return语句但是没有表达式；返回的是undefine。
- 函数没有return ；返回的是undefined。
</code></pre><h2 id="函数–作用域"><a href="#函数–作用域" class="headerlink" title="函数–作用域"></a>函数–作用域</h2><ul>
<li>在js当中只有函数能够划分作用域。函数在js 中也是一等公民。<br><br> a  局部作用域：任何函数的内部我们称之为局部作用域。<br> b 全局作用域：script 标签内部我们称之为全局作用域。</li>
<li>作用域的访问规则：<br> <strong>就近原则</strong>：<pre><code>1 使用一个变量。
     先去当前作用域去找，找到就使用，如果找不到就往父级找，父级没有？那再往上找，如果全局中也没有，那么报错。
2  修改一个变量的值
     先去当前作用域找，如果有这个变量，那么把当前作用域中的变量的值给修改了；如果没有那么就往上找，如果都没有，那么它自己也就变成了一个全局变量。
</code></pre></li>
</ul>
<h2 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h2><ul>
<li><p>在每个作用域里面的代码执行之前，都会把当前这个作用域里面<strong>函数声明、变量</strong>提升到<strong>当前这个作用域的最顶端</strong>，赋值语句保留在原地。</p>
<p> 注意关键字：的那你去哪作用域  函数声明 变量</p>
</li>
</ul>
<h2 id="函数的声明方式："><a href="#函数的声明方式：" class="headerlink" title="函数的声明方式："></a>函数的声明方式：</h2><ul>
<li>函数声明语句的方式声明函数</li>
<li>函数表达式的方式声明函数<br>两者的区别:<br>a 表达式在预解析阶段函数会被前置，提升但当前作用域；意味着不能立即调用。<br><br>b 表达式声明的函数，函数不会前置，意味着可以立即调用。</li>
</ul>
<h2 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h2><ul>
<li>函数名代表的是整个函数，函数名加个小括号，表示的是函数的调用，</li>
</ul>
<h2 id="函数的检测"><a href="#函数的检测" class="headerlink" title="函数的检测"></a>函数的检测</h2><ul>
<li>typeof 函数名</li>
<li>函数名 instanceof Function</li>
<li>Object.prototype.toString.call(函数名)</li>
</ul>
<h2 id="函数的创建方法"><a href="#函数的创建方法" class="headerlink" title="函数的创建方法"></a>函数的创建方法</h2><h2 id="函数调用的方式"><a href="#函数调用的方式" class="headerlink" title="函数调用的方式"></a>函数调用的方式</h2><ol>
<li>直接调用</li>
<li>作为方法调用</li>
<li>函数上下文调用</li>
<li>构造器</li>
</ol>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>在JavaScript中不同的函数调用方式this 的指向也是不同的</p>
<ul>
<li>全局作用域下的 this指向全局对象，在浏览器中，这个全局对象指向的是windows</li>
<li>一般函数中的this,指向的是window</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function f1()&#123;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line">f1()===window;//true</span><br></pre></td></tr></table></figure>
<ul>
<li>作为对象方法的函数中的this<br>谁调用，this 指向谁。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">    x:1,</span><br><span class="line">    y:function()&#123;</span><br><span class="line">        return this.x;</span><br><span class="line">        //分析：对于属性y 我们定义了一个函数，我们也把这种形式叫做对象的方法.</span><br><span class="line">        //这里的this 指向的是对象 o</span><br><span class="line">        // 因此return this.x 就相当于 return o.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">o.y(); //1</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>再举个例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;prop:37&#125;;</span><br><span class="line">function independent()&#123;</span><br><span class="line">    return this.prop;</span><br><span class="line">&#125;</span><br><span class="line">o.f = independent;</span><br><span class="line">console.log(o.f());//37</span><br><span class="line">//分析：这里的this为什么不是window呢？这是因为，在执行过程中，里面的this并不是看函数创建时候的this，而是看函数调用时候的,谁调用了我，我就指向谁。</span><br></pre></td></tr></table></figure></p>
<ul>
<li>对象原型链中的this</li>
</ul>
<p>构造函数中的this </p>
<p>call/apply方法与this</p>
<p>bind 方法与this</p>
<h2 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h2><p>字面量表示如何表达这个值，一般除去表达式，给变量赋值时，等号右边都可以认为是字面量。</p>
<p>字面量分为字符串字面量(string literal )、数组字面量(array literal)和</p>
<p>对象字面量(object literal)，另外还有函数字面量(function literal)。</p>
<p>示例：<br>var test=”hello world!”;<br>“hello world!”就是字符串字面量，test是变量名。</p>
<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function learn(something) &#123;</span><br><span class="line">    console.log(something);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function we(callback, something) &#123;</span><br><span class="line">    something += &apos;is cool&apos;;</span><br><span class="line">    callback(something);</span><br><span class="line">&#125;</span><br><span class="line">we(learn, &apos;Nodejs&apos;);//输出  Nodejs id cool</span><br><span class="line">//分析  我们传入进去的是一个具名函数</span><br><span class="line"></span><br><span class="line">we(function(something)&#123;</span><br><span class="line">    console.log(something)</span><br><span class="line">&#125;,&apos;Nodejs&apos;);//输出  Nodejs id cool</span><br><span class="line">//分析  我们传入进去的是一个匿名函数</span><br></pre></td></tr></table></figure>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p><strong>构造函数介绍</strong>：</p>
<p>构造函数也是一个函数，一般用来创建对象</p>
<p><strong>构造函数的特征:</strong></p>
<ol>
<li>首字母大写 （不大写也没事，但是这是大家规范）</li>
<li>构造函数一般和new 关键字一起使用</li>
<li>不需要手动写返回值</li>
</ol>
<p><strong>构造函数执行的过程</strong></p>
<p>1.1使用new关键字创建对象 </p>
<p>1.2调用构造函数，将构造函数内的this 指向创建出来的对象</p>
<p>1.3 在构造函数内部，通过this给对象新增属性和方法（做初始化工作）</p>
<p>1.4 自动返回刚才new 创建出来的对象</p>
<p>注意：如果手动帮构造函数设置了返回语句呢？</p>
<p>a : 如果返回的是一个简单的数据类型  ，那么没有影响,返回的还是new创建出来的对象</p>
<p>b : 如果返回的是一个复杂的数据类型，则会把创建出来的那个对象给覆盖掉 。返回的是手工设置的数据类型</p>
<p><strong>new关键字</strong></p>
<p>ps: 任何函数，只要通过new关键操作符来调用，那它就可以作为构造函数；而任何函数，如果不通过构造函数来调用，那它跟普通函数也没什么两样。</p>
<p>如果像使用普通的函数一样去调用构造函数</p>
<p> a 函数中的this会指向window对象，通过this添加的所有的属性和方法，都会添加给window对象</p>
<p>  b  函数中如果没有return语句，则返回undefined</p>
<p><strong>例子：自定义一个构造函数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function my(name,age,sex)&#123;	</span><br><span class="line"></span><br><span class="line">	this.name = name;</span><br><span class="line"></span><br><span class="line">	this.age = age;</span><br><span class="line"></span><br><span class="line">	this.sex = sex;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用new关键字创建对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var m1 = new My(&quot;张&quot;, 15,&quot;男&quot;);</span><br><span class="line"></span><br><span class="line">var m2  = new My(&quot;李&quot;, 1,&quot;女&quot;);</span><br></pre></td></tr></table></figure></p>
<p>构造函数创建对象存在的问题<br>如果将函数声明放在构造函数里，那么每次创建一个对象，都会拥有这个方法，所有对象的功能方法都一致；从而造成：</p>
<ol>
<li>资源的一种浪费。功能相同的函数，完全没有必要再内存中存在这么多份。所以就造成了资源浪费。</li>
<li><p>代码冗余</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.sayHi = function()&#123;</span><br><span class="line">        console.log(&quot;你好&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = new Person(&quot;张三&quot;, 18);</span><br><span class="line">var p1 = new Person(&quot;李四&quot;, 19);</span><br><span class="line">console.log(p.sayHi == p1.sayHi); //输出结果为false</span><br></pre></td></tr></table></figure>
<p> 构造函数创建对象存在的问题解决办法：</p>
</li>
</ol>
<p>在外部创建一个函数，书写构造函数的时候直接引用，这样的话解决了上述问题，但是又带来了新的问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function sayHello()&#123;</span><br><span class="line">    console.log(&quot;你好&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Person(name, age)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.sayHi = sayHello;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用该构造函数创建对象，并对比创建出来的对象的sayHi方法</span><br><span class="line">var p = new Person(&quot;张三&quot;, 18);</span><br><span class="line">var p1 = new Person(&quot;李四&quot;, 19);</span><br><span class="line">console.log(p.sayHi == p1.sayHi); //输出结果为true</span><br></pre></td></tr></table></figure>
<p><strong>构造函数存在的问题解决办法–新的问题</strong></p>
<ul>
<li>全局变量增多，会增加引入框架命名冲突的风险</li>
<li>代码结构混乱，会变得难以维护</li>
</ul>
<p><strong>构造函数存在的问题解决办法</strong></p>
<p>引入原型</p>
<h2 id="函数-值类型的数据作为函数的参数-的调用过程"><a href="#函数-值类型的数据作为函数的参数-的调用过程" class="headerlink" title="函数(值类型的数据作为函数的参数)的调用过程"></a>函数(值类型的数据作为函数的参数)的调用过程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function test1(num) &#123;</span><br><span class="line">     num = 100;</span><br><span class="line">   &#125;</span><br><span class="line">   var num1 = 10;</span><br><span class="line">   test1(num1);</span><br><span class="line">   console.log(num); //is not defined</span><br><span class="line">   console.log(num1); //10</span><br><span class="line">   //分析过程</span><br><span class="line">   1 num1 在内存中声明一个空间 赋值为 10 </span><br><span class="line">   2 函数调用  函数有形参，会先声明，并把实参的值赋值给他，num=10</span><br><span class="line">   3 执行函数 num =100;</span><br><span class="line">   4 执行完之后空间回收，所以num已经不存在,</span><br><span class="line">   5 所以最后 num1 输出的值是 10</span><br></pre></td></tr></table></figure>
<h2 id="函数-引用类型的数据作为函数的参数-的调用过程"><a href="#函数-引用类型的数据作为函数的参数-的调用过程" class="headerlink" title="函数(引用类型的数据作为函数的参数)的调用过程"></a>函数(引用类型的数据作为函数的参数)的调用过程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function test2(arr)&#123;</span><br><span class="line">      arr[0] = 100;</span><br><span class="line">    &#125;</span><br><span class="line">    var arr1 = [10,20,30];</span><br><span class="line">    test2(arr1);             </span><br><span class="line">    console.log(arr1[0]); //100</span><br><span class="line">    //分析过程</span><br><span class="line">    1 在内存中申明一个空间，用来存放数组[10,20,30] 变量 arr1 存放的数组[10,20,30]的地址。</span><br><span class="line">    2 调用函数 test2 ,因为有形参，所以先声明形参。并把存放在arr1中的地址赋值一份给arr</span><br><span class="line">    3 修改数组arr[0]的值。</span><br><span class="line">    4 回收形参arr的空间</span><br><span class="line">    5 输出arr1[0]的值</span><br></pre></td></tr></table></figure>
<h2 id="总结引用类型作为函数的参数和值类型作为函数的参数"><a href="#总结引用类型作为函数的参数和值类型作为函数的参数" class="headerlink" title="总结引用类型作为函数的参数和值类型作为函数的参数"></a>总结引用类型作为函数的参数和值类型作为函数的参数</h2><pre><code>. 引用类型因为指向的是同一个，所以你改一个，另外一个也就跟着改了。
. 值类型的话就不一样了。两者都是在不同的内存空间中，不会互相影响。
</code></pre><h2 id="函数-高级部分"><a href="#函数-高级部分" class="headerlink" title="函数  高级部分"></a>函数  高级部分</h2><h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><p>由构造函数点出来的属性，我们叫做静态成员。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.random(); </span><br><span class="line">Math.abs();</span><br></pre></td></tr></table></figure></p>
<h2 id="实例成员"><a href="#实例成员" class="headerlink" title="实例成员"></a>实例成员</h2><p>由实例化的对象点出来的属性，我们叫实例成员<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Person(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  Person.prototype.sayHi = function () &#123;</span><br><span class="line">    console.log(&quot;哈哈哈哈....&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">   Person.sayHi();</span><br><span class="line">//这里的sayHi是构造函数作为对象点出来的，所以这里的sayHi就是静态成员。</span><br></pre></td></tr></table></figure></p>
<h2 id="instancof"><a href="#instancof" class="headerlink" title="instancof"></a>instancof</h2><h2 id="eval函数"><a href="#eval函数" class="headerlink" title="eval函数"></a>eval函数</h2><p>可以把字符串当做代码执行，但是字符串要符合js代码规范<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eval(&quot;var a = 10;&quot;);</span><br><span class="line">console.log(a);//10</span><br></pre></td></tr></table></figure></p>

        </section>
    </article>
    <!-- 文末导航 s-->
    <div class="article-nav prev-next-wrap clearfix">
        
            <a href="/2017/05/10/js的数据类型/" class="fl pre-post btn btn-default" title='js的数据类型'>
                <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
                <span class="hidden-xs">js的数据类型</span>
            </a>
        
        
            <a href="/2017/02/13/js的简单总结/" class="fr next-post btn btn-default" title='js的简单总结'>
                <span class="hidden-lg">下一篇</span>
                <span class="hidden-xs">js的简单总结</span><i class="fa fa-angle-right fa-fw"></i>
            </a>
        
    </div>
 <!-- 文末导航 e -->
 
  <!-- disqus 评论框 start -->
  <div class="comment">
      <div id="disqus_thread" class="disqus-thread">
        <i>加载评论框需要翻墙</i>
      </div>
  </div>
  <!-- disqus 评论框 end -->

  

    
</div>
<aside>

<div class="toc-container">
  <h1>目录</h1>
  <div class="content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么要使用函数，使用函数的目的"><span class="toc-number">1.</span> <span class="toc-text">为什么要使用函数，使用函数的目的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#什么时候使用函数"><span class="toc-number">2.</span> <span class="toc-text">什么时候使用函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数名"><span class="toc-number">3.</span> <span class="toc-text">函数名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数体"><span class="toc-number">4.</span> <span class="toc-text">函数体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数名和变量名重名的情况"><span class="toc-number">5.</span> <span class="toc-text">函数名和变量名重名的情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数的参数"><span class="toc-number">6.</span> <span class="toc-text">函数的参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数参数的类型"><span class="toc-number">7.</span> <span class="toc-text">函数参数的类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#arguments"><span class="toc-number">8.</span> <span class="toc-text">arguments</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重载"><span class="toc-number">9.</span> <span class="toc-text">重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#返回值"><span class="toc-number">10.</span> <span class="toc-text">返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数–作用域"><span class="toc-number">11.</span> <span class="toc-text">函数–作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#预解析"><span class="toc-number">12.</span> <span class="toc-text">预解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数的声明方式："><span class="toc-number">13.</span> <span class="toc-text">函数的声明方式：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数的调用"><span class="toc-number">14.</span> <span class="toc-text">函数的调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数的检测"><span class="toc-number">15.</span> <span class="toc-text">函数的检测</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数的创建方法"><span class="toc-number">16.</span> <span class="toc-text">函数的创建方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数调用的方式"><span class="toc-number">17.</span> <span class="toc-text">函数调用的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this"><span class="toc-number">18.</span> <span class="toc-text">this</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字面量"><span class="toc-number">19.</span> <span class="toc-text">字面量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#匿名函数"><span class="toc-number">20.</span> <span class="toc-text">匿名函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#回调函数"><span class="toc-number">21.</span> <span class="toc-text">回调函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造函数"><span class="toc-number">22.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数-值类型的数据作为函数的参数-的调用过程"><span class="toc-number">23.</span> <span class="toc-text">函数(值类型的数据作为函数的参数)的调用过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数-引用类型的数据作为函数的参数-的调用过程"><span class="toc-number">24.</span> <span class="toc-text">函数(引用类型的数据作为函数的参数)的调用过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结引用类型作为函数的参数和值类型作为函数的参数"><span class="toc-number">25.</span> <span class="toc-text">总结引用类型作为函数的参数和值类型作为函数的参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数-高级部分"><span class="toc-number">26.</span> <span class="toc-text">函数  高级部分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#静态成员"><span class="toc-number">27.</span> <span class="toc-text">静态成员</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实例成员"><span class="toc-number">28.</span> <span class="toc-text">实例成员</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#instancof"><span class="toc-number">29.</span> <span class="toc-text">instancof</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#eval函数"><span class="toc-number">30.</span> <span class="toc-text">eval函数</span></a></li></ol>
  </div>
</div>

</aside>
</main>





<!-- disqus 公共JS代码 -->
<script type="text/javascript">
/* * * CONFIGURATION VARIABLES * * */
var disqus_shortname = "suijiafeng";
var disqus_identifier = "http://suijiafeng.com/2017/03/17/函数/";
var disqus_url = "http://suijiafeng.com/2017/03/17/函数/";
isAgent(getDisqus)
// determine user agent in China
function isAgent(cb) {
var url = '//graph.facebook.com/feed?callback=h';
var xhr = new XMLHttpRequest();
var called = false;
xhr.open('GET', url);
xhr.onreadystatechange = function() {
if (xhr.readyState === 4 && xhr.status === 200) {
called = true;
cb(true);
}
};
xhr.send();
// timeout 1s, this facebook API is very fast.
setTimeout(function() {
if (!called) {
xhr.abort();
cb(false)
}
}, 1000);
}
function getDisqus(isAgent) {
var dsq = document.createElement('script'); dsq.type = 'text/javascript'; 
dsq.async = true
dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq)
}
</script>
<!-- disqus 公共JS代码 end -->




  <footer class="footer-bg" style="background: #23282D; margin:20px 0 5px 0;">
  <div class="copyright" >
    <div style="margin: 0 auto">
        <p style="text-align:center">COPYRIGHT  2018  眭加凤.  ALL RIGHTS RESERVED.</p>
    </div>
  </div>
</footer>


<script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script src="/lib/in-view.min.js"></script>
<script src="/lib/lodash.min.js"></script>
<script>
  var isDown = true
  var oldY = 0
  inView.offset(50)

  document.body.addEventListener('touchstart', function(){});
  
  window.addEventListener('scroll', _.throttle(e => {
    var currentY = window.scrollY
    if((oldY - currentY) < 0) {
      isDown = true
    } else {
      isDown = false
    }
    oldY = currentY
  }, 250))

  $("article img").each(function() {
      var strA = "<a data-fancybox='gallery' href='" + this.src + "'></a>";
      $(this).wrapAll(strA);
  });

  $('.toc-link').each(function() {
      var href = $(this).attr("href");
      
      inView(href).on('exit', () => {
        if (isDown) {
          handleActive(href)
        }
      })

      inView(href).on('enter', () => {
        if (!isDown) {
          handleActive(href)
        }
      })

      this.onclick = function(e) {
        var pos = $(href).offset().top - 10;
        $("html,body").animate({scrollTop: pos}, 300);
        setTimeout(() => {
          handleActive(href)
        }, 350)
        return false
      }
  })

  function handleActive(href) {
    document.querySelectorAll('.toc-link').forEach(elm => {
      elm.classList.remove('active')
    })
    document.querySelector(".toc [href='"+ href +"']").classList.add('active')
  }
</script>
<script src="/lib/jquery.fancybox.min.js"></script>



</body>
</html>
