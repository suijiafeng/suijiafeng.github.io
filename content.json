{"meta":{"title":"眭加凤的博客","subtitle":"和你一起终生学习","description":"互联网前端学习","author":"suijiafeng","url":"http://suijiafeng.com"},"pages":[{"title":"about","date":"2018-01-23T17:40:05.000Z","updated":"2018-12-12T04:36:13.362Z","comments":true,"path":"about/index.html","permalink":"http://suijiafeng.com/about/index.html","excerpt":"","text":""},{"title":"about","date":"2018-01-23T17:40:11.000Z","updated":"2018-12-12T04:36:13.362Z","comments":true,"path":"about/index-1.html","permalink":"http://suijiafeng.com/about/index-1.html","excerpt":"","text":""},{"title":"留言","date":"2016-02-01T12:29:57.000Z","updated":"2018-12-12T04:36:13.362Z","comments":true,"path":"comment/index.html","permalink":"http://suijiafeng.com/comment/index.html","excerpt":"","text":""},{"title":"实验室","date":"2016-02-01T12:29:57.000Z","updated":"2018-12-12T04:36:13.378Z","comments":true,"path":"lab/index.html","permalink":"http://suijiafeng.com/lab/index.html","excerpt":"","text":""},{"title":"page","date":"2018-12-11T05:17:21.000Z","updated":"2018-12-11T05:28:49.877Z","comments":true,"path":"page/index.html","permalink":"http://suijiafeng.com/page/index.html","excerpt":"","text":"你好，我是坏人，你怕不怕？"}],"posts":[{"title":"ES6语法常用特性总结","slug":"ES6语法常用特性总结","date":"2018-08-20T15:18:06.000Z","updated":"2018-12-12T04:36:13.331Z","comments":true,"path":"2018/08/20/ES6语法常用特性总结/","link":"","permalink":"http://suijiafeng.com/2018/08/20/ES6语法常用特性总结/","excerpt":"","text":"ECMAScript6在保证向下兼容的前提下，提供大量新特性，目前浏览器兼容情况如下： ES6特性如下： 块级作用域关键字let,常量const blogexcerpt:123456789 对象字面量的属性赋值简写var obj = { // __proto__ __proto__: theProtoObj, // Shorthand for ‘handler: handler’ handler, // Method definitions toString() { // Super calls return &quot;d &quot; + super.toString(); }, // Computed (dynamic) property names [ &apos;prop_&apos; + (() =&gt; 42)() ]: 42 }; 赋值解构let singer = { first: &quot;Bob&quot;, last: &quot;Dylan&quot; }; let { first: f, last: l } = singer; // 相当于 f = &quot;Bob&quot;, l = &quot;Dylan&quot; let [all, year, month, day] = /^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)$/.exec(&quot;2015-10-25&quot;); let [x, y] = [1, 2, 3]; // x = 1, y = 2 4.函数参数（Default 、Rest 、Spread） //Default function findArtist(name=&apos;lu&apos;, age=&apos;26&apos;) { ... } //Rest function f(x, ...y) { // y is an Array return x * y.length; } f(3, &quot;hello&quot;, true) == 6 //Spread function f(x, y, z) { return x + y + z; } // Pass each elem of array as argument f(...[1,2,3]) == 6 箭头函数 简化了代码形式，默认return表达式结果。 自动绑定语义this，即定义函数时的this。如上面例子中，forEach的匿名函数参数中用到的this。 字符串模板var name = &quot;Bob&quot;, time = &quot;today&quot;; `Hello ${name}, how are you ${time}?` // return &quot;Hello Bob, how are you today?&quot; Iterators（迭代器）+ for..of迭代器有个next方法，调用会返回： 返回迭代对象的一个元素：{ done: false, value: elem } 如果已到迭代对象的末端：{ done: true, value: retVal } for (var n of [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]) { console.log(n); } // 打印a、b、c ClassClass，有constructor、extends、super，但本质上是语法糖（对语言的功能并没有影响，但是更方便程序员使用）。 class Artist { constructor(name) { this.name = name; } perform() { return this.name + &quot; performs &quot;; } } class Singer extends Artist { constructor(name, song) { super.constructor(name); this.song = song; } perform() { return super.perform() + &quot;[&quot; + this.song + &quot;]&quot;; } } let james = new Singer(&quot;Etta James&quot;, &quot;At last&quot;); james instanceof Artist; // true james instanceof Singer; // true james.perform(); // &quot;Etta James performs [At last]&quot; Map + Set + WeakMap + WeakSet四种集合类型，WeakMap、WeakSet作为属性键的对象如果没有别的变量在引用它们，则会被回收释放掉。 // Sets var s = new Set(); s.add(&quot;hello&quot;).add(&quot;goodbye&quot;).add(&quot;hello&quot;); s.size === 2; s.has(&quot;hello&quot;) === true; // Maps var m = new Map(); m.set(&quot;hello&quot;, 42); m.set(s, 34); m.get(s) == 34; //WeakMap var wm = new WeakMap(); wm.set(s, { extra: 42 }); wm.size === undefined // Weak Sets var ws = new WeakSet(); ws.add({ data: 42 });//Because the added object has no other references, it will not be held in the set 12.Math + Number + String + Array + Object APIs 一些新的API Number.EPSILON Number.isInteger(Infinity) // false Number.isNaN(&quot;NaN&quot;) // false Math.acosh(3) // 1.762747174039086 Math.hypot(3, 4) // 5 Math.imul(Math.pow(2, 32) - 1, Math.pow(2, 32) - 2) // 2 &quot;abcde&quot;.includes(&quot;cd&quot;) // true &quot;abc&quot;.repeat(3) // &quot;abcabcabc&quot; Array.from(document.querySelectorAll(&apos;*&apos;)) // Returns a real Array Array.of(1, 2, 3) // Similar to new Array(...), but without special one-arg behavior [0, 0, 0].fill(7, 1) // [0,7,7] [1, 2, 3].find(x =&gt; x == 3) // 3 [1, 2, 3].findIndex(x =&gt; x == 2) // 1 [1, 2, 3, 4, 5].copyWithin(3, 0) // [1, 2, 3, 1, 2] [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].entries() // iterator [0, &quot;a&quot;], [1,&quot;b&quot;], [2,&quot;c&quot;] [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].keys() // iterator 0, 1, 2 [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].values() // iterator &quot;a&quot;, &quot;b&quot;, &quot;c&quot; Object.assign(Point, { origin: new Point(0,0) }) Proxies使用代理（Proxy）监听对象的操作，然后可以做一些相应事情。 var target = {}; var handler = { get: function (receiver, name) { return `Hello, ${name}!`; } }; var p = new Proxy(target, handler); p.world === &apos;Hello, world!&apos;; 可监听的操作： get、set、has、deleteProperty、apply、construct、getOwnPropertyDescriptor、defineProperty、getPrototypeOf、setPrototypeOf、enumerate、ownKeys、preventExtensions、isExtensible。 SymbolsSymbol是一种基本类型。Symbol 通过调用symbol函数产生，它接收一个可选的名字参数，该函数返回的symbol是唯一的。 var key = Symbol(&quot;key&quot;); var key2 = Symbol(&quot;key&quot;); key == key2 //false PromisesPromises是处理异步操作的对象，使用了 Promise 对象之后可以用一种链式调用的方式来组织代码，让代码更加直观（类似jQuery的deferred 对象）。 function fakeAjax(url) { return new Promise(function (resolve, reject) { // setTimeouts are for effect, typically we would handle XHR if (!url) { return setTimeout(reject, 1000); } return setTimeout(resolve, 1000); }); } // no url, promise rejected fakeAjax().then(function () { console.log(&apos;success&apos;); },function () { console.log(&apos;fail&apos;); }); 总结对于ES6，在某些方式是不是重蹈ES4的覆辙，变得复杂了；又或许几年后大家的接受能力变强了，觉得是应该这样了。我觉得还是不错的，因为它们是向下兼容的，即使复杂语法不会用，也能用自己熟知的方式，提供的语法糖也都挺实际。","categories":[],"tags":[]},{"title":"vue3.0快速创建项目","slug":"vue3.0快速创建项目","date":"2018-08-13T14:45:36.000Z","updated":"2018-12-12T04:36:13.346Z","comments":true,"path":"2018/08/13/vue3.0快速创建项目/","link":"","permalink":"http://suijiafeng.com/2018/08/13/vue3.0快速创建项目/","excerpt":"","text":"前置条件更新npm到最新版本命令行运行: npm install -g npm npm就自动为我们更新到最新版本 使用 npm 全局安装 vue-cli ： npm i -g @vue/cli 创建项目执行： vue create my-project // my-project是要创建的文件夹 此处有两个选择： default (babel, eslint) // 默认套餐，提供babel和eslint支持 Manually select features // 自己去选择需要的功能，提供更多的特性选择。 比如如果想要支持 TypeScript ，就应该选择这一项。 可以使用上下方向键来切换选项。 如果只需要 babel 和 eslint 支持，那么选择第一项，就完事了，静静等待 vue 初始化项目。 vue-cli 内置支持了8个功能特性，可以多选：使用方向键在特性选项之间切换，使用空格键选中当前特性，使用 a 键切换选择所有，使用 i 键翻转选项。 对于每一项的功能，此处做个简单描述： TypeScript //支持使用 TypeScript 书写源码 Progressive Web App (PWA) //Support PWA 支持。 Router //支持 vue-router 。 Vuex 支持 vuex 。 CSS Pre-processors //支持 CSS 预处理器。 Linter / Formatter //支持代码风格检查和格式化。 Unit Testing //支持单元测试。 E2E Testing //支持 E2E 测试。 我选择了 Router，Vuex，CSS Pre-processors，Linter / Formatter 按住enter进入下一步，接下来都是对之前每项选项的更详细的选择。css选择SCSS/SASS Linter / Formatter选择prettier 这一步就是要选择配置文件的位置了。 对于Babel 、 PostCSS 等，都可以有自己的配置文件：.babelrc 、 .postcssrc 等等，同时也可以把配置信息放在 package.json 里面。此处出于对编辑器（ Visual Studio Code ）的友好支持（编辑器一般默认会在项目根目录下寻找配置文件），选择把配置文件放在外面，选择 In dedicated config files待补充Save this as a preset for future projects? 这个就是问要不要把当前的这一系列选项配置保存起来，方便下一次创建项目时复用。选择y。 选完之后， vue-cli 就根据前面选择的内容，开始初始化项目了。 启动项目初始完之后，进入到项目根目录： cd my-project 启动项目： npm run serve 稍等一会儿，可以看到自动在浏览器中打开了 安装PostCSS插件通过Vue-cli构建的项目，在项目的根目录下有一个.postcssrc.js，默认情况下已经有了： module.exports = { plugins: { autoprefixer: {} } } 5配置成 module.exports = { plugins: { &quot;postcss-import&quot;:{}, &quot;postcss-url&quot;:{}, &quot;autoprefixer&quot;: {} } } 安装postcss-import和postcss-url插件 $ npm install postcss-import和$ npm install postcss-url postcss-import相关配置点击这里。主要功有是解决@import引入路径问题。使用这个插件，可以让你很轻易的使用本地文件、node_modules或者web_modules的文件。这个插件配合postcss-url让你引入文件变得更轻松。 postcss-url相关配置可以点击这里。该插件主要用来处理文件，比如图片文件、字体文件等引用路径的处理。在Vue项目中，vue-loader已具有类似的功能，只需要配置中将vue-loader配置进去。autoprefixer插件是用来自动处理浏览器前缀的一个插件。如果你配置了postcss-cssnext，其中就已具备了autoprefixer的功能。 在配置的时候，未显示的配置相关参数的话，表示使用的是Browserslist指定的列表参数，你也可以像这样来指定last 2 versions 或者 &gt; 5%。如此一来，你在编码时不再需要考虑任何浏览器前缀的问题，可以专心撸码。这也是PostCSS最常用的一个插件之一。 配置插件我们要完成vw的布局兼容方案，或者说让我们能更专心的撸码，还需要配置下面的几个PostCSS插件： postcss-aspect-ratio-mini postcss-px-to-viewport postcss-write-svg postcss-cssnext cssnano postcss-viewport-units 要使用安装成功后，在项目根目录下的package.json文件中，可以看到新安装的依赖包： &quot;dependencies&quot;: { &quot;cssnano&quot;: &quot;^3.10.0&quot;, &quot;postcss-aspect-ratio-mini&quot;: &quot;^0.0.2&quot;, &quot;postcss-cssnext&quot;: &quot;^3.1.0&quot;, &quot;postcss-import&quot;: &quot;^11.1.0&quot;, &quot;postcss-px-to-viewport&quot;: &quot;^0.0.3&quot;, &quot;postcss-url&quot;: &quot;^7.3.2&quot;, &quot;postcss-viewport-units&quot;: &quot;^0.1.4&quot;, &quot;postcss-write-svg&quot;: &quot;^3.0.1&quot;, &quot;vue&quot;: &quot;^2.5.16&quot;, &quot;vue-router&quot;: &quot;^3.0.1&quot;, &quot;vuex&quot;: &quot;^3.0.1&quot; }, 接下来在.postcssrc.js文件对新安装的PostCSS插件进行配置： module.exports = { plugins: { &quot;postcss-import&quot;: {}, &quot;postcss-url&quot;: {}, //&quot;autoprefixer&quot;: {}, &quot;postcss-aspect-ratio-mini&quot;: {}, &quot;postcss-write-svg&quot;: { utf8: false }, &quot;postcss-cssnext&quot;: {}, &quot;postcss-px-to-viewport&quot;: { viewportWidth: 750, //视窗的宽度，对应的是我们设计稿的宽度，一般是750 viewportHeight: 1334, //视窗的高度，根据750设备的宽度来置顶，一般指定1334，也可以不配置 unitPrecision: 3, //指定&apos;px&apos;转换为视窗单位值的小数位数（很多时候无法整除） viewportUnit: &apos;vw&apos;, //指定需要转换成的视窗单位，建议使用vw selectorBlackList: [&apos;.ignore&apos;, &apos;.hairlines&apos;, &apos;.g-vw-no&apos;], //指定不转行为视窗单位的类，可以自定义，可以无限添加，建议定义一至两个通用的类名 minPixeValue: 1, //小于或等于&apos;1px&apos;不转换为视窗单位，你也可以设置为你想要的值 mediaQuery: false //允许在媒体查询中转换&apos;px&apos; }, &quot;postcss-viewport-units&quot;: {}, &quot;cssnano&quot;: { preset: &quot;advanced&quot;, autoprefixer: false, &quot;postcss-zindex&quot;: false } } } 特别声明：由于cssnext和cssnano都具有autoprefixer,事实上只需要一个，所以把默认的autoprefixer删除掉，然后把cssnano中的autoprefixer设置为false。对于其他的插件使用，稍后会简单的介绍。 由于配置文件修改了，所以重新跑一下npm run dev。 项目就可以正常看到了。接下来简单的介绍一下后面安装的几个插件的作用。 打包上线在开发完项目之后，就应该打包上线了。 vue-cli 也提供了打包的命令，在项目根目录下执行： npm run build 执行完之后，可以看到在项目根目录下多出了一个 dist 目录，该目录下就是打包好的所有静态资源，直接部署到静态资源服务器就好了。 下面作个总结 Vue3.0 与 Vue2.0 区别： 一、创建项目命令的变化。vue create my-project //vue3.0创建方式 vue init webpack my-project //Vue2.0 创建方式 同时3.0 版本包括默认预设配置 和 用户自定义配置 TypeScript Progressive Web App (PWA) Support Router Vuex CSS Pre-processors Linter / Formatter Unit Testing E2E Testing 二、 项目目录结构变化：我们对比发现 vue-cli 3.0 默认项目目录相比 2.0 来说精简了很多。 移除了配置文件目录， config 和 build 文件夹。 移除了 static 文件夹，新增 public 文件夹，并且 index.html 移动到 public 中。 在 src 文件夹中新增了 views 文件夹，用于分类 视图组件 和 公共组件。 三.移除了配置文件目录后如何自定义配置。从 3.0 版本开始，在项目的根目录放置一个 vue.config.js 文件, 可以配置该项目的很多方面。 vue.config.js 应该导出一个对象，例如： module.exports = { baseUrl: &apos;/&apos;, outputDir: &apos;dist&apos;, lintOnSave: true, compiler: false, // 调整内部的 webpack 配置。 // 查阅 https://github.com/vuejs/vue-doc-zh-cn/vue-cli/webpack.md chainWebpack: () =&gt; {}, configureWebpack: () =&gt; {}, // 配置 webpack-dev-server 行为。 devServer: { open: process.platform === &apos;darwin&apos;, host: &apos;0.0.0.0&apos;, port: 8080, https: false, hotOnly: false, // 查阅 https://github.com/vuejs/vue-doc-zh-cn/vue-cli/cli-service.md#配置代理 proxy: null, // string | Object before: app =&gt; {} } .... } 调整 webpack 配置最简单的方式就是在 vue.config.js 中的 configureWebpack 选项提供一个对象，该对象将会被 webpack-merge 合并入最终的 webpack 配置。 示例代码：配置 webpack 新增一个插件。 // vue.config.js module.exports = { configureWebpack: { plugins: [ new MyAwesomeWebpackPlugin() ] } } 修改插件选项的参数你需要熟悉 webpack-chain 的 API 并阅读一些源码以便了解如何权衡这个选项的全部配置项，但是它给了你比直接修改 webpack 配置中的值更灵活且安全的方式。 // vue.config.js module.exports = { chainWebpack: config =&gt; { config .plugin(&apos;html&apos;) .tap(args =&gt; { return [/* new args to pass to html-webpack-plugin&apos;s constructor */] }) } } 四. ESLint、Babel、browserslist 相关配置： Babel 可以通过 .babelrc 或 package.json 中的 babel 字段进行配置。 ESLint 可以通过 .eslintrc 或 package.json 文件中的 eslintConfig 字段进行配置。 你可能注意到了 package.json 中的 browserslist 字段指定了该项目的目标浏览器支持范围。 五. 关于 public 目录的调整。vue 约定 public/index.html 作为入口模板会通过 html-webpack-plugin 插件处理。在构建过程中，资源链接将会自动注入其中。除此之外，vue-cli 也自动注入资源提示( preload/prefetch ), 在启用 PWA 插件时注入 manifest/icon 链接, 并且引入(inlines) webpack runtime / chunk manifest 清单已获得最佳性能。 在 JavaScript 或者 SCSS 中通过 相对路径 引用的资源会经过 webpack 处理。放置在 public 文件的资源可以通过绝对路径引用，这些资源将会被复制，而不经过 webpack 处理。 小提示：图片最好使用相对路径经过 webpack 处理，这样可以避免很多因为修改网站根目录导致的图片404问题。","categories":[],"tags":[]},{"title":"webpack4的学习与填坑","slug":"webpack4的学习与填坑","date":"2018-07-11T16:56:00.000Z","updated":"2018-12-12T04:36:13.346Z","comments":true,"path":"2018/07/12/webpack4的学习与填坑/","link":"","permalink":"http://suijiafeng.com/2018/07/12/webpack4的学习与填坑/","excerpt":"","text":"在慕课上学习了webpack的课程，做了一些笔记，算分享也算记录吧。教程里的是webpack1和现在的webpack4有很多区别，自己也走了不少的坑，最好使用的时候去看官方文档。 https://webpack.js.org/在填坑的时候也借鉴了很多人写的文章。所以有很多部分是融合了超级多前人的经验总结，然后自己结合实际进行操作的做笔记。部分地方可能有重复，看得懂就好了。 1.全局安装webpack npm install -g webpack 2.创建项目文件，初始化项目文件目录 npm init 到项目文件下安装webpack npm install webpack 3.安装全局的webpack-cli npm install -g webpack-cli //获取当前webpack版本号配置文件 4.配置mode 默认有production和development两种模式可以设置 命令行设置 webpack –mode development 5.新建入口在项目文件目录下新建src文件夹，新建index.js文件入口 6.文件打包命令行输入 webpack --mode development 或 webpack --mode production webpack将会默认打包，将./src/index.js文件打包成./dist/main.js文件（自动生成dist文件夹和main.js文件） 7.建立html文件，在项目目录下建立html文件，可以直接引用dist/main.js文件。 注意，我们的 script 引用的文件是 dist/main.js，而不是 index.js。 这正是前端开发领域的一个趋势：开发的源文件（例子中的 index.js）与最终部署的文件（例子中的 dist/main.js）是区分开的，之所以这样，是因为开发环境与用户的使用环境并不一致。比如我们可以在开发环境使用 ES2017 甚至 ES2018 的特性，而用户的浏览器不见得支持 - 这也是 webpack 等打包工具的一个意义，它们能够辅助我们构建出在目标用户浏览器上正常运行的代码。 8.其他参数配置我们如果需要配置webpack指令的其他参数，只需要在webpack –mode production/development后加上其他参数即可，如： webpack --mode development --watch --progress --display-modules --colors --display-reasons 9.监控文件,实时刷新watch选项最为直观，但在默认情况下，watch选项是关闭状态。启用watch选项 webpack --mode development --watch 10.刷新浏览器（看官方文档容易填坑，奈何英语emmmm）https://github.com/webpack/webpack-dev-server https://webpack.js.org/configuration/dev-server/#devserverwebpack-dev-server,一个基于expressjs的开发服务器，提供实时刷新浏览器页面的功能。 安装webpack-dev-server首先在项目下安装 webpack-dev-server: npm install -g webpack-dev-server 然后在命令行下执行 webpack-dev-server –mode development –output-public-path dist webpack-dev-server是一个轻量级的服务器，修改文件源码后，自动刷新页面将修改同步到页面上安装webpack-dev-server： ①全局安装：npm install webpack-dev-server -g ②在项目中安装并将依赖写在package.json文件中:npm install webpack-dev-server –save-dev ③使用命令webpack-dev-server –mode development –output-public-path src完成自动刷新，指定publicPath，这部分很容易没有实时刷新。 ④默认的端口号是8080，如果需要8080端口被占用，就需要改端口，webpack-dev-server –port 3000(将端口号改为3000)，可以直接在webpack.config.js配置文件中配置devServer属性，开启热更新和port。 ⑤启动服务，输入localhost:端口号，就显示发布的所有根目录，如果项目根目录中没有index.html文件，就会在浏览器中列出项目根目录中的所有的文件夹。 ⑥当使用webpack-dev-server –mode development –output-public-path src命令时，在每次修改文件，是将文件打包保存在内存中并没有写在磁盘里，这种打包得到的文件和项目根目录中的index.html位于同一级。使用webpack命令将打包后的文件保存在磁盘中例如在index.html文件中引入通过webpack-dev-server –mode development –output-public-path src打包的build.js&lt;script src=&quot;build.js&quot;&gt;&lt;/script&gt; 在index.html文件中引入通过webpack命令打包的build.js &lt;script src=&quot;./build/build.js&quot;&gt;&lt;/script&gt;–inline 内联模式，在开发服务器的两种不同模式之间切换。默认情况下, 应用程序将被启用内嵌模式。这意味着将在包中插入一个脚本来处理实时重装, 并且生成消息将出现在浏览器控制台中。–hot 启用热模块更换功能 //////以上是搜索了各个教程里面说的，但是实际操作还是有问题，index.html入口文件是在根目录下，没有进行配置content-base，因为配置了之后会只打包配置的目录文件，默认是根文件。配置了output的publicPath（很重要，删掉之后就不能自动刷新了，应该是webpack-dev-server将每次打包的文件根据output设置生成在publicPath目录下，而文件本身依旧是手动打包的，无法查看到自动刷新打包的文件），只配置了端口，没有配置hot:true和inline:true(最开始配置了，但是有报错，所以删掉莫名OK了） ⑦webpack自带的watch命令与webpack-dev-server的区别–watch是文件修改后自动打包，webpack-dev-server是修改后发布到服务器上 ⑧webpack-dev-server –mode development –content-base src –inline –hot//显示只针对src路径下的文件刷新,文件修改之后浏览器自动刷新，如果要打开的文件和打包的文件不在一个文件夹内，最好不要设定文件夹 11.打包css文件 在项目目录下安装处理css文件的loader命令行输入： npm install css-loader style-loader --save-dev css-loader //处理css文件 style-loader //将css-loader处理后的文件作为样式标签&lt;style&gt;插入到html文件中 在处理css文件的时候要指定loader，如在index.js文件里输入 require(&apos;style-loader!css-loader!./style.css&apos;) 或者直接在命令行输入 webpack --mode development --module-bind “css=style-loader!css-loader”12–progress(查看进度)13–display-modules(显示隐藏的模块)14 –display-reasons(显示打包原因) 15.配置，webpack需要传入配置对象，因此进行新建配置文件webpack.config.js，或者使用node.js内置的path模块进行配置，并在它前面加上 __dirname这个全局变量。可以防止不同操作系统之间的文件路径问题，并且可以使相对路径按照预期工作。 ①先写moudule.exports={};进行配置； ②入口文件配置，entry=”入口文件路径，如./src/js/main.js”; ③输出文件配置，output={path:dirname+”输出文件路径，如/dist/js/bundle.js”};//要创建dist文件夹 dirname为运行时的当前路径；另一种方式，先定义const path = require(“path”);//引入nodejs的path模块 然后在输出文件路径path:path.resolve(__dirname,”./dist/js/bundle.js”); //path.resolve()方法解析了当前路径，将相对路径改为绝对路径。④重新指定配置文件名 webpack –config 文件名 如webpack –config webpack.dev.config.js 16.定义执行脚本，可以在package.json中设置 在script中设置，如设置”webpack”:”webpack –mode development –config webpack.config.js –progress –display-modules –colors –display-reason”,//–colors(彩色显示)直接执行上面的脚本npm run webpack 17.entry配置（chunk）， ①字符串表示，单输入，所有依赖都要在入口文件中指定，如entry:”./src/js/main.js”, ②数组表示，多输入，两个需要打包到一起的文件可以在配置文件的entry中用数组表示，如entry:[“./app/entry1”, “./app/entry2”],//这两个文件将会打包到一起 ③对象表示（哈希），多页面入口，entry:{page1:”./page1”,page2:[“./src/a.js”,”./src/b.js”]}, 这三种方式都会把文件打包到输出文件中。 18.output配置， ①单个入口起点，就设置一个出口，如output:{filename:’bundle.js’,path:’/dist/js’} ②多个入口起点，可以设置name或者hash，如output:{filename:’[name].js’,path:dirname+’/dist/js’}或output:{filename:’[name]-[hash].js’,path:dirname+’/dist/js’}或output:{filename:’[name]-[chunkhash].js’,path:__dirname+’/dist/js’} hash值可以认为是版本号或者MD5值保证每个文件的唯一性，每一次修改之后生成文件的hash值不一样，文件名不一样。③publicPath可以理解为占位符。当需要上线的时候可以将服务器地址设置到这个参数中，output: {path:&apos;xxx&apos;,filename:&apos;xxx&apos;,publicPath:&apos;http://cdn.com/&apos;} 插件（plugin）插件是 webpack 的支柱功能。webpack 自身也是构建在 webpack 配置中用到的相同的插件系统之上。插件目的在于解决 loader 无法实现的其他事。 19.插件html-webpack-plugin要引用之前先安装,在项目文件目录下安装 npm install html-webpack-plugin –save-dev安装好之后，在webpack.config.js配置文件中对插件的引用var htmlWebpackPlugin = require(‘html-webpack-plugin’);//commonJS写法在module.exports中添加plugin部分进行插件初始化，插件列表，当多个bundle需要共享一些相同的插件时，CommonChunkPlugin可以将这些依赖项提取到一个共享包中，以免重复。plugins:[ new webpack.optimize.CommonsChunkPlugin({ ….. }), new htmlChunkPlugin({ template:’index.html’,//自定义模板 filename:’index-[hash].html’,//生成文件名 inject:’head’,//指定链接注入在标签中还是标签中，为false值时表示不自动注入文件中，需要手动设置 title:’webpack demo’,//传递参数，可以在index.html模板中引用 minify:{//压缩html文件，具体参数设置可以查看官方文档 } }) ]index.html引用配置文件中的参数，JS语法模式，要使用JS语句可以使用&lt;%%&gt;将每行代码包裹起来。赋值可以使用&lt;%=xxx %&gt;，如&lt;%=htmlWebpackPlugin.options.title%&gt;就可以取到配置文件中定义的title的值。在配置文件中可以任意的配置参数向html文件进行传参。自定义引用的js文件可以直接写到html文件中如在html文件中相对应的位置写， &lt;script src=&quot;&lt;%=htmlWebpackPlugin.files.chunks.main.entry %&gt;&quot;&gt;&lt;/script&gt; &lt;script src=&quot;&lt;%=htmlWebpackPlugin.chunks.a.entry%&gt;&quot;&gt;&lt;/script&gt; chunk是文件入口以上是单文件引用的示例，多文件引用则需要调用多次的html-webpack-plugin插件，设置方式相同多页面使用同一个页面模板，可以定义htmlWebpackPlugin插件中的chunks参数，进行设置不同的页面引用不同的chunks，如设置chunks:[‘main’,’a’]excludeChunks:[‘a’],//指出排除的chunk直接将公共初始化脚本嵌入到html页面中，inline方式，在html模板中加上脚本源码引用代码，如 &lt;script type=&quot;text/javascript&quot;&gt; &lt;%=compilation.assets[htmlWebpackPlugin.files.chunks.main.entry.substr(htmlWebpackPlugin.files.publicPath.length)].source()%&gt; &lt;/script&gt; //.substr()的作用是将删除publicPath部分的绝对路径获取文件的相对路径。 按照文件顺序引用js文件可以手动设置for循环出htmlWebpackPlugin.files.chunks的entry值插入文件中。 20.loaderloader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。 本质上，webpack loader 将所有类型的文件，转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。loader能够import导入任何类型的模块。在webpack的配置中loader有两个目标： ①.test属性，用于表示出应该被对应的loader进行转换的某个或某些文件。 ②.use属性，表示进行转换时，应该使用那个loader。 使用方式：①配置，在webpack.config.js中指定②内联，在每个import语句中显示指定loader③CLI，在shell命令中指定 在webpack.config.js中配置loader 在module.exports中添加属性module如安装babel插件（js编译器），使用此插件转换ES6代码，如何安装根据官网进行安装： module:{ rules:[ { test:/.js$/, exclude:/node_modules/, loader:”babel-loader” } ] } 设置preset，指定preset（预配置）设置如何处理js文件 ①在rules中设置query:{presets:[‘latest’]} ②在根目录下创建一个.babelrc文件,其中内容为：{ “presets”:[“env”]}③在package.json中，增加babel属性：“babel”:{“presets”:[“latset”]} 21.优化可以在配置文件中，设置打包范围，如exclude设置不处理哪些模块，include处理哪些文件下的内容。具体可以看官方文档进行配置。","categories":[],"tags":[]},{"title":"关于Vue生命周期的使用与总结","slug":"关于Vue生命周期的使用与总结","date":"2018-06-19T14:45:00.000Z","updated":"2018-12-12T04:36:13.346Z","comments":true,"path":"2018/06/19/关于Vue生命周期的使用与总结/","link":"","permalink":"http://suijiafeng.com/2018/06/19/关于Vue生命周期的使用与总结/","excerpt":"","text":"所有的生命周期钩子自动绑定 this 上下文到实例中，因此可以通过其访问数据、运算等，下边会按照生命周期函数执行顺序来讲解 beforeCreate 实例初始化后，创建完成之前被调用 created 实例创建完成后被立即调用，这个时候还没有开始挂载 不能访问 $el beforeMount 挂载开始之前调用，即将开始挂载 对比：对应 react componentWillMount 在完成首次渲染之前调用 此时仍可以修改组件的状态 mounted 实例挂载之后调用，但是并不是所有子组件也都一起挂载完成，如果需要整个视图渲染完毕 可以使用 this.$nextTick(function () {}) 对比：对应 react componentDidMount 完成首次渲染之后调用， 可以在这里操作DOM beforeUpdate 数据更新完成前调用，发生在虚拟DOM重新渲染和打补丁前，在这里进一步的更改状态，不会触发重新渲染 对比：对应 react componentWillUpdate 接受状态的改变，进行渲染之前调用，不同的是 vue 中允许在这一步更改状态；而 react 则禁止，如果要更改状态要在 react 的 componentWillReceiveProps 声明周期中进行 updated 更改数据重新渲染虚拟DOM后调用，在这里，组件DOM已经更新，可以执行依赖DOM的操作，但是应该避免在这里更改状态，与 mounted 一样，不能保证所有子组件都挂载完成，可以使用 this.nextTick(function () {})` 进行全部渲染完的操作 对比：对应 react componentDidUpdate 完成渲染新的props或者state后调用，此时可以访问到新的DOM元素 beforeDestroy 实例销毁之前调用，在这一步，实例仍然可用 对比：对应 react componentWillUnmount 组件销毁之前调用，做一些清理工作 destroyed 实例销毁之后调用 对比：react 中没有这个生命周期钩子 其他 react 中有 componentWillReceiveProps 这个钩子，用来组件接受更新时调用，可以再次更新 props 或者 state, 在 vue 中虽然没有这个声明周期钩子，但是 vue 实例提供一个 watch 属性，可以用来监视状态改变，与 componentWillReceiveProps 功能类似 react 中有 shouldComponentUpdate 这个钩子，用来判断决定组件是否需要更新，以减少重新渲染，提升性能；在 vue 中组件是否需要更新，由 vue 框架主动判断，不在需要开发者在这个函数中操作了 总结一下他们大致的用处： beforecreate : 可以在这加个loading事件 created ：在这结束loading，还做一些初始化，实现函数自执行 mounted ： 在这发起axios请求，拿回数据，配合路由钩子做一些事情 beforeDestory： destoryed ：当前组件已被删除，清空相关内容","categories":[],"tags":[]},{"title":"express搭建后台服务器","slug":"express搭建简单的后台服务器","date":"2018-06-07T16:58:00.000Z","updated":"2018-12-12T04:36:13.346Z","comments":true,"path":"2018/06/08/express搭建简单的后台服务器/","link":"","permalink":"http://suijiafeng.com/2018/06/08/express搭建简单的后台服务器/","excerpt":"","text":"在实际开发的项目的过程中，有时候需要数据Api接口，但是，又因为种种原因，后端人员迟迟不能提供api接口。这个时候，mockjs可以模拟各种随机数据。但是对于像我这样懒的小伙伴，我想给你推荐一个更好，更方便的express搭建服务端框架，废话少说，跟着下面的步骤，就可以轻松搭建一个属于自己的模拟本地服务器。 安装Express 应用生成器此时，默认你已经安装了nodejs 运行这个命令装一下Express 应用生成器。npm install express-generator -g 然后创建一个应用，并安装依赖。express myapp cd myapp npm install 这时候，myapp文件夹里的文件结构如下： //myapp ├── app.js ├── bin │ └── www ├── package.json ├── public │ ├── images │ ├── javascripts │ └── stylesheets │ └── style.css ├── routes │ ├── index.js │ └── users.js └── views ├── error.jade ├── index.jade └── layout.jade 将你想要模拟服务器引用的文件放在pubilc里面，例如：public/myJSON.json最后，还有配置一个跨域名的访问的权限， `// app.js var app = express(); app.all(&apos;*&apos;, function(req, res, next) { res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); //这里的“*”，指的是来访者白名单。 res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;X-Requested-With&quot;); res.header(&quot;Access-Control-Allow-Methods&quot;,&quot;PUT,POST,GET,DELETE,OPTIONS&quot;); res.header(&quot;X-Powered-By&quot;,&apos; 3.2.1&apos;) res.header(&quot;Content-Type&quot;, &quot;application/json;charset=utf-8&quot;); next(); });` 启动express服务器npm start 然后在浏览器中打开 http://localhost:3000/myJson.json,就能模拟跨域服务器文件访问了。","categories":[],"tags":[]},{"title":"js 正则表达式总结","slug":"js正则表达式总结","date":"2018-06-05T14:45:00.000Z","updated":"2018-12-12T04:36:13.346Z","comments":true,"path":"2018/06/05/js正则表达式总结/","link":"","permalink":"http://suijiafeng.com/2018/06/05/js正则表达式总结/","excerpt":"","text":"1. 简介正则表达式(Regular Expression) 是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个规则字符串，这个规则字符串用来表达对字符串的一种过滤逻辑。 简单来说就是：按照某种规则去匹配符合条件的字符串。正则表达式的规则是/ pattern / flags 可以使用字面量形式或者new的方式来创建正则表达式 // 使用直接字面量创建，推荐使用，性能更好，注意这里pattern不能为空，不然以为是注释 var exp1 = /\\d/g // 使用RegExp对象创建 var exp2 = new RegExp(&apos;\\d&apos;, &apos;g&apos;); 模式中使用的所有元字符都建议在之前加\\转义，正则表达式中的元字符包括： ( [ { \\ ^ $ | ) ? * + . ] } 2. 内容2.1 匹配模式修饰符表示正则表达式的匹配模式 修饰符 描述 i 执行对大小写不敏感的匹配 g 执行全局匹配，查找所有匹配而非在找到第一个匹配后停止 m 执行多行匹配，会改变^和$的行为 u 可以匹配4字节的unicode编码 加了u修饰符，会正确处理大于\\uFFFF的unicode，比如4字节的?\\uD83D\\uDC2A /^\\uD83D/.test(&apos;\\uD83D\\uDC2A&apos;) // true /^\\uD83D/u.test(&apos;\\uD83D\\uDC2A&apos;) // false 2.2 类类使用[ ]来表达，用于查找某个范围内的字符 表达式 描述 [abc] 查找方括号之间的任何字符 [0-9] 查找任何从 0 至 9 的数字 还有一些预定义类方便我们直接使用： 预定义类 等价 描述 \\s [\\t\\n\\x0B\\f\\r] 空格 \\S [^\\t\\n\\x0B\\f\\r] 非空格 \\d [0-9] 数字 \\D [^0-9] 非数字 \\w [a-zA-Z_0-9] 单词字符 ( 字母、数字、下划线) \\W [^a-zA-Z_0-9] 非单词字符 . [^\\r\\n] 任意字符，除了回车与换行外所有字符 \\f \\x0c \\cL 匹配一个换页符 \\n \\x0a \\cJ 匹配一个换行符 \\r \\x0d \\cM 匹配一个回车符 \\t \\x09 \\cI 匹配一个制表符 \\v \\x0b \\cK 匹配一个垂直制表符 \\xxx 查找以八进制数 xxx 规定的字符 \\xdd 查找以十六进制数 dd 规定的字符 \\uxxxx 查找以十六进制数 xxxx 规定的 Unicode 字符 2.3 量词量词表示匹配多少个目标对象，精确匹配长度使用{ } 量词 等价 描述 n* {0,} 匹配零个或多个n n+ {1,} 匹配至少一个 n 的字符串 n? {0,1} 匹配零个或一个n {n} 匹配n次 {n,m} 匹配n到m次 {n,} 至少匹配n次 2.4 边界边界 描述 ^ 以xx开始，在类[ ]中表示非 $ 以xx结束 \\b 单词边界 \\B 非单词边界 ^ 匹配字符串开始位置，也就是位置0，如果设置了 RegExp 对象的 Multiline 属性 m ，^ 也匹配 &apos;n&apos; 或 &apos;r&apos; 之后的位置 $ 一般匹配字符串结束位置，如果设置了 RegExp 对象的 Multiline 属性m ，$ 也匹配 &apos;n&apos; 或 &apos;r&apos; 之前的位置 \\b 匹配一个单词边界，也就是指单词和空格间的位置，如er\\b可以匹配&quot;never&quot; 中的 &apos;er&apos;，但不能匹配 &quot;verb&quot; 中的 &apos;er&apos; \\B 匹配非单词边界。如er\\B能匹配 &quot;verb&quot; 中的 &apos;er&apos;，但不能匹配 &quot;never&quot; 中的 &apos;er&apos; 2.5 分组分组使用( )，作用是提取相匹配的字符串，使量词作用于分组比如hehe{3}是把e匹配了3次而不是单词，如果希望作用于单词，可以使用分组(hehe){3} 或分组中使用 | 可以达到或的效果比如：T(oo|ii)m可以匹配 Toom 和 Tiim `abToomhaTiimmm`.replace(/T(oo|ii)m/g, &apos;-&apos;) // ab-ha-mm 反向引用使用( )后可以使用$1-$9等来匹配 &apos;2018-02-11&apos;.replace(/(\\d{4})\\-(\\d{2})\\-(\\d{2})/g, &apos;$2/$3/$1&apos;) // 02/11/2018 后向引用\\n 表示后向引用，\\1是指在正则表达式中，从左往右数第1个( )中的内容；以此类推，\\2表示第2个( )，0表示整个表达式。 //匹配日期格式，表达式中的\\1代表重复(\\-|\\/|.) var rgx = /\\d{4}(\\-|\\/|.)\\d{1,2}\\1\\d{1,2}/ rgx.test(&quot;2016-03-26&quot;) // true rgx.test(&quot;2016-03.26&quot;) // false 后向引用和反向引用的区别是：\\n只能用在表达式中，而$n只能用在表达式之外的地方。 忽略分组如果不希望捕获某些分组，在分组内加上?:即可比如(?:tom).(ok)那么这里$1指的就是ok 前瞻前瞻是RegExp匹配到规则的时候，向后检查是否符合断言，后顾JS目前不支持 名称 正则 描述 正向前瞻 (?= ) 后面要有xx 负向前瞻 (?! ) 后面不能有xx &apos;1a2bc*456v8&apos;.replace(/\\w(?=\\d)/g, &apos;-&apos;) // 1-2bc*--6-8 匹配后面是数字的单词字符 &apos;1a2bc*456v8&apos;.replace(/\\w(?!\\d)/g, &apos;-&apos;) // -a---*45-v- 匹配后面不是数字的单词字符 (?=exp)匹配一个位置，这个位置的右边能匹配表达式exp，注意这个表达式仅仅匹配一个位置，只是它对于这个位置的右边有要求，而右边的东西是不会被放进结果的，比如用read(?=ing)去匹配&quot;reading&quot;，结果是&quot;read&quot;，而&quot;ing&quot;是不会放进结果的。 举个栗子，对密码应用以下限制：其长度必须介于 4 到 8 个字符之间，并且必须至少包含一个数字，正则是/^(?=.*\\d).{4,8}$/ 2.6 贪婪模式 与 非贪婪模式正则表达式在匹配的时候默认会尽可能多的匹配，叫贪婪模式。通过在限定符后加? 可以进行非贪婪匹配 比如\\d{3,6}默认会匹配6个数字而不是3个，在量词{ }后加一个? 就可以修改成非贪婪模式，匹配3次 `12345678`.replace(/\\d{3,6}/, &apos;-&apos;) // -78 `12345678`.replace(/\\d{3,6}?/, &apos;-&apos;) // -45678 &apos;abbbb&apos;.replace(/ab+?/, &apos;-&apos;) // -bbb 2.7 优先级优先级从高到低： 转义 \\ 括号( )、(?: )、(?= )、[ ] 字符和位置 或 | 3. 常用属性与方法3.1 RegExp构造函数属性RegExp构造函数上也包含一些属性，这些属性适用于作用域中所有的正则表达式，并且基于所执行的最近一次正则表达式操作而变化，这些属性分别有一个长属性名和短属性名 长属性名 短属性名 描述 input $_ 返回执行规范表述查找的字符串。只读 lastMatch $&amp; 返回任何正则表达式搜索过程中的最后匹配的字符。只读 lastParen $+ 如果有的话，返回任何正则表达式查找过程中最后括的子(分组)匹配。只读 leftContext $` 返回被查找的字符串中从字符串开始位置到最后匹配之前的位置之间的字符。只读 rightContext $&apos; 返回被搜索的字符串中从最后一个匹配位置开始到字符串结尾之间的字符。只读 3.2 RegExp实例上的属性属性 描述 global 是否全文搜索，默认false，对应修饰符的g，只读 ignoreCase 是否大小写敏感，默认false，对应修饰符i，只读 multiline 是否多行搜索，默认false，对应修饰符m，只读 flags 返回修饰符，只读 lastIndex 当前表达式匹配内容的最后一个字符的下一个位置 source 正则表达式的文本字符串 3.3 常用方法方法详细的探究可以看一下文章JS 进阶- test, exec, match, replace RegExp.prototype.test(str)测试字符串参数中是否存在匹配正则表达式的字符串，使用.test的时候如果修饰符有g，那么会正则会记住lastIndex并在下一次执行的时候从lastIndex处开始检测，如果只是为了测试是否符合正则，可以不用g或者每次都重新实例化正则表达式 const reg=/\\w/g reg.test(&apos;a&apos;) // true reg.test(&apos;a&apos;) // false RegExp.prototype.exec(str) 使用正则表达式对字符串执行搜索，并将更新全局RegExp对象的属性以反映匹配结果如果匹配失败，exec() 方法返回 null如果匹配成功，exec() 方法返回一个数组，并更新正则表达式对象的属性 数组索引0：匹配的全部字符串数组索引1,2..n：括号中的分组捕获index：属性是匹配文本的第一个字符的位置input：存放被检索的字符串要注意的是： exec()永远只返回一个匹配项（指匹配整个正则的） 如果设置了g修饰符，每次调用exec()会在字符串中继续查找新匹配项，不设置g修饰符，对一个字符串每次调用exec()永远只返回第一个匹配项。所以如果要匹配一个字符串中的所有需要匹配的地方，那么可以设置g修饰符，然后通过循环不断调用exec方法。 //匹配所有ing结尾的单词 const str=&quot;Reading and Writing&quot; const pattern=/\\b([a-zA-Z]+)ing\\b/g let matches while(matches=pattern.exec(str)){ console.log(matches.index +&apos; &apos;+ matches[0] + &apos; &apos; + matches[1]); } // 0 Reading Read // 12 Writing Writ String.prototype.search(reg) search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串方法返回第一个匹配结果的index，查找不到返回-1search() 方法不执行全局匹配，它将忽略修饰符g，并且总是从字符串的开始进行检索 String.prototype.split(reg)split() 方法一般用来分割字符串成数组，也可以传入正则表达式，使用正则可以避免一些传入字符串解决不了的问题 &apos;a1b2c3d4e&apos;.split(/\\d/) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;] &apos;a b c&apos;.split(&apos; &apos;) // [&apos;a&apos;, &apos;b&apos;, &apos;&apos;, &apos;&apos;, &apos;c&apos;] 无法识别连续空格 &apos;a b c&apos;.split(/\\s*/) // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;] String.prototype.match(reg) match() 方法将检索字符串，以找到一个或多个与reg相匹配的文本，reg是否有修饰符g影响很大返回值与RegExp.prototype.exec的返回类似，不过只返回匹配的字符串数组 &apos;cdbbdbsdbdbzddzdbbbd&apos;.match(/d(b+)d/g) // [&quot;dbbd&quot;, &quot;dbd&quot;, &quot;dbbbd&quot;] &apos;cdbbdbsdbdbzddzdbbbd&apos;.match(/d(b+)d/) // [&quot;dbbd&quot;, &quot;bb&quot;, index: 1, input: &quot;cdbbdbsdbdbzddzdbbbd&quot;] 如果修饰符有g 则匹配出所有匹配的数组，如果不是，则出第一个匹配的字符串，以及相应的捕获内容 String.prototype.replace(reg, str | num | function) 找到匹配并替换，传入string、number比较常见，这里传入回调function是比较高级的用法，这里可以参考MDN 比如一个场景，把手机号的中间4位换成* function validateMobile(str) { return /^[1][0-9]{10}$/.test(str) &amp;&amp; str.replace(/(\\d{3})(\\d{4})(\\d{4})/, (rs, $1, $2, $3) =&gt; `${$1}****${$3}`) } 也可以不返回值，用回调来遍历，比如一个在面试中会遇到的问题：找出重复最多的字符 let str = &apos;asss23sjdssskssa7lsssdkjsssdss&apos; const arr = str.split(/\\s*/) // 把字符串转换为数组 const str2 = arr.sort().join(&apos;&apos;) // 首先进行排序，这样结果会把相同的字符放在一起，然后再转换为字符串 let value = &apos;&apos; let index = 0 str2.replace(/(\\w)\\1*/g, function($0, $1) { //匹配字符 if (index &lt; $0.length) { index = $0.length // index是出现次数 value = $1 // value是对应字符 } }) console.log(`最多的字符: ${value} ,重复的次数: ${index}`) // s 17 商业转载请联系作者获得授权,非商业转载请注明出处。原文: https://mp.weixin.qq.com/s/_ub6XtBuL4ouJFfZ96cfwg 著作权归 © 微信公众号 “前端大杂烩” 作者所有。","categories":[],"tags":[]},{"title":"vue项目里前后端接口联调总结","slug":"vue项目里前后端接口联调总结","date":"2018-06-01T17:02:00.000Z","updated":"2018-12-12T04:36:13.346Z","comments":true,"path":"2018/06/02/vue项目里前后端接口联调总结/","link":"","permalink":"http://suijiafeng.com/2018/06/02/vue项目里前后端接口联调总结/","excerpt":"","text":"如何实现前后端接口联调 首先，我们已经知道，目前的前后端分离的架构应用分为两种情况： 前后端完全分离，前后端分别拥有自己的域名和服务器。 前后端开发分离，但是部署时是一个域名和一台服务器。 虽然架构可以采用前后端分离，但是部署有可能就不一样了，这和项目的大小，公司的情况等等都有关系了，一个百八十人用的小系统，还得两台服务器两个域名，你不觉着浪费吗？ 两种不同的部署情况直接导致了前期在设计联调方案的时候就不同了。 如果你们公司的项目在部署时是两台服务器对应两个域名，恭喜你，这是最nice的方案，也是联调最舒服的方式。 公司是一家刚起步的小公司，肯定是怎么节省成本怎么来，问过后端，才知道他们公司是属于第二种情况，也就是开发时前后端分离，部署时是一个域名和一台服务器。知道这个之后，就明白接下来该怎么操作了。 在此之前在项目根目录static文件夹下新建了一个mock文件夹，里面写了一些json文件，当我们做联调的时候，这些mock数据就没用了，我们要把mock数据切换成后端提供给我们的真实的数据。 当把static文件夹下的mock数据删除之后，在运行项目，发现报错了，浏览器提示，你访问的mock下面的index.json文件找不到404。 我们平时本地前端开发环境dev地址大多是 localhost:8080，而后台服务器的访问地址就有很多种情况了，比如 后端程序猿本地IP（127.0.0.1:8889），或者外网域名，当前端与后台进行数据交互时，自然就出现跨域问题（后台服务没做处理情况下）。axios不支持jsonp, 所以我们就要使用http-proxy-middleware中间件做代理。 现在通过在前端修改 vue-cli 的配置可解决：vue-cli中的 config/index.js 下配置 dev选项的 {proxyTable}: proxyTable: { ‘/api’: { target: ‘127.0.0.1:8889’, // 真实请求的地址 changeOrigin: true, // 是否跨域 pathRewrite: { ‘^/api’: ‘/static/mock’ } }} 如果你想在公司的vue项目中实现前后端联调，不需要再使用类似于fiddler charles的抓包代理工具了，你只需要使用proxyTable这个配置项，把你需要请求的后端的服务器地址写在target值里就OK了。 解决完跨域问题后，接下来王小闰该想想怎么在一台服务器一个域名下进行联调的问题了。比较常见的做法是前端在本地修改，本地查看，测试好了以后上传到服务器，看看线上环境可不可以，OK的话一切都好；不行就本地接着改，然后在上传。 联调完之后，如何将前端打包的项目文件发给后端，这里也需要注意两点： （1）css、js和图片等静态文件 这时候的静态文件在开发阶段不需要任何考虑，按照你喜欢的相对路径或者相对于项目的根路径的形式写就行了，因为早晚还得交给后端。但是，需要注意： 如果你采用 相对项目根路径的书写方式来写你的静态文件路径 时，一定要先和后端商量好，将来项目部署的时候他会把你的前端整个项目放在哪里？如果不是根目录下，你就挂了。比如：你的reset.css的路径是 /exports/styles/common/reset.css ，后端把你前端项目放在了根目录下的 frontEnd 文件夹下， reset.css 文件就报404了。 如果后端采用的java，你需要特别注意的是， tomcat的根目录 并不是 webapps 文件，而后端项目默认是部署在 webapps/ROOT 文件下的，所以你如果使用了相对项目根路径的书写方式来写你的静态文件路径时，对不起又是404了。 （2）ajax后端数据 因为现在唯一的一台服务器还是在后端程序猿那里，所以此时你还是可以写绝对路径（域名+请求路径），利用shost文件来改变域名映射实现联调。 最后，不管是在大公司还是在小公司，都需要知道，并不是说你将dist文件打包发给后端就完事了，就不需要了解leader后面操作的点击部署、合并分支的事儿了，技术时时刻刻在更新，固步自封，迟早的要被淘汰的。 另外，像基础命令、拉取分支、构建编译包、copy生产包到服务器、备份资料、启动脚本、灰度发布、等等流程其实都是很有必要了解的。","categories":[],"tags":[]},{"title":"vue2.0 引入 jQurey 的方式","slug":"vue2-0-引入-jQurey-的方式","date":"2018-05-27T17:03:00.000Z","updated":"2018-12-12T04:36:13.346Z","comments":true,"path":"2018/05/28/vue2-0-引入-jQurey-的方式/","link":"","permalink":"http://suijiafeng.com/2018/05/28/vue2-0-引入-jQurey-的方式/","excerpt":"","text":"最近学习vue，习惯性的通过&lt;script&gt;标签引入jquery，写完后报错才想起来，这种方式在vue是不适用的。 1：因为已经安装了vue脚手架，所以需要在webpack中全局引入jquery 打开package.json文件，在里面的dependencies加入这行代码，jquery后面的是版本，根据你自己需求更改。 dependencies:{ &quot;jquery&quot;:&quot;^2.2.3&quot; } 然后在命令行中npm install jquery –save-dev 大多人应该都是使用的淘宝镜像，所以使用cnpm，如果你不是 ，可以使用npm安装。 2：找到build文件夹下的webpack.base.conf.js文件中加入一行代码 var webpack=require(&quot;webpack&quot;) 3：然後在webpack.base.conf.js中module.exports的最后加入这行代码， plugins: [ new webpack.optimize.CommonsChunkPlugin(&apos;common.js&apos;), new webpack.ProvidePlugin({ jQuery: &quot;jquery&quot;, $: &quot;jquery&quot; }) ] 4：在main.js中引入,加入下面这行代码 import $ from &apos;jquery&apos; 5：最后一步，重新跑一边就好，npm run dev 6.验证方法 在APP.vue里进行验证 //app.vue &lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;img src=&quot;./assets/logo.png&quot;&gt; &lt;a class=&quot;alert&quot; href=&quot;javascript:;&quot;&gt;點我 &lt;/a&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name:&quot;app&quot;, } $(document).ready(function(){ $(&quot;a&quot;).click(function(){ $(this).hide(); alert(&quot;這就對了&quot;) }); }); &lt;/script&gt; &lt;style&gt; &lt;/style&gt; 能夠弹出 alert 内容，就说明jQuery 能正常使用。","categories":[],"tags":[]},{"title":"項目中常用到的Emmet语法","slug":"項目中常用到的Emmet语法","date":"2018-05-13T14:45:00.000Z","updated":"2018-12-12T04:36:13.362Z","comments":true,"path":"2018/05/13/項目中常用到的Emmet语法/","link":"","permalink":"http://suijiafeng.com/2018/05/13/項目中常用到的Emmet语法/","excerpt":"","text":"Emmet (前身为 Zen Coding) 是一个能大幅度提高前端开发效率的一个工具，基本上，大多数的文本编辑器都会允许你存储和重用一些代码块，我们称之为“片段”。虽然片段能很好地推动你得生产力，但大多数的实现都有这样一个缺点：你必须先定义你得代码片段，并且不能再运行时进行拓展。 Emmet把片段这个概念提高到了一个新的层次：你可以设置CSS形式的能够动态被解析的表达式，然后根据你所输入的缩写来得到相应的内容。Emmet是很成熟的并且非常适用于编写HTML/XML 和 CSS 代码的前端开发人员，但也可以用于编程语言。下面介紹幾種常見的Emmet語法： 后代：&gt;缩写：nav&gt;ul&gt;li &lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; 兄弟：+缩写：div+p+bq &lt;div&gt;&lt;/div&gt; &lt;p&gt;&lt;/p&gt; &lt;blockquote&gt;&lt;/blockquote&gt; 上级：^缩写：div+div&gt;p&gt;span+em^bq &lt;div&gt;&lt;/div&gt; &lt;div&gt; &lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt; &lt;blockquote&gt;&lt;/blockquote&gt; &lt;/div&gt; 分组：()缩写：div&gt;(header&gt;ul&gt;li*2&gt;a)+footer&gt;p &lt;div&gt; &lt;header&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/header&gt; &lt;footer&gt; &lt;p&gt;&lt;/p&gt; &lt;/footer&gt; &lt;/div&gt; 乘法：缩写：ul&gt;li5 &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; 自增符号：$缩写：h$[title=item$]{Header $}*3 &lt;h1 title=&quot;item1&quot;&gt;Header 1&lt;/h1&gt; &lt;h2 title=&quot;item2&quot;&gt;Header 2&lt;/h2&gt; &lt;h3 title=&quot;item3&quot;&gt;Header 3&lt;/h3&gt; ID和类属性缩写：#header &lt;div id=&quot;header&quot;&gt;&lt;/div&gt; 缩写：.title &lt;div class=&quot;title&quot;&gt;&lt;/div&gt; 缩写：form#search.wide &lt;form id=&quot;search&quot; class=&quot;wide&quot;&gt;&lt;/form&gt; 缩写：p.class1.class2.class3 &lt;p class=&quot;class1 class2 class3&quot;&gt;&lt;/p&gt; 自定义属性缩写：p[title=”Hello world”] &lt;p title=&quot;Hello world&quot;&gt;&lt;/p&gt; 文本：{}缩写：a{Click me} &lt;a href=&quot;&quot;&gt;Click me&lt;/a&gt; 缩写：p&gt;{Click }+a{here}+{ to continue} &lt;p&gt;Click &lt;a href=&quot;&quot;&gt;here&lt;/a&gt; to continue&lt;/p&gt; 隐式标签缩写：.class &lt;div class=&quot;class&quot;&gt;&lt;/div&gt; 缩写：em&gt;.class &lt;em&gt;&lt;span class=&quot;class&quot;&gt;&lt;/span&gt;&lt;/em&gt; 缩写：ul&gt;.class &lt;ul&gt; &lt;li class=&quot;class&quot;&gt;&lt;/li&gt; &lt;/ul&gt; 缩写：table&gt;.row&gt;.col &lt;table&gt; &lt;tr class=&quot;row&quot;&gt; &lt;td class=&quot;col&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; HTML缩写：link:css &lt;link rel=&quot;stylesheet&quot; href=&quot;&quot; /&gt; 缩写：link:favicon &lt;link rel=&quot;shortcut icon&quot; type=&quot;image/x-icon&quot; href=&quot;favicon.ico&quot; /&gt; 缩写：link:touch &lt;link rel=&quot;apple-touch-icon&quot; href=&quot;favicon.png&quot;&gt; 缩写：script:src &lt;script src=&quot;&quot;&gt;&lt;/script&gt; 别名：input:radio &lt;input type=&quot;radio&quot; name=&quot;&quot; id=&quot;&quot; /&gt; 缩写：input:submit &lt;input type=&quot;submit&quot; value=&quot;&quot; /&gt; 缩写：input:s &lt;input type=&quot;submit&quot; value=&quot;&quot; /&gt; 缩写：input:image &lt;input type=&quot;image&quot; src=&quot;&quot; alt=&quot;&quot; /&gt; 商业转载请联系作者获得授权,非商业转载请注明出处。原文: https://www.w3cplus.com/tools/emmet-cheat-sheet.html © w3cplus.com著作权归作者所有。","categories":[],"tags":[]},{"title":"Linux 常用命令简单总结","slug":"Linux-常用命令简单总结","date":"2018-05-06T05:06:10.000Z","updated":"2018-12-12T04:36:13.346Z","comments":true,"path":"2018/05/06/Linux-常用命令简单总结/","link":"","permalink":"http://suijiafeng.com/2018/05/06/Linux-常用命令简单总结/","excerpt":"","text":"包管理器apt-get Debian/Ubuntu系统包管理器apt-get 是Debian/Ubuntu系统中 一个用于快速下载/安装的简单命令行管理工具！ 使用示例： # 检索 新的包列表 apt-get update # 升级 可更新的所有软件包（注意这个命令会升级所有的软件包，所以会升级很长时间） apt-get upgrade # 安装 Nginx 软件包 apt-get install nginx # 卸载 Nginx 软件包 apt-get remove nginx # 卸载 Nginx 软件包 并删除所有相关配置文件 apt-get remove --purge nginx # 在安装软件和卸载的时候，为了避免误操作，都会询问是否继续，每次都要输入 y 来确定会很麻烦，可以加上 -y 参数 # 安装 Nginx 软件包 并不显示确定提示 apt-get install nginx -y # 卸载 Nginx 软件包，删除所有相关配置文件 并不显示提示 apt-get remove --purge nginx -y # 清除 旧的/无用 的软件包 apt-get clean &amp;&amp; apt-get autoclean # 下载 Nginx 二进制软件包到当前目录，但不解压和安装 apt-get download nginx -d # 更多的命令可以用 apt-get --help 查看。 yum CentOS系统包管理器yum 是CentOS系统中 一个用于快速下载/安装的简单命令行管理工具！ 使用示例： # 检索 新的包列表 yum update # 安装 Nginx 软件包 yum install nginx # 安装 Development Tools 软件包组（这个软件包组中包含了编译所需的软件） # 注意：当软件包或者软件包组的名字中包含空格的时候，请把 软件包或软件包组 加上双引号！ yum groupinstall &quot;Development Tools&quot; # 卸载 Nginx 软件包 yum erase nginx / yum remove nginx # 卸载 Development Tools 软件包组 yum groupremove &quot;Development Tools&quot; # 升级 所有可更新的软件包 yum upgrade # 升级 Nginx 可更新的软件包 yum upgrade nginx # 在安装软件和卸载的时候，为了避免误操作，都会询问是否继续，每次都要输入 y 来确定会很麻烦，可以加上 -y 参数 # 安装 Nginx 软件包 并不显示确定提示 yum install nginx -y # 卸载 Nginx 软件包 并不显示确定提示 yum erase nginx -y / yum remove nginx -y # 搜索 Nginx 软件包是否存着 yum search nginx # 列出 可用的软件包 yum list # 列出 可用的软件包组 yum grouplist # 清除 缓存目录中的所有软件包 yum clean # 清除 缓存目录中的 Nginx 软件包 yum clean nginx # 重装 Nginx 软件包 yum reinstall nginx 文件/文件夹 操作以下除特殊说明，都以当前目录为 /root 示例。 mkdir 新建 文件夹点击展开 查看 mkdir命令说明 # 在当前文件夹新建一个 bash 文件夹，完整的绝对路径就是 /root/bash mkdir bash # 更多的命令可以用 mkdir --help 查看。 cd 进入 文件夹 点击展开 查看 cd命令说明 # 你当前在 /root目录中，使用这个命令会进入 /root/bash目录，这是相对路径 cd bash # 如果你不在 /root目录中的话，就不能用上面的相对路径了，就需要绝对路径 cd /root/bash ———————————————————————————————————————————————————————————————————————————— # 假设你当前在 /root/bash目录中，使用相对路径，你可以用这个命令进入上一级 /root目录， .. 代表相对路径 上级目录 cd .. # 当然你也可以用绝对路径来进入上一级 /root目录 cd /root cp 复制或重命名 文件/文件夹 查看 cp命令说明 # 复制当前目录内的 log.txt文件到 /var目录 cp log.txt /var/log.txt # 复制当前目录内的 bash文件夹到 /home目录 cp -R bash /home/bash ———————————————————————————————————————————————————————————————————————————— # 复制当前目录内的所有.txt后缀的文件到 /var/log目录 cp *.txt /var/log # 复制当前目录内的所有以 doubi开头的文件到 /var/log目录 cp doubi* /var/log # 复制当前目录内的所有以 doubi开头 以.txt后缀结尾的文件到 /var/log目录 cp doubi*.txt /var/log ———————————————————————————————————————————————————————————————————————————— # 假设当前目录是 /root/doubi/log，要把这个目录中的所有.txt后缀的文件复制到上一级目录 /root/doubi，那么这样做 cp *.txt .. # .. 就是相对路径，代表上一级目录，当然你也可以用绝对路径，这样更不容易出错 cp *.txt /root/doubi ———————————————————————————————————————————————————————————————————————————— # 重命名当前目录内的 log.txt文件为 log2.txt cp log.txt log2.txt # 复制当前目录内的 log.txt文件到 /var目录并重命名为 log1.txt cp log.txt /var/log1.txt # 复制当前目录内的 bash文件夹到 /home目录并重命名为 bash2 cp -R bash /home/bash2 ———————————————————————————————————————————————————————————————————————————— # 复制当前目录内的 log.txt文件到 /var目录，但是 /var 目录中已经存着 log.txt，那么会提示 cp: overwrite `/var/log.txt&apos;? 可以用 -f 强制覆盖 cp -f log /var/log.txt # 复制当前目录内的 log.txt log1.txt log2.txt文件和 log233目录到 /home/log目录中 cp -R log.txt log1.txt log2.txt log233 /home/log # 更多的命令可以用 cp --help 查看。 mv 移动或重命名 文件/文件夹 查看 mv命令说明 # 关于 mv 命令，可以参考上面 cp 的使用方法，没什么区别，只是一个是复制，一个是移动，把上面 cp 命令改成 mv 就能套用了。 # 移动当前目录内的 log.txt文件到 /var目录 mv log.txt /var/log.txt # 移动当前目录内的 bash文件夹到 /home目录 mv bash /home/bash ———————————————————————————————————————————————————————————————————————————— # 重命名当前目录内的 log.txt文件为 log2.txt mv log.txt log2.txt # 复制当前目录内的 log.txt文件到 /var目录并重命名为 log1.txt mv log.txt /var/log1.txt # 复制当前目录内的 bash文件夹到 /home目录并重命名为 bash2 mv bash /home/bash2 # 更多的命令可以用 mv --help 查看。 rm 删除 文件/文件夹 查看 rm命令说明 # 删除当前目录下的 log.txt文件 rm log.txt # 删除当前目录下所有.txt后缀的文件 rm *.txt # 使用 rm 命令删除时，会提示你是否确定删除，输入 y 即删除，输入 n 则取消 # rm: remove regular file `log.txt&apos;? y ———————————————————————————————————————————————————————————————————————————— # 删除当前目录下所有.txt后缀的文件 rm *.txt # 删除当前目录下所有以 doubi开头的文件 rm doubi* # 删除当前目录下所有以 doubi开头 以.txt后缀结尾的文件 rm doubi*.txt ———————————————————————————————————————————————————————————————————————————— # 当你用 rm 删除目录的时候会发现提示这不是一个文件 # rm bash # rm: cannot remove `bash&apos;: Is a directory # 可以加上 -r 来归递删除目录及其目录下的内容 rm -r bash ———————————————————————————————————————————————————————————————————————————— # 因为为了避免手误删除错误，所以 rm默认是加上了 -i 的参数，也就是每一次删除文件/目录都会提示，如果觉得烦可以用 -rf 参数 rm -rf bash # rm -rf 这个命令请慎重使用，而且千万不要使用 rm -rf / 或者 rm -rf /* 之类的命令(系统自杀)，可能会让你系统爆炸，所以使用请慎重！ # 更多的命令可以用 rm --help 查看。 查看/编辑文件 操作ls 显示目录中文件 查看 ls命令说明 # 显示当前目录下的所有文件 ls -a ———————————————————————————————————————————————————————————————————————————— # 命令后面加上 绝对路径/相对路径 就会显示指定文件夹内的所有文件 ls -a bash/log # 相对路径，当前目录是 /root ，欲查看的目录是 /root/bash/log ls -a /root/bash/log # 绝对路径， 当前目录是 /root ，欲查看的目录是 /root/bash/log # 更多的命令可以用 ls --help 来查看。 du 查看 文件/文件夹 占用磁盘空间的大小 查看 du命令说明 使用示例： # 显示 /root 文件夹的大小，但不显示其子目录和文件的大小 du -sh # 显示 /root 文件夹的大小，并显示其子目录和文件的大小 du -ah # 待写... # 更多的命令可以用 du --help 来查看。 cat 查看文件内容 查看 cat命令说明 假设 log.txt文件的内容为： doubi233 doubi doubi666 doubi2366 doubi8888 查看文件： # 查看 log.txt文件的所有内容 cat log.txt # 输出示例如下 doubi233 doubi doubi666 doubi2366 doubi8888 # 查看 log.txt文件的所有内容，并对所有行编号 cat -n log.txt # 输出示例如下： 1 doubi233 2 doubi 3 4 5 doubi666 6 7 doubi2366 8 doubi8888 # 查看 log.txt文件的所有内容，并对非空行编号 cat -b log.txt # 输出示例如下： 1 doubi233 2 doubi 3 doubi666 4 doubi2366 5 doubi8888 # 查看 log.txt文件的所有内容，并对非空行编号，且不输出多行空行 cat -bs log.txt # 输出示例如下： 1 doubi233 2 doubi 3 doubi666 4 doubi2366 5 doubi8888 清空文件： # 清空当前目录中的 log.txt 文件 cat /dev/null &gt; log.txt # 清空 /var目录中的 log.txt 文件 cat /dev/null &gt; /var/log.txt 写入文件： # 写入文本到当前目录中的 log.txt文件中(加入文本到文件内容最后) cat &gt;&gt; log.txt &lt;&lt;-EOF doubi doubi233 doubi666 EOF # 清空文件并写入文本到 /var目录中的 log.txt文件中(先清空后写入) cat &gt; /var/log.txt &lt;&lt;-EOF doubi doubi233 doubi666 EOF # 更多的命令可以用 cat --help 来查看。 head 查看文件内容（主要用于正查） 使用示例： 假设 log.txt 文件内容为： doubi1 doubi2 doubi3 doubi4 doubi5 # 查看 log.txt文件的全部内容 head log.txt # 查看 log.txt文件的前 4字节的内容 head -c 4 log.txt # 输出示例 doub # 查看 log.txt文件的前 2行的内容 head -n 2 log.txt # 输出示例 doubi1 doubi2 # 查看 log.txt文件的从倒数第2行到行首的内容 head -n -2 log.txt # 输出示例 doubi1 doubi2 doubi3 # 查看 log.txt log1.txt log2.txt文件的前 3行内容 head -n 3 log.txt log1.txt log2.txt # 更多的命令可以用 head --help 来查看。 tail 查看文件内容（主要用于倒查） 使用示例： 假设 log.txt 文件内容为： doubi1 doubi2 doubi3 doubi4 doubi5 # 查看 log.txt文件的全部内容 tail log.txt # 查看 log.txt文件从行首 第25字节到最后的内容 tail -c +25 log.txt # 输出示例 bi4 doubi5 # 查看 log.txt文件从行尾 第4字节到最前面的内容 tail -c -4 log.txt # 输出示例 bi5 # 查看 log.txt文件的从第2行到最后一行的内容 tail -n +2 log.txt # 输出示例 doubi2 doubi3 doubi4 doubi5 # 查看 log.txt文件的后 2行的内容 tail -n -2 log.txt # 输出示例 doubi4 doubi5 # 持续查看（监视） log.txt文件的变化内容（新增加的内容），使用 Ctrl＋C 终止 tail -f log.txt # 查看 log.txt log1.txt log2.txt文件的前 3行内容 tail -n 3 log.txt log1.txt log2.txt # 更多的命令可以用 tail --help 来查看。 sed 查看/编辑文件内容 查看 sed命令说明 参数介绍： -i ：操作后应用保存到原文件（如果不加这个参数，那么任何修改都不会影响原文件里的内容，只会把结果输出） # 待写... # 更多的命令可以用 sed --help 来查看。 使用示例： # 查看 log.txt 第3行的内容 sed &apos;3p&apos; log.txt # 查看 log.txt 第2-8行的内容 sed &apos;2,8p&apos; log.txt # 删除 log.txt 第4行 sed -i &apos;4d&apos; log.txt # 删除 log.txt 第3-7行 sed -i &apos;3,7d&apos; log.txt # 删除 log.txt 第1行 sed -i &apos;1d&apos; log.txt # 删除 log.txt 最后1行 sed -i &apos;$d&apos; log.txt # 删除 log.txt 文件中所有包含 233内容的行 sed -i &apos;/233/d&apos; log.txt # 替换 log.txt 文件中所有 233为666 sed -i &apos;s/233/666/&apos; log.txt # 替换 log.txt 文件中所有 /ver 为 doubi/，因为有斜杠，所以需要使用 \\ 转义，但是单引号会导致无法转义，所以要改成双引号。 sed -i &quot;s/\\/ver/doubi\\//&quot; log.txt # 待写... # 更多的命令可以用 sed --help 来查看。 vim 编辑文件内容 查看 vim 命令说明 vim 介绍 vim 相当于 vi的扩展或者加强版，一些系统只安装了 vi，所以想要用 vim还需要手动安装( yum install vim -y / apt-get install vim -y)，安装 vim后，会自动替换或者说整合 vi。 当你使用 vi 命令的时候，首先进入的是 命令行模式，这个模式就是 vi 自身的功能，而点击 I 键 后就会进入编辑模式(插入模式)，这时候就可以直接输入字符了，这个就是 vim的扩展功能了。当修改完成后，按 ESC键 即可退出编辑模式回到命令行模式，这时候输入 :wq 并回车代表保存并退出，如果不想保存可以使用 :q! 不保存强制退出。 vim的命令行 命令很多，我也没打算都写出来，只写出最常用的好了。 # 打开当前目录下的 log.txt文件，如果没有那么会新建 log.txt文件（安装vim后，使用 vi和 vim打开文件没区别） vi log.txt vim log.txt # 在命令行模式下，直接输入以下 符号和字母(区分大小写) ## 进入编辑模式（插入模式，按 Esc键 即可返回命令行模式） i ## 删除光标当前所在的一行 dd ## 删除文件内所有内容 dddG ## 复制光标当前所在的一行 yy ## 粘贴刚才复制的一行内容 p ## 撤销上个操作（误操作可以用这个恢复） u ## 保存当前文件（ : 是英文的冒号） :w ## 另存当前文件内容为 log2.txt :w log2.txt ## 退出当前文件 :q ## 不保存 并强制退出当前文件 :q! ## 保存并退出当前文件 :wq # 更多的命令可以用 vi --help / vim --help 来查看。 解压缩 操作在Linux中经常会下载到压缩文件，而压缩文件的格式有很多，比如 zip、rar、gz、xz、tar.gz、tar.xz等。 tar gz zip等 解压 压缩包 示例 查看 解压压缩包说明 # 解压后缀为 .tar 的压缩包 tar -xf log.tar ———————————————————————————————————————————————————————————————————————————— # 解压后缀为 .tar.xz 的压缩包 tar -xJf log.tar.xz ———————————————————————————————————————————————————————————————————————————— # 解压后缀为 .tar.gz 的压缩包，有两个方法 tar -xzf log.tar.gz ———————————————————————————————————————————————————————————————————————————— # 解压后缀为 .gz 的压缩包，有两个方法，如提示命令不存在，请安装 yum install gzip -y / apt-get install gzip -y gzip -d log.gz gunzip log.gz ———————————————————————————————————————————————————————————————————————————— # 解压后缀为 .bz / .bz2 / tar.bz2 的压缩包，有两个方法 bzip2 -d log.bz bunzip2 log.bz tar -jxf log.tar.bz bzip2 -d log.bz2 bunzip2 log.bz2 tar -jxf log.tar.bz2 ———————————————————————————————————————————————————————————————————————————— # 解压后缀为 .Z / tar.Z 的压缩包，有两个方法 uncompress log.Z log.txt uncompress log.Z log ———————————————————————————————————————————————————————————————————————————— tar xZf log.tar.Z log.txt tar xZf log.tar.Z log ———————————————————————————————————————————————————————————————————————————— # 解压后缀为 .rar 的压缩包，如提示命令不存在，请安装 yum install unrar -y / apt-get install unrar -y ，注意 rar 和 unrar 是分开的 unrar x log.rar ———————————————————————————————————————————————————————————————————————————— # 解压后缀为 .zip 的压缩包，如提示命令不存在，请安装 yum install unzip -y / apt-get install unzip -y，注意 zip 和 unzip 是分开的 unzip log.zip # 更多的命令可以用 tar --help / gzip --help / unrar --help / unzip --help 来查看。 压缩 文件/文件夹 示例 点击展开 查看 压缩文件/文件夹说明 # 分别压缩当前目录下的 log.txt文件 / log文件夹为 log.tar 压缩包 tar -cf log.tar log.txt tar -cf log.tar log ———————————————————————————————————————————————————————————————————————————— # 如果要压缩多个文件和文件夹，那么只需要在后面一直加下去即可 tar -cf log.tar log.txt doub.txt log bash ———————————————————————————————————————————————————————————————————————————— # 分别压缩当前目录下的 log.txt文件 / log文件夹为 log.tar.xz 压缩包，以下的其他后缀压缩命令都是一样 tar -cJf log.tar.xz log.txt tar -cJf log.tar.xz log ———————————————————————————————————————————————————————————————————————————— # 分别压缩当前目录下的 log.txt文件 / log文件夹为 log.tar.gz 压缩包 tar -czf log.tar.gz log.txt tar -czf log.tar.gz log ———————————————————————————————————————————————————————————————————————————— # 分别压缩当前目录下的 log.txt文件 / log文件夹为 log.gz 压缩包 gzip log.gz log.txt gzip log.gz log ———————————————————————————————————————————————————————————————————————————— # 分别压缩当前目录下的 log.txt文件 / log文件夹为 log.tar.bz 压缩包 暂时没查到 ———————————————————————————————————————————————————————————————————————————— # 分别压缩当前目录下的 log.txt文件 / log文件夹为 log.bz / log.tar.bz / log.bz2 / log.tar.bz2压缩包 bzip2 -z log.txt bzip2 -z log tar cjf log.tar.bz2 log.txt tar cjf log.tar.bz2 log ———————————————————————————————————————————————————————————————————————————— # 分别压缩当前目录下的 log.txt文件 / log文件夹为 log.Z / log.tar.Z 压缩包 compress log.txt compress log tar cZf log.tar.Z log.txt tar cZf log.tar.Z log ———————————————————————————————————————————————————————————————————————————— # 分别压缩当前目录下的 log.txt文件 / log文件夹为 log.rar 压缩包，如提示命令不存在，请安装 yum install rar -y / apt-get install rar -y ，注意 rar 和 unrar 是分开的 unrar a log.rar log.txt unrar a log.rar log ———————————————————————————————————————————————————————————————————————————— # 分别压缩当前目录下的 log.txt文件 / log文件夹为 log.zip 压缩包，如提示命令不存在，请安装 yum install zip -y / apt-get install zip -y ，注意 zip 和 unzip 是分开的 zip log.zip log.txt zip log.zip log # 更多的命令可以用 tar --help / gzip --help / rar --help / zip --help 来查看。 网络工具wget 下载工具wget 是Linux系统最常用的工具之一，命令行方式的多功能下载工具，支持HTTP，HTTPS和FTP协议。 查看 wget命令说明 使用示例： # 下载一个文件到当前目录 wget https://softs.fun/100MB.bin # 下载文件到当前目录并重命名为 200MB.bin wget -O &quot;200MB.bin&quot; https://softs.fun/100MB.bin # 下载文件到 /root目录（-P只能指定下载目录，并不能指定文件名） wget -P &quot;/root&quot; https://softs.fun/100MB.bin # 下载文件到 /root/doubi目录并重命名为 200MB.bin wget -O &quot;/root/doubi/200MB.bin&quot; https://softs.fun/100MB.bin # 下载文件完成之前 wget进程结束了，那么可以使用断点续传重新下载中断的文件（前提是下载服务器支持断点续传） wget -c https://softs.fun/100MB.bin # 通过后台下载文件到 /root/doubi目录并重命名为 200MB.bin wget -b -O &quot;/root/doubi/200MB.bin&quot; https://softs.fun/100MB.bin # Continuing in background, pid 2333. # Output will be written to `wget-log&apos;. # 后台下后，你可以使用以下命令来查看下载进度： tail -f wget-log # 有时候一些Linux系统中的SSL证书不完整，会导致下载一些 HTTPS网站文件的时候会验证SSL证书失败，可以这样做 # 不验证服务器SSL证书，下载文件到当前目录并重命名为 200MB.bin wget --no-check-certificate -O &quot;200MB.bin&quot; https://softs.fun/100MB.bin # 使用wget发送POST请求数据 wget --post-data &quot;user=doubi&amp;passwd=23333&quot; https://xxx.xx/ # 下载文件到当前目录 并仅通过IPv4连接 只获取比本地新的文件，限速 200KB/S wget --limit-rate=200k -N -4 https://softs.fun/100MB.bin # 下载文件到当前目录 并重试次数为 1，超时时间为 2秒 wget -t1 -T2 https://softs.fun/100MB.bin # 通过 wget来获取服务器的外网IP（-qO- 代表运行完会输出下载的信息，并不会保存到本地文件） wget -qO- ipinfo.io/ip # 更多的命令可以用 wget --help 来查看。 curl 下载工具curl是Linux系统一个利用URL规则在命令行下工作的文件传输工具，是一款很强大的HTTP命令行工具。它支持文件的上传和下载，是综合传输工具，但习惯称curl为下载工具。点击展开 查看 curl命令说明 使用示例： # 获取当前服务器的外网IP curl ipinfo.io/ip # 获取一个文件保存到当前目录中 wget -O https://softs.fun/Bash/ssr.sh # 获取一个文件保存到 /root/doubi目录中 并修改文件名为 233.sh curl -o &quot;/root/doubi/233.sh&quot; https://softs.fun/Bash/ssr.sh # 下载文件完成之前 curl进程结束了，那么可以使用断点续传重新下载中断的文件（前提是下载服务器支持断点续传） curl -C -O https://softs.fun/100MB.bin # 有时候一些Linux系统中的SSL证书不完整，会导致访问/下载一些 HTTPS网站/文件的时候会验证SSL证书失败，可以这样做 # 不验证服务器SSL证书，下载文件到当前目录并重命名为 233.sh curl -k -o &quot;233.sh&quot; https://softs.fun/Bash/ssr.sh # 使用curl发送GET请求数据 curl https://xxx.xx/?user=doubi # 使用curl发送POST请求数据 curl --data &quot;user=doubi&amp;passwd=23333&quot; https://xxx.xx/ # 下载文件到当前目录 并仅通过IPv4连接，限速 200KB/S curl --limit-rate 200K -4 https://softs.fun/100MB.bin # 下载文件到当前目录 并重试次数为 1，超时时间为 2秒 curl --retry 1 -m 10 https://softs.fun/100MB.bin # 更多的命令可以用 curl --help 来查看。 netstat 查看链接和端口监听等信息 查看 netstat命令说明 使用示例： # 显示当前服务器的所有连接信息 netstat -a # 显示当前服务器的所有 TCP连接信息 netstat -at # 显示当前服务器的所有 UDP连接信息 netstat -au 一般来说经常使用这个命令： # 显示当前服务器的所有正在监听 TCP端口的信息，并且 显示进程PID和进程名，但不显示别名（域名以IP显示），这个命令算是最常用的了。 netstat -lntp # 输出示例 Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN 14233/nginx.conf tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 1555/sshd tcp 0 0 0.0.0.0:443 0.0.0.0:* LISTEN 14233/nginx.conf tcp6 0 0 :::22 :::* LISTEN 1555/sshd # 显示监听 80端口的进程PID和进程名，grep是匹配并显示 符合关键词的行。 netstat -lntp|grep &quot;:80&quot; # 输出示例 Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN 14233/nginx.conf # 显示 ssh的监听情况，grep是匹配并显示 符合关键词的行。 netstat -lntp|grep &quot;ssh&quot; # 输出示例 Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 1555/sshd 表头解释： Proto ：连接协议（tcp/udp是IPv4，tcp6/udp6是IPv6） Recv-Q ： 接收队列（基本都是0，如果不是代表堆积） Send-Q ：发送队列（基本都是0，如果不是代表堆积） Local Address ：本地地址和端口 Foreign Address ：对外地址和端口 State ：连接状态 PID/Program name ：进程PID/进程名 # 每隔 1秒显示一次当前服务器的所有连接信息 netstat -c # 每隔 1秒显示一次当前服务器的所有 TCP连接信息 netstat -ct # 每隔 1秒显示一次当前服务器的所有 UDP连接信息 netstat -cu # 显示当前服务器的路由表 netstat -r # 显示当前服务器的网络接口信息（网卡） netstat -i # 显示当前服务器的网络统计信息 netstat -s # 更多的命令可以用 netstat --help 来查看。 在使用 netstat命令中，会显示一些连接状态，下面是各状态的意思： LISTEN # 监听来自远程连接的 TCP端口连接请求 SYN-SENT # 在发送连接请求后，等待匹配的连接请求 SYN-RECEIVED # 在收到和发送一个连接请求后，等待对方对连接请求的确认 ESTABLISHED # 代表一个打开的连接 FIN-WAIT-1 # 等待远程 TCP连接中断请求，或先前的连接中断请求的确认 FIN-WAIT-2 # 从远程 TCP等待连接中断请求 CLOSE-WAIT # 等待从本地用户发来的连接中断请求 CLOSING # 等待远程TCP对连接中断的确认 LAST-ACK # 等待原来的发向远程TCP的连接中断请求的确认 TIME-WAIT # 等待足够的时间，以确保远程TCP接收到连接中断请求的确认 CLOSED # 没有任何连接状态（或者关闭了连接） 系统命令 date 查看/设置 系统时间 查看 date命令说明 使用示例： # 显示 当前系统时间 date # 输出：Wed Apr 5 12:38:44 CST 2017 # 显示当前系统的 UTC时间 date -u # 输出：Wed Apr 5 04:30:06 UTC 2017 # 显示 log.txt 文件的最后修改时间 date -r log.txt # 显示 当前日期的年份 date +%Y # 输出：2017 # 显示 当前日期的月份 date +%m # 输出：4 # 显示 各种格式类型的日期 date +%D # 输出：04/05/17 date +%Y-%m-%d # 输出：2017-04-05 date +%m/%d/%y # 输出：04/05/17 date +%m/%d/%Y # 输出：04/05/2017 # 显示 Unix时间戳 date +%s # 输出：1491367399 # 显示一个完整的时间（年、月、日、小时、分钟、秒钟、周几 时区） date &quot;+%Y-%m-%d %H:%M:%S %u %Z&quot; # 输出：2017-04-05 12:12:15 3 CST # 设置 系统时间（年、月、日） date -s &quot;2017-04-05&quot; # 设置 系统时间（小时、分钟、秒钟） date -s &quot;10:29:05&quot; # 设置 系统时间（年、月、日、小时、分钟、秒钟） date -s &quot;2017-04-05 10:29:05&quot; # 更多的命令可以用 date --help 来查看。 再教你们一个修改时区为上海（北京）时区的方法： cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime然后再用 date 查看时间，就会发现时区变为 CST 了。 chmod 修改 文件/文件夹 权限点击展开 查看 chmod命令说明 参数介绍： -c :只输出被改变权限的文件信息 -f :当chmod不能改变文件模式时，不通知文件的用户 -R :可递归遍历子目录，把修改应到目录下所有文件和子目录 -v :无论修改是否成功，输出每个文件的信息 # 操作符号： + :添加某个权限。 - :取消某个权限。 = :赋予给定权限并取消其他所有权限（如果有的话）。 # 权限设置字母： r :可读 w :可写 x :可执行 X :只有目标文件对某些用户是可执行的或该目标文件是目录时才追加x 属性 s :在文件执行时把进程的属主或组ID置为该文件的文件属主。方式“u＋s”设置文件的用户ID位，“g＋s”设置组ID位 t :保存程序的文本到交换设备上 u :当前用户的权限 g :当前用户同组的权限 o :其他用户的权限 # 权限设定数字： # 数字表示的属性含义： 0 ：表示没有权限 1 ：表示可执行权限 2 ：表示可写权限 4 ：表示可读权限 # 然后将其相加，所以数字属性的格式应为3个从0到7的八进制数，其顺序是（u）（g）（o）。 # 如果想让某个文件的属主有“读/写”二种权限，需要把4（可读）+2（可写）＝6（读/写）。 # 更多的命令可以用 chmod --help 来查看。 使用示例： # 当需要运行 可执行的脚本或者程序（比如 Go语言编写的软件）的时候，需要赋予执行权限 chmod +x ssr.sh # 赋予 log.txt 文件可读权限 chmod 444 log.txt # 赋予 /ver/log 文件夹 可读、可写权限 chmod 666 log.txt # 赋予 /home/www 文件夹 可读、可写、可执行权限 chmod 777 log.txt # 赋予 /home/www 文件夹极其所有子目录和文件 可读、可写、可执行权限 chmod -R 777 log.txt # 更多的命令可以用 chmod --help 来查看。 uname 获取操作系统信息 查看 uname命令说明 使用示例： root@doub.date:~# uname #在使用 uname 的时候，相当于是使用 uname -s Linux root@doub.date:~# uname -a Linux doub.date 2.6.32-042stab120.6 #1 SMP Thu Oct 27 16:59:03 MSK 2016 i686 GNU/Linux root@doub.date:~# uname -m #输出一般是64位: x86_64 / 32位: i386 或分支 i686 i686 root@doub.date:~# uname -n doub.date root@doub.date:~# uname -r 2.6.32-042stab120.6 root@doub.date:~# uname -s Linux root@doub.date:~# uname -v #1 SMP Thu Oct 27 16:59:03 MSK 2016 root@doub.date:~# uname -p unknown root@doub.date:~# uname -i unknown root@doub.date:~# uname -o GNU/Linux 我暂时总结到这里，我以后用到还会继续慢慢添加的，","categories":[],"tags":[]},{"title":"vue轮播插件的快速使用","slug":"VUE轮播图快速构建方法","date":"2018-04-30T02:56:00.000Z","updated":"2018-12-12T04:36:13.346Z","comments":true,"path":"2018/04/30/VUE轮播图快速构建方法/","link":"","permalink":"http://suijiafeng.com/2018/04/30/VUE轮播图快速构建方法/","excerpt":"","text":"Vue-Awesome-Swiper 基于 Swiper4、适用于 Vue 的轮播组件，支持服务端渲染和单页应用。 如果需要回退到 Swiper3，请使用 v2.6.7 版本跟着下面的步骤，一起构建一个轮播图组件吧。 1、使用NPM下载依赖包 npm install vue-awesome-swiper --save 2、全局注册 import Vue from &apos;vue&apos; import VueAwesomeSwiper from &apos;vue-awesome-swiper&apos; // require styles import &apos;swiper/dist/css/swiper.css&apos; Vue.use(VueAwesomeSwiper, /* { default global options } */) 3、复制插件的通用模板 &lt;!-- The ref attr used to find the swiper instance --&gt; &lt;template&gt; &lt;swiper :options=&quot;swiperOption&quot; ref=&quot;mySwiper&quot; @someSwiperEvent=&quot;callback&quot;&gt; &lt;!-- slides --&gt; &lt;swiper-slide&gt;I&apos;m Slide 1&lt;/swiper-slide&gt; &lt;swiper-slide&gt;I&apos;m Slide 2&lt;/swiper-slide&gt; &lt;swiper-slide&gt;I&apos;m Slide 3&lt;/swiper-slide&gt; &lt;swiper-slide&gt;I&apos;m Slide 4&lt;/swiper-slide&gt; &lt;swiper-slide&gt;I&apos;m Slide 5&lt;/swiper-slide&gt; &lt;swiper-slide&gt;I&apos;m Slide 6&lt;/swiper-slide&gt; &lt;swiper-slide&gt;I&apos;m Slide 7&lt;/swiper-slide&gt; &lt;!-- Optional controls --&gt; &lt;div class=&quot;swiper-pagination&quot; slot=&quot;pagination&quot;&gt;&lt;/div&gt; &lt;div class=&quot;swiper-button-prev&quot; slot=&quot;button-prev&quot;&gt;&lt;/div&gt; &lt;div class=&quot;swiper-button-next&quot; slot=&quot;button-next&quot;&gt;&lt;/div&gt; &lt;div class=&quot;swiper-scrollbar&quot; slot=&quot;scrollbar&quot;&gt;&lt;/div&gt; &lt;/swiper&gt; &lt;/template&gt; &lt;script&gt; export default { name: &apos;carrousel&apos;, data() { return { swiperOption: { loop:true, pagination:{ el:&quot;.swiper-pagination&quot;, clickable:true } // some swiper options/callbacks // 所有的参数同 swiper 官方 api 参数 // ... } } }, computed: { swiper() { return this.$refs.mySwiper.swiper } }, mounted() { // current swiper instance // 然后你就可以使用当前上下文内的swiper对象去做你想做的事了 console.log(&apos;this is current swiper instance object&apos;, this.swiper) this.swiper.slideTo(3, 1000, false) } } &lt;/script&gt; 4、根据实际需要，设置轮播图参数，例如，自动轮播，分页器，左右切换控制箭头，滚动速度等；相关配置详情请上 swiper官网","categories":[],"tags":[]},{"title":"vue中使用sass的配置的方法","slug":"vue中使用sass的配置的方法","date":"2018-03-01T16:56:00.000Z","updated":"2018-12-12T04:36:13.346Z","comments":true,"path":"2018/03/02/vue中使用sass的配置的方法/","link":"","permalink":"http://suijiafeng.com/2018/03/02/vue中使用sass的配置的方法/","excerpt":"","text":"1、创建一个基于 webpack 模板的新项目 $ vue init webpack myvue 2、在当前目录下，安装依赖 $ cd myvue $ npm install 3、安装sass的依赖包 npm install --save-dev sass-loader //sass-loader依赖于node-sass npm install --save-dev node-sass 4、在build文件夹下的webpack.base.conf.js的rules里面添加配置 { test: /\\.sass$/, loaders: [&apos;style&apos;, &apos;css&apos;, &apos;sass&apos;] } 5、在APP.vue中修改style标签 &lt;style lang=&quot;scss&quot;&gt;","categories":[],"tags":[]},{"title":"关于Ajax","slug":"关于Ajax","date":"2017-11-21T17:14:00.000Z","updated":"2018-12-12T04:36:13.346Z","comments":true,"path":"2017/11/22/关于Ajax/","link":"","permalink":"http://suijiafeng.com/2017/11/22/关于Ajax/","excerpt":"","text":"Ajax AJAX是异步的JavaScript和XML（Asynchronous JavaScript And XML）。简单点说，就是使用 XMLHttpRequest 对象与服务器通信。 它可以使用JSON，XML，HTML和文本等多种格式发送和接收。AJAX最吸引人的就是它的“异步”特性，也就是说他可以在不重新刷新页面的情况下与服务器通信，交换数据，更新页面。 你可以使用AJAX最主要的两个特性做下列事： 在不重新加载页面的情况下发送请求给服务器。接受并使用从服务器发来的数据。 工作原理Ajax的工作原理相当于在用户和服务器之间加了—个中间层,使用户操作与服务器响应异步化。并不是所有的用户请求都提交给服务器,像—些数据验证和数据处理等都交给Ajax引擎自己来做, 只有确定需要从服务器读取新数据时再由Ajax引擎代为向服务器提交请求。 发送Http请求 为了使用JavaScript向服务器发送一个http请求，你需要一个包含必要函数功能的对象实例。这就是为什么会有 XMLHttpRequest 的原因。 这是IE浏览器的ActiveX对象 XMLHTTP的前身。 随后Mozilla，Safari和其他浏览器也都实现了类似的方法，被称为 XMLHttpRequest 。同时，微软也实现了XMLHttpRequest方法。 // Old compatibility code, no longer needed. if (window.XMLHttpRequest) { // Mozilla, Safari, IE7+ ... httpRequest = new XMLHttpRequest(); } else if (window.ActiveXObject) { // IE 6 and older httpRequest = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); Note: 上面代码只是简单版的如何创建一个XMLHttp实例。更实际的例子，请看本篇文章下方简单例子。 发送一个请求后，你会收到响应。在这一阶段，你要告诉XMLHttp请求对象是由哪一个JavaScript函数处理响应，在设置了对象的 onreadystatechange属性后给他命名，当请求状态改变时调用函数。 httpRequest.onreadystatechange = nameOfTheFunction; 要注意的是，函数名后没有参数，因为你把一个引用赋值给了函数，而不是真正的调用了它。 此外，如果不使用函数名的方式，你还可以用JavaScript的匿名函数响应处理的动作，就像下面这样： httpRequest.onreadystatechange = function(){ // Process the server response here. }; 接下来，声明当你接到响应后要做什么，你要发送一个实际的请求，通过调用HTTP请求对象的 open() 和 send() 方法，像下面这样: httpRequest.open(&apos;GET&apos;, &apos;http://www.example.org/some.file&apos;, true); httpRequest.send(); open()的第一个参数是HTTP请求方法 - 有GET，POST，HEAD以及服务器支持的其他方法。 保证这些方法一定要是大写字母，否则其他一些浏览器（比如FireFox）可能无法处理这个请求。更多关于HTTP的请求方法，可以查看 W3C 文档哈。第二个参数是你要发送的URL。由于安全原因，默认不能调用第三方URL域名。 确保你在页面中使用的是正确的域名，否则在调用 open() 方法是会有 “权限被拒绝” 错误提示。如果你真的需要向另一个域名发送请求, 可以查看 HTTP access control，跨域问题将在后期文章发布。第三个参数是可选的，用于设置请求是否是异步的。如果设为 true (默认设置)，JavaScript执行会持续，并且在服务器还没有响应的情况下与页面进行交互。send() 方法的参数可以是任何你想发送给服务器的内容，如果是 POST 请求的话。发送表单数据时应该用服务器可以解析的格式，像查询语句： &quot;name=value&amp;anothername=&quot;+encodeURIComponent(myVar)+&quot;&amp;so=on&quot; 或者其他格式, 类似 multipart/form-data，JSON，XML等。 如果你使用 POST 数据，那就需要设置请求的MIME类型。比如，在调用 send() 方法获取表单数据前要有下面这个： httpRequest.setRequestHeader(&apos;Content-Type&apos;,&apos;application/x-www-form-urlencoded&apos;); 处理服务器响应 在发送请求时，你提供的JavaScript函数名负责处理响应： httpRequest.onreadystatechange = nameOfTheFunction; 这个函数应该做什么？首先，函数要检查请求的状态。如果状态的值是 XMLHttpRequest.DONE （对应的值是4），意味着服务器响应收到了并且是没问题的，然后就可以继续执行。 if (httpRequest.readyState === XMLHttpRequest.DONE) { // Everything is good, the response was received. } else { // Not ready yet. } 全部readyState状态值可以查看书籍或者文档，如下也是： 0 (未初始化) or (请求还未初始化)1 (正在加载) or (已建立服务器链接)2 (加载成功) or (请求已接受)3 (交互) or (正在处理请求)4 (完成) or (请求已完成并且响应已准备好) 接下来，判断HTTP响应的 response code。 更多响应码可以查看W3C文档。在下面的例子中，我们通过检查响应码 200 OK 区别对待成功和不成功的AJAX调用。 if (httpRequest.status === 200) { // Perfect! } else { // There was a problem with the request. // For example, the response may have a 404 (Not Found) // or 500 (Internal Server Error) response code. } 在检查完请求状态和HTTP响应码后， 你就可以用服务器返回的数据做任何你想做的了。你有两个方法去访问这些数据： httpRequest.responseText –服务器以文本字符的形式返回 httpRequest.responseXML – 以 XMLDocument 对象方式返回，之后就可以使用JavaScript来处理 注意上面这一步只在你发起异步请求时有效（既 open() 的第三个参数未特别指定或设为 true）。如果你你发起的是同步请求则不必使用函数，但是非常不推荐这样子做，它的用户体验很不好。 简单的例子 让我们把所有的知识都集中起来做一个简单的HTTP请求。这个JavaScript会请求一个HTML文档 test.html，包含 “I’m a test” 内容。然后我们 alert() 响应的内容。注意这个例子我们只是用了JavaScript，没有用jQuery。而且，HTML，XML和PHP文件都要放在用一个目录下。 &lt;button id=&quot;ajaxButton&quot; type=&quot;button&quot;&gt;Make a request&lt;/button&gt; &lt;script&gt; (function() { var httpRequest; document.getElementById(&quot;ajaxButton&quot;).addEventListener(&apos;click&apos;, makeRequest); function makeRequest() { httpRequest = new XMLHttpRequest(); if (!httpRequest) { alert(&apos;Giving up :( Cannot create an XMLHTTP instance&apos;); return false; } httpRequest.onreadystatechange = alertContents; httpRequest.open(&apos;GET&apos;, &apos;test.html&apos;); httpRequest.send(); } function alertContents() { if (httpRequest.readyState === XMLHttpRequest.DONE) { if (httpRequest.status === 200) { alert(httpRequest.responseText); } else { alert(&apos;There was a problem with the request.&apos;); } } }})(); &lt;/script&gt; 在这个例子中： 用户点击 “Make a request” 按钮；事件处理调用 makeRequest() 函数；请求已通过然后（onreadystatechange）传给 alertContents() 执行。alertContents() 检查返回的响应是否OK，然后 alert() test.html 文件内容。 Note: 如果你向一个代码片段发送请求，将返回XML，而不是静态XML文件，在IE浏览器上则必须要设置响应头才能正常工作。如果不设置响应头为 Content-Type:application/xml ，IE浏览器会在你访问XML元素时抛出 “Object Expected” 错误。Note 2: 如果不设置响应头 Cache-Control: no-cache 浏览器将会把响应缓存下来而且再也不无法重新提交请求。你也可以添加一个总是不同的 GET 参数，比如时间戳或者随机数 。 在通信错误的事件中（例如服务器宕机），在访问响应状态 onreadystatechange 方法中会抛出一个例外。为了缓和这种情况，则可以使用 try…catch 把 if…then 语句包裹起来。 function alertContents() { try { if (httpRequest.readyState === XMLHttpRequest.DONE) { if (httpRequest.status === 200) { alert(httpRequest.responseText); } else { alert(&apos;There was a problem with the request.&apos;); } } } catch( e ) { alert(&apos;Caught Exception: &apos; + e.description); } } 处理XML相应 在上一个例子中，在收到HTTP请求的响应后我们会请求对象的 responseText 属性，包含 test.html 文件的内容。现在我们试试 responseXML属性。 首先，我们创建一个稍后将要请求的有效的 XML 文档。文档（test.html）包含以下内容： &lt;?xml version=&quot;1.0&quot; ?&gt;&lt;root&gt; I&apos;m a test.&lt;/root&gt; 在脚本里我们只需要把请求行改为： ... onclick=&quot;makeRequest(&apos;test.xml&apos;)&quot;&gt; ... 然后在 alertContents() 里，我们把 alert(httpRequest.responseText) 改为： pRequest.responseXML; var root_node = xmldoc.getElementsByTagName(&apos;root&apos;).item(0); alert(root_node.firstChild.data); 这部分代码采用 responseXML 提供的 XMLDocument 对象，并使用 DOM 方法访问 XML 文档中包含的一些数据。你可以在这里查看 test.xml 并且在这里更新测试代码。 处理数据 最后，我们发送一个数据给服务器并收到响应。这次我们用 JavaScript 请求动态页面，test.php 并返回一个计算后的字符串 - “Hello, [user date]”，并用 alert() 出来。 首先要添加一个文本到 HTML 中以方便用户输入名字： &lt;label&gt; Your name: &lt;input type=&quot;text&quot; id=&quot;ajaxTextbox&quot; /&gt; &lt;/label&gt; &lt;span id=&quot;ajaxButton&quot; style=&quot;cursor: pointer; text-decoration: underline&quot;&gt; Make a request &lt;/span&gt; 还要添加事件处理程序，从表单中获取用户数据连同服务器端的UTL一并发送给 makeRequest() 函数： document.getElementById(&quot;ajaxButton&quot;).onclick = function() { var userName = document.getElementById(&quot;ajaxTextbox&quot;).value; makeRequest(&apos;test.php&apos;,userName); }; 我们还要修改 makeRequest() 让它接受用户数据并将其发给服务器。把请求方法从 GET 改为 POST，把数据作为参数让httpRequest.send() 调用。 uest(url, userName) { ... httpRequest.onreadystatechange = alertContents; httpRequest.open(&apos;POST&apos;, url); httpRequest.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded&apos;); httpRequest.send(&apos;userName=&apos; + encodeURIComponent(userName)); } 如果这就是服务器返回的全部内容，alertContents() 函数可以使用 简单例子 中的相同函数写。可是，服务器会返回计算后的内容和原内容。所以，如果用户输入 “Jane” 在输入框中，那服务器就会返回如下内容： {&quot;userData&quot;:&quot;Jane&quot;,&quot;computedString&quot;:&quot;Hi, Jane!&quot;} 为了在 alertContents() 中使用这个数据，我们可不能只是alert responseText ，我们要解析它并 alertconputedString，我们想要的属性： function alertContents() { if (httpRequest.readyState === XMLHttpRequest.DONE) { if (httpRequest.status === 200) { var response = JSON.parse(httpRequest.responseText); alert(response.computedString); } else { alert(&apos;There was a problem with the request.&apos;); } } } test.php 文件应该包含一下内容： $name = (isset($_POST[&apos;userName&apos;])) ? $_POST[&apos;userName&apos;] : &apos;no name&apos;; $computedString = &quot;Hi, &quot; . $name; $array = [&apos;userName&apos; =&gt; $name, &apos;computedString&apos; =&gt; $computedString]; echo json_encode($array); 优点 优秀的用户体验减轻服务器和带宽的负担，节约空间和宽带租用成本。提高Web程序的性能基于标准化的并被广泛支持的技术，不需要下载插件或者小程序。 缺点 破坏浏览器前进，后退按钮的正常 开发和调试工具缺乏。 对搜索引擎的支持比较弱。 破坏了程序的异常机制。 违背了url和资源定位的初衷。采用了ajax技术，真正url地址下面看到的和我在这个url地址下看到的内容是不同的 一些手持设备（如手机、PDA等）现在还不能很好的支持ajax。 浏览器对XMLHttpRequest对象的支持度不足","categories":[],"tags":[]},{"title":"CSS 的 BEM 书写规范 ","slug":"CSS 的 BEM 书写规范","date":"2017-10-07T08:02:00.000Z","updated":"2018-12-12T04:36:13.331Z","comments":true,"path":"2017/10/07/CSS 的 BEM 书写规范/","link":"","permalink":"http://suijiafeng.com/2017/10/07/CSS 的 BEM 书写规范/","excerpt":"","text":"使用 BEM 命名规范，理论上讲，每行 css 代码都只有一个选择器。 BEM代表“块（block）,元素（element）,修饰符（modifier）”,我们常用这三个实体开发组件。 在选择器中，由以下三种符合来表示扩展的关系： - 中划线 ：仅作为连字符使用，表示某个块或者某个子元素的多单词之间的连接记号。 __ 双下划线：双下划线用来连接块和块的子元素 _ 单下划线：单下划线用来描述一个块或者块的子元素的一种状态 type-block__element_modifier 块（block）一个块是设计或布局的一部分，它有具体且唯一地意义 ，要么是语义上的要么是视觉上的。 在大多数情况下，任何独立的页面元素（或复杂或简单）都可以被视作一个块。它的HTML容器会有一个唯一的CSS类名，也就是这个块的名字。 针对块的CSS类名会加一些前缀（ ui-），这些前缀在CSS中有类似 命名空间 的作用。 一个块的正式（实际上是半正式的）定义有下面三个基本原则： CSS中只能使用类名（不能是ID）。每一个块名应该有一个命名空间（前缀）每一条CSS规则必须属于一个块。例如：一个自定义列表 .list 是一个块，通常自定义列表是算在 mod 类别的，在这种情况下，一个 list 列表的block写法应该为: .list 元素（element）块中的子元素是块的子元素，并且子元素的子元素在 bem 里也被认为是块的直接子元素。一个块中元素的类名必须用父级块的名称作为前缀。 如上面的例子，li.item 是列表的一个子元素， .list{}.list .item{} .list{}.list__item{} 修饰符（modifier）一个“修饰符”可以理解为一个块的特定状态，标识着它持有一个特定的属性。 用一个例子来解释最好不过了。一个表示按钮的块默认有三个大小：小，中，大。为了避免创建三个不同的块，最好是在块上加修饰符。这个修饰符应该有个名字（比如：size ）和值（ small，normal 或者 big ）。 如上面的例子中，表示一个选中的列表，和一个激活的列表项 .list{} .list.select{} .list .item{} .list .item.active{} .list{} .list_select{} .list__item{} .list__item_active{} LESS 书写规范使用 .less 后缀的文件来存储变量、混合代码以及最终合并压缩。 子less 注解lib-base.less 预定义的变量，例如颜色、字号、字体lib-mixins.less 用于混合的代码，例如渐变、半透明的混合lib-reset.less 初始化lib-ui.less 颗粒化ui功能xxx.less 模块样式.less 文件的引用顺序会对最终编译的样式的作用域和优先级产生影响，请尽量按照由底层到自定义的顺序来引用。 关于风格书写原则 原则上不会出现2层以上选择器嵌套使用BEM原则，用命名来解耦，所有类名都为一层，增加效率和复用性 两层选择器嵌套出现在.mod-xxx__item_current子元素的情况，如下：使用推荐的嵌套写法 常规写法： .xxx{} .xxx__item{} .xxx__item_current{} // 嵌套写法 .xxx__item_current .mod-xxx__link{} 推荐： .xxx{} .xxx__item{} .xxx__item_hightlight{} .xxx__product-name{} .xxx__link{} .xxx__ming-zi-ke-yi-hen-chang{} // 嵌套写法 .xxx__item_current{ .xxx__link{} } 对应的HTML结构如下： &lt;ul class=&quot;xxx&quot;&gt; &lt;li class=&quot;xxx__item&quot;&gt;第一项 &lt;div class=&quot;xxx__product-name&quot;&gt;我是名称&lt;/div&gt; &lt;span class=&quot;xxx__ming-zi-ke-yi-hen-chang&quot;&gt;看类名&lt;/span&gt; &lt;a href=&quot;#&quot; class=&quot;xxx__link&quot;&gt;我是link&lt;/a&gt; &lt;li&gt; &lt;li class=&quot;xxx__item xxx__item_current&quot;&gt;第二项 且 当前选择项 &lt;div class=&quot;xxx__product-name&quot;&gt;我是名称&lt;/div&gt; &lt;a href=&quot;#&quot; class=&quot;xxx__item-link&quot;&gt;我是link&lt;/a&gt; &lt;li&gt; &lt;li class=&quot;xxx__item xxx__item_hightlight&quot;&gt;第三项 且 特殊高亮 &lt;div class=&quot;xxx__product-name&quot;&gt;我是名称&lt;/div&gt; &lt;a href=&quot;#&quot; class=&quot;xxx__item-link&quot;&gt;我是link&lt;/a&gt; &lt;li&gt; &lt;/ul&gt; BEM 解决问题组件之间的完全解耦，不会造成命名空间的污染，如：.mod-xxx ul li 的写法带来的潜在的嵌套风险。 性能BEM 命名会使得 Class 类名变长，但经过 gzip 压缩后这个带宽开销可以忽略不计","categories":[],"tags":[]},{"title":"35个Jquery小技巧","slug":"35个Jquery小技巧","date":"2017-08-03T17:07:00.000Z","updated":"2018-12-12T04:36:13.331Z","comments":true,"path":"2017/08/04/35个Jquery小技巧/","link":"","permalink":"http://suijiafeng.com/2017/08/04/35个Jquery小技巧/","excerpt":"","text":"1.禁止右键点击$(document).ready(function(){ $(document).bind(“contextmenu”,function(e){ return false; });}); 2.隐藏搜索文本框文字$(document).ready(function() { $(&quot;input.text1&quot;).val(&quot;Enter your search text here&quot;); textFill($(&apos;input.text1&apos;)); }); function textFill(input){ //input focus text function var originalvalue = input.val(); input.focus( function(){ if( $.trim(input.val()) == originalvalue ){ input.val(&apos;&apos;); } }); input.blur( function(){ if( $.trim(input.val()) == &apos;&apos; ){ input.val(originalvalue); } }); } 3.在新窗口中打开链接XHTML 1.0 Strict doesn’t allow this attribute in the code, so use this to keep the code valid. $(document).ready(function() { //Example 1: Every link will open in a new window $(&apos;a[href^=&quot;http://&quot;]&apos;).attr(&quot;target&quot;, &quot;_blank&quot;); //Example 2: Links with the rel=&quot;external&quot; attribute will only open in a new window (&apos;a[@rel=&apos;external&apos;]&apos;).click(function(){ this.target = &quot;_blank&quot;; });});// how to useopen link 检测浏览器 注: 在版本jQuery 1.4中，$.support 替换掉了$.browser 变量 $(document).ready(function() {// Target Firefox 2 and aboveif ($.browser.mozilla &amp;&amp; $.browser.version &gt;= “1.8” ){ // do something} // Target Safariif( $.browser.safari ){ // do something} // Target Chromeif( $.browser.chrome){ // do something} // Target Caminoif( $.browser.camino){ // do something} // Target Operaif( $.browser.opera){ // do something} // Target IE6 and belowif ($.browser.msie &amp;&amp; $.browser.version &lt;= 6 ){ // do something} // Target anything above IE6if ($.browser.msie &amp;&amp; $.browser.version &gt; 6){ // do something}}); 预加载图片 This piece of code will prevent the loading of all images, which can be useful if you have a site with lots of images. $(document).ready(function() {jQuery.preloadImages = function(){ for(var i = 0; i","categories":[],"tags":[]},{"title":"正则表达式的类","slug":"JS的代码的引用规范","date":"2017-05-21T17:18:00.000Z","updated":"2018-12-12T04:36:13.346Z","comments":true,"path":"2017/05/22/JS的代码的引用规范/","link":"","permalink":"http://suijiafeng.com/2017/05/22/JS的代码的引用规范/","excerpt":"","text":"开篇,还是得说说 ^ 和 $ 他们是分别用来匹配字符串的开始和结束，以下分别举例说明： “^The”: 开头一定要有”The”字符串; “of despair$”: 结尾一定要有”of despair” 的字符串; 那么, “^abc$”: 就是要求以abc开头和以abc结尾的字符串，实际上是只有abc匹配。 “notice”: 匹配包含notice的字符串。 你可以看见如果你没有用我们提到的两个字符(最后一个例子)，就是说 模式(正则表达式) 可以出现在被检验字符串的任何地方，你没有把他锁定到两边。 接着,说说 ‘*’, ‘+’,和 ‘?’, 他们用来表示一个字符可以出现的次数或者顺序. 他们分别表示： “zero or more”相当于{0,}, “one or more”相当于{1,}, “zero or one.”相当于{0,1}, 这里是一些例子: “ab“: 和ab{0,}同义,匹配以a开头,后面可以接0个或者N个b组成的字符串(“a”, “ab”, “abbb”, 等); “ab+”: 和ab{1,}同义,同上条一样，但最少要有一个b存在 (“ab”, “abbb”, 等.); “ab?”:和ab{0,1}同义,可以没有或者只有一个b; “a?b+$”: 匹配以一个或者0个a再加上一个以上的b结尾的字符串. 要点, ‘‘, ‘+’,和 ‘?’只管它前面那个字符. 你也可以在大括号里面限制字符出现的个数，比如 “ab{2}”: 要求a后面一定要跟两个b(一个也不能少)(“abb”); “ab{2,}”: 要求a后面一定要有两个或者两个以上b(如”abb”, “abbbb”, 等.); “ab{3,5}”: 要求a后面可以有2-5个b(“abbb”, “abbbb”, or “abbbbb”). 现在我们把一定几个字符放到小括号里，比如： “a(bc)*”: 匹配 a 后面跟0个或者一个”bc”; “a(bc){1,5}”: 一个到5个 “bc.” 还有一个字符 ‘│’, 相当于OR 操作: “hi│hello”: 匹配含有”hi” 或者 “hello” 的 字符串; “(b│cd)ef”: 匹配含有 “bef” 或者 “cdef”的字符串; “(a│b)*c”: 匹配含有这样多个(包括0个)a或b，后面跟一个c的字符串; 一个点(‘.’)可以代表所有的单一字符,不包括”\\n” 如果,要匹配包括”\\n”在内的所有单个字符,怎么办? 对了,用’[\\n.]’这种模式. “a.[0-9]”: 一个a加一个字符再加一个0到9的数字 “^.{3}$”: 三个任意字符结尾 . 中括号括住的内容只匹配一个单一的字符 “[ab]”: 匹配单个的 a 或者 b ( 和 “a│b” 一样); “[a-d]”: 匹配’a’ 到’d’的单个字符 (和”a│b│c│d” 还有 “[abcd]”效果一样); 一般我们都用[a-zA-Z]来指定字符为一个大小写英文 “^[a-zA-Z]”: 匹配以大小写字母开头的字符串 “[0-9]%”: 匹配含有 形如 x% 的字符串 “,[a-zA-Z0-9]$”: 匹配以逗号再加一个数字或字母结尾的字符串 你也可以把你不想要得字符列在中括号里，你只需要在总括号里面使用’^’ 作为开头 “%[^a-zA-Z]%” 匹配含有两个百分号里面有一个非字母的字符串. 要点:^用在中括号开头的时候,就表示排除括号里的字符。为了PHP能够解释，你必须在这些字符面前后加’’,并且将一些字符转义. 不要忘记在中括号里面的字符是这条规路的例外?在中括号里面, 所有的特殊字符，包括(‘’), 都将失去他们的特殊性质 “[*+?{}.]”匹配含有这些字符的字符串. 还有,正如regx的手册告诉我们: “如果列表里含有 ‘]’, 最好把它作为列表里的第一个字符(可能跟在’^’后面). 如果含有’-‘, 最好把它放在最前面或者最后面, or 或者一个范围的第二个结束点[a-d-0-9]中间的‘-’将有效. 看了上面的例子,你对{n,m}应该理解了吧.要注意的是,n和m都不能为负整数,而且n总是小于m. 这样,才能 最少匹配n次且最多匹配m次. 如”p{1,5}”将匹配 “pvpppppp”中的前五个p. 下面说说以\\开头的 \\b 书上说他是用来匹配一个单词边界,就是…比如’ve\\b’,可以匹配love里的ve而不匹配very里有ve \\B 正好和上面的\\b相反.例子我就不举了 …..突然想起来….可以到http://www.phpv.net/article.php/251 看看其它用\\ 开头的语法 好,我们来做个应用: 如何构建一个模式来匹配 货币数量 的输入 构建一个匹配模式去检查输入的信息是否为一个表示money的数字。我们认为一个表示money的数量有四种方式： “10000.00” 和 “10,000.00”,或者没有小数部分, “10000” and “10,000”. 现在让我们开始构建这个匹配模式: ^[1-9][0-9]*$ 这是所变量必须以非0的数字开头.但这也意味着 单一的 “0” 也不能通过测试. 以下是解决的方法:^(0│[1-9][0-9]*)$ “只有0和不以0开头的数字与之匹配”，我们也可以允许一个负号在数字之前: ^(0│-?[1-9][0-9]*)$ 这就是: “0 或者 一个以0开头 且可能 有一个负号在前面的数字.” 好了,现在让我们别那么严谨，允许以0开头.现在让我们放弃 负号 , 因为我们在表示钱币的时候并不需要用到. 我们现在指定 模式 用来匹配小数部分: ^[0-9]+(.[0-9]+)?$ 这暗示匹配的字符串必须最少以一个阿拉伯数字开头. 但是注意，在上面模式中 “10.” 是不匹配的, 只有 “10” 和 “10.2” 才可以. (你知道为什么吗) ^[0-9]+(.[0-9]{2})?$ 我们上面指定小数点后面必须有两位小数.如果你认为这样太苛刻,你可以改成: ^[0-9]+(.[0-9]{1,2})?$ 这将允许小数点后面有一到两个字符. 现在我们加上用来增加可读性的逗号(每隔三位), 我们可以这样表示: ^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 不要忘记 ‘+’ 可以被 ‘*’ 替代 如果你想允许空白字符串被输入话 (为什么?). 也不要忘记反斜杆 ’\\’ 在php字符串中可能会出现错误 (很普遍的错误). 现在，我们已经可以确认字符串了, 我们现在把所有逗号都去掉 str_replace(“,”, “”, $money) 然后在把类型看成 double然后我们就可以通过他做数学计算了. 再来一个: 构造检查email的正则表达式 在一个完整的email地址中有三个部分: 1. 用户名 (在 ‘@’ 左边的一切), 2.’@’, 3. 服务器名(就是剩下那部分). 用户名可以含有大小写字母阿拉伯数字,句号 (‘.’), 减号(‘-‘), and 下划线 (‘_’). 服务器名字也是符合这个规则,当然下划线除外. 现在, 用户名的开始和结束都不能是句点. 服务器也是这样. 还有你不能有两个连续的句点他们之间至少存在一个字符，好现在我们来看一下怎么为用户名写一个匹配模式: ^[_a-zA-Z0-9-]+$ 现在还不能允许句号的存在. 我们把它加上: ^[_a-zA-Z0-9-]+(.[_a-zA-Z0-9-]+)*$ 上面的意思就是说: “以至少一个规范字符(除了.)开头,后面跟着0个或者多个以点开始的字符串.” 简单化一点, 我们可以用 eregi()取代 ereg().eregi()对大小写不敏感, 我们就不需要指定两个范围 “a-z” 和 “A-Z” ? 只需要指定一个就可以了: ^[_a-z0-9-]+(.[_a-z0-9-]+)*$ 后面的服务器名字也是一样,但要去掉下划线: ^[a-z0-9-]+(.[a-z0-9-]+)*$ 好. 现在只需要用”@”把两部分连接: ^[_a-z0-9-]+(.[_a-z0-9-]+)@[a-z0-9-]+(.[a-z0-9-]+)$ 这就是完整的email认证匹配模式了,只需要调用 eregi(‘^[_a-z0-9-]+(.[_a-z0-9-]+)@[a-z0-9-]+(.[a-z0-9-]+)$ ’,$eamil) 就可以得到是否为email了. 正则表达式的其他用法 提取字符串 ereg() and eregi() 有一个特性是允许用户通过正则表达式去提取字符串的一部分(具体用法你可以阅读手册). 比如说,我们想从 path/URL 提取文件名 ? 下面的代码就是你需要: ereg(“([^\\/]*)$”, $pathOrUrl, $regs); echo $regs[1]; 高级的代换 ereg_replace() 和 eregi_replace()也是非常有用的: 假如我们想把所有的间隔负号都替换成逗号: ereg_replace(“[ \\n\\r\\t]+”, “,”, trim($str)); 最后,我把另一串检查EMAIL的正则表达式让看文章的你来分析一下. “^[-!#$%&amp;\\’+\\./0-9=?A-Z^_`a-z{|}~]+’.’@’.’[-!#$%&amp;\\’+\\/0-9=?A-Z^`a-z{|}~]+.‘.’[-!#$%&amp;\\’*+\\./0-9=?A-Z^`a-z{|}~]+$”","categories":[],"tags":[]},{"title":"js的数据类型","slug":"js的数据类型","date":"2017-05-09T17:11:00.000Z","updated":"2018-12-12T04:36:13.346Z","comments":true,"path":"2017/05/10/js的数据类型/","link":"","permalink":"http://suijiafeng.com/2017/05/10/js的数据类型/","excerpt":"","text":"特点：弱类型特性。共有5种原始类型：number String boolean null undefined 1中Object 类型 隐士转换：+ - 巧用 + - 的转换逻辑123456789&quot;123&quot;==1230 ==falsenull ==undefined[1,2]==[1,2] 因为他们两个是不同的对象NaN 不等于NaN ​ 类型相同，同 === ​ 类型不同，尝试类型转换 包装对象object 对象 ：Function Data Array 当我们尝试把基本类型当成是对象来使用的时候 ​ js内部会帮我们包装成对象，当这个动作完成后，这个对象也就被销毁了 12345678var a = &quot;string&quot;;undefineda.length6a.t=3;3a.t;//设置完 a.t 属性之后，临时被包装的对象也就被销毁了。undefined 类型检测 obj instanceof Object运行原理：判断左边obj 对象的原型链上是否有右边这个对象 Object 的protype 属性 类型检测： 表达式： 函数表达式 运算符： 1.三元运算符 2.逗号运算符 var val=(1,2,3);//3 3.delete 4 in 5 new 6 this 7 void 运算优先级 语句 语句种类 1浏览器把 &#123;a:1,b:2&#125;//当成了块，而不是对象字面量。 ## var 声明语句 var a; var a,b,c; try catch 1 首先执行try 中的代码，如果出现异常就由catch 捕获，但是不过有没有异常，最后都会执行finally 中的代码 2 注意点：try 后面一定要带一个catch 或finally ,或者两者皆带。 function for in switch ##循环 with可以修改当前的作用域 严格模式 严格模式下的特点：12SyntaxError :语法错误ReferenceError:引用错误 对象 对象结构 创建对象 创建对象的方式2-new 原型链–深入理解","categories":[],"tags":[]},{"title":"函数","slug":"函数","date":"2017-03-16T17:28:00.000Z","updated":"2018-12-12T04:36:13.362Z","comments":true,"path":"2017/03/17/函数/","link":"","permalink":"http://suijiafeng.com/2017/03/17/函数/","excerpt":"","text":"为什么要使用函数，使用函数的目的1 程序有的时候一段一样的代码会在不同的地方多次执行，如果我们使用复制粘贴的方法，当然也可行，但是会造成代码冗余的情况发生，可维护性也差，你想啊，我一个地方改了，其他地方也要改，不能起到牵一发而动全身的效果。代码的健壮性也不好。 什么时候使用函数1.有些代码在不同地方，需要执行，我们可以把这些代码封装成一个函数。 2.代码复用：如果一段代码是实现一个功能，我们就可以把一段代码封装成一个函数，哪里需要这个功能，就调用这个函数。 函数是一块JavaScript中的一段代码，被定义一次，但是可执行和调用多次。 JS中的函数也是对象，所以JS函数可以像其它对象那样操作和传递，所以我们也常把函数叫做函数对象。 函数名函数名最好为一个有意义的名词。 js中函数不能重名，如果重名的会话，后面的函数会把前面的函数给覆盖掉。 函数体只要是符合js语法规范的代码，就可以称之为函数体。 函数名和变量名重名的情况 如果变量有值，那么输出的就是标量的值 如果变量没有值，那么输出的就是函数的代码，注意是函数的代码，而不是输出的结果。 建议：变量量名最好为一个有意义的动词，函数名最好为一个有意义的名词。 函数的参数- 形参 定义函数的时候，在小括号里面写的，叫做函数的形式参数(形参); 形参本质上就是函数声明中的一个变量 - 实参 调用函数的时候，小括号里面的值，调用的时候，会把实参传递给形参。 函数参数的类型- 值类型 它里面存放的是一个值 - 引用类型 存放的是一个地址 arguments 是一个伪数组，里面存放的是实际是函数的参数。里面的元素和形参一一对应。 因为是个伪数组，所以没有数组里面的方法，可以使用下标索引 如果函数里面没有形参，函数调用的时候传递过来了实参，那么这个传递过来的值就存在arguments里面 重载 arguments 可以模拟重载。 好处：a 方便程序员记忆，b 可以根据参数个数的不同，执行不同的代码。 返回值- return语句，函数在执行完return语句后，就会停止执行并立即退出程序。 - 只能返回一个东西，如果想要返回多个东西的话，可以定一个个对象或者数组，以他们为载体返回。 - 函数有retrun 语句并且有表达式；返回的是表达式的值。 - 函数有return语句但是没有表达式；返回的是undefine。 - 函数没有return ；返回的是undefined。 函数–作用域 在js当中只有函数能够划分作用域。函数在js 中也是一等公民。 a 局部作用域：任何函数的内部我们称之为局部作用域。 b 全局作用域：script 标签内部我们称之为全局作用域。 作用域的访问规则： 就近原则：1 使用一个变量。 先去当前作用域去找，找到就使用，如果找不到就往父级找，父级没有？那再往上找，如果全局中也没有，那么报错。 2 修改一个变量的值 先去当前作用域找，如果有这个变量，那么把当前作用域中的变量的值给修改了；如果没有那么就往上找，如果都没有，那么它自己也就变成了一个全局变量。 预解析 在每个作用域里面的代码执行之前，都会把当前这个作用域里面函数声明、变量提升到当前这个作用域的最顶端，赋值语句保留在原地。 注意关键字：的那你去哪作用域 函数声明 变量 函数的声明方式： 函数声明语句的方式声明函数 函数表达式的方式声明函数两者的区别:a 表达式在预解析阶段函数会被前置，提升但当前作用域；意味着不能立即调用。b 表达式声明的函数，函数不会前置，意味着可以立即调用。 函数的调用 函数名代表的是整个函数，函数名加个小括号，表示的是函数的调用， 函数的检测 typeof 函数名 函数名 instanceof Function Object.prototype.toString.call(函数名) 函数的创建方法函数调用的方式 直接调用 作为方法调用 函数上下文调用 构造器 this在JavaScript中不同的函数调用方式this 的指向也是不同的 全局作用域下的 this指向全局对象，在浏览器中，这个全局对象指向的是windows 一般函数中的this,指向的是window 1234function f1()&#123; return this;&#125;f1()===window;//true 作为对象方法的函数中的this谁调用，this 指向谁。12345678910var o = &#123; x:1, y:function()&#123; return this.x; //分析：对于属性y 我们定义了一个函数，我们也把这种形式叫做对象的方法. //这里的this 指向的是对象 o // 因此return this.x 就相当于 return o.x; &#125;&#125;o.y(); //1 再举个例子1234567var o = &#123;prop:37&#125;;function independent()&#123; return this.prop;&#125;o.f = independent;console.log(o.f());//37//分析：这里的this为什么不是window呢？这是因为，在执行过程中，里面的this并不是看函数创建时候的this，而是看函数调用时候的,谁调用了我，我就指向谁。 对象原型链中的this 构造函数中的this call/apply方法与this bind 方法与this 字面量字面量表示如何表达这个值，一般除去表达式，给变量赋值时，等号右边都可以认为是字面量。 字面量分为字符串字面量(string literal )、数组字面量(array literal)和 对象字面量(object literal)，另外还有函数字面量(function literal)。 示例：var test=”hello world!”;“hello world!”就是字符串字面量，test是变量名。 匿名函数回调函数123456789101112131415function learn(something) &#123; console.log(something);&#125;function we(callback, something) &#123; something += &apos;is cool&apos;; callback(something);&#125;we(learn, &apos;Nodejs&apos;);//输出 Nodejs id cool//分析 我们传入进去的是一个具名函数we(function(something)&#123; console.log(something)&#125;,&apos;Nodejs&apos;);//输出 Nodejs id cool//分析 我们传入进去的是一个匿名函数 构造函数构造函数介绍： 构造函数也是一个函数，一般用来创建对象 构造函数的特征: 首字母大写 （不大写也没事，但是这是大家规范） 构造函数一般和new 关键字一起使用 不需要手动写返回值 构造函数执行的过程 1.1使用new关键字创建对象 1.2调用构造函数，将构造函数内的this 指向创建出来的对象 1.3 在构造函数内部，通过this给对象新增属性和方法（做初始化工作） 1.4 自动返回刚才new 创建出来的对象 注意：如果手动帮构造函数设置了返回语句呢？ a : 如果返回的是一个简单的数据类型 ，那么没有影响,返回的还是new创建出来的对象 b : 如果返回的是一个复杂的数据类型，则会把创建出来的那个对象给覆盖掉 。返回的是手工设置的数据类型 new关键字 ps: 任何函数，只要通过new关键操作符来调用，那它就可以作为构造函数；而任何函数，如果不通过构造函数来调用，那它跟普通函数也没什么两样。 如果像使用普通的函数一样去调用构造函数 a 函数中的this会指向window对象，通过this添加的所有的属性和方法，都会添加给window对象 b 函数中如果没有return语句，则返回undefined 例子：自定义一个构造函数 123456789function my(name,age,sex)&#123; this.name = name; this.age = age; this.sex = sex;&#125; 使用new关键字创建对象123var m1 = new My(&quot;张&quot;, 15,&quot;男&quot;);var m2 = new My(&quot;李&quot;, 1,&quot;女&quot;); 构造函数创建对象存在的问题如果将函数声明放在构造函数里，那么每次创建一个对象，都会拥有这个方法，所有对象的功能方法都一致；从而造成： 资源的一种浪费。功能相同的函数，完全没有必要再内存中存在这么多份。所以就造成了资源浪费。 代码冗余 1234567891011function Person(name, age)&#123; this.name = name; this.age = age; this.sayHi = function()&#123; console.log(&quot;你好&quot;); &#125;&#125;var p = new Person(&quot;张三&quot;, 18);var p1 = new Person(&quot;李四&quot;, 19);console.log(p.sayHi == p1.sayHi); //输出结果为false 构造函数创建对象存在的问题解决办法： 在外部创建一个函数，书写构造函数的时候直接引用，这样的话解决了上述问题，但是又带来了新的问题 1234567891011121314function sayHello()&#123; console.log(&quot;你好&quot;);&#125;function Person(name, age)&#123; this.name = name; this.age = age; this.sayHi = sayHello;&#125;//调用该构造函数创建对象，并对比创建出来的对象的sayHi方法var p = new Person(&quot;张三&quot;, 18);var p1 = new Person(&quot;李四&quot;, 19);console.log(p.sayHi == p1.sayHi); //输出结果为true 构造函数存在的问题解决办法–新的问题 全局变量增多，会增加引入框架命名冲突的风险 代码结构混乱，会变得难以维护 构造函数存在的问题解决办法 引入原型 函数(值类型的数据作为函数的参数)的调用过程12345678910111213function test1(num) &#123; num = 100; &#125; var num1 = 10; test1(num1); console.log(num); //is not defined console.log(num1); //10 //分析过程 1 num1 在内存中声明一个空间 赋值为 10 2 函数调用 函数有形参，会先声明，并把实参的值赋值给他，num=10 3 执行函数 num =100; 4 执行完之后空间回收，所以num已经不存在, 5 所以最后 num1 输出的值是 10 函数(引用类型的数据作为函数的参数)的调用过程123456789101112function test2(arr)&#123; arr[0] = 100; &#125; var arr1 = [10,20,30]; test2(arr1); console.log(arr1[0]); //100 //分析过程 1 在内存中申明一个空间，用来存放数组[10,20,30] 变量 arr1 存放的数组[10,20,30]的地址。 2 调用函数 test2 ,因为有形参，所以先声明形参。并把存放在arr1中的地址赋值一份给arr 3 修改数组arr[0]的值。 4 回收形参arr的空间 5 输出arr1[0]的值 总结引用类型作为函数的参数和值类型作为函数的参数. 引用类型因为指向的是同一个，所以你改一个，另外一个也就跟着改了。 . 值类型的话就不一样了。两者都是在不同的内存空间中，不会互相影响。 函数 高级部分静态成员由构造函数点出来的属性，我们叫做静态成员。12Math.random(); Math.abs(); 实例成员由实例化的对象点出来的属性，我们叫实例成员12345678function Person(name)&#123; this.name = name; &#125; Person.prototype.sayHi = function () &#123; console.log(&quot;哈哈哈哈....&quot;); &#125; Person.sayHi();//这里的sayHi是构造函数作为对象点出来的，所以这里的sayHi就是静态成员。 instancofeval函数可以把字符串当做代码执行，但是字符串要符合js代码规范12eval(&quot;var a = 10;&quot;);console.log(a);//10","categories":[],"tags":[]},{"title":"js的简单总结","slug":"js的简单总结","date":"2017-02-12T17:31:00.000Z","updated":"2018-12-12T04:36:13.346Z","comments":true,"path":"2017/02/13/js的简单总结/","link":"","permalink":"http://suijiafeng.com/2017/02/13/js的简单总结/","excerpt":"","text":"JS的数据类型 简单基本数据类型 :number boolean string 复杂数据类型: Array function Object Date RegExp Math String Number Boolean 空类型 : null undefined 基本包装类型 ：Number String Boolean 显式数据转换-Boolean|(需要转换的内容） a:可以转换成false的有： 0 -0 false undefined null NaN “”空字符串 Number()函数 可以用于任何数据类型 如果是Boolean 值，true和false将分别被转换为 1 和 0 如果是数值，只是简单的传入和返回。 如果是null ，返回的是 0 如果是undefiend 那么返回的是 NaN。 如果是字符串，那么遵从如下规则： 1.如果字符串本身的值是一个数字，就可以转换成数字。 2.如果就是一个字符串，那么转换成 NaN 3.如果字符串是一个空格字符串&quot; &quot;,或者是一个空字符串&quot;&quot;，转换成0。 4.如果字符串本身的值是一个数字，头尾有空格会忽略，会被转换成一个数字；但是如果 中间有空格，那么会转成 NaN. 比如说： var str = &quot; 3 2 &quot;; 5.如果字符串本身的值是一个小数，那么会转换成小数。 parseInt()函数 用于把字符串转换成数值 从左到右，找到是数字的部分，把他转换。如果字符串的值本身是一个小数，转换后得到的是他的整数部分。 parseFloat()函数 用于把字符串转换成数值如果字符串的值本身是一个小数，注意：转换后得到的就是这个小数本身。 如何保留小数的位数可以先放放大若干倍数，在做相对应的操作。 隐式转换 其他类型的转number —在需要转换的内容前面写一个正号 +，适用规则和Number()函数的转换规则一样。 其他类型转换string ：—-使用连接符+ 其他类型转布尔类型 ：—-使用取反运算符 –语法 !!需要转换的内容 valueof ()是拿到对象原始的值 toString()对象的 toString() —[object type] 数组的 toString() 转换为字符串类型 其它：如果一个复杂的数据类型和一个基本的数据类型进行运算，会调用这个对象的valueOf方法，取去他的原始值再和这个基本数据类型进行运算. console.log([] == ![]); //true console.log({} == !{}); //false 如果valueOf取不到一个值，就调用这个对象的toString方法，得到的值再和这个基本数据类型进行运算。 判断数据类型a typeof 能够判断基本数据类型(除了null，null会得到一个object)。 以及函数。 b instanceof 可以判断数据类型，不严谨 continue跳出本次循环 break直接跳出循环体 对象的动态特性 动态的给对象添加属性和方法 可以使用点语法 可以使用数组特性的方式 DOM元素操作 在地址栏上也是可以输入js代码的 ，同样也是可以执行的 谷歌浏览器输出结果看颜色判断是什么类型。 number:蓝色 string :黑色 navigator navigator .userAgent 查看浏览器信息 循环for() for(var key in obj) in 关键字的使用a 可以用来循环数组与对象 b 判断某个对象是否可以访问某个属性、方法 语法： “属性名” in 对象 c 判断数组中有没有这个下标 “下标” in 数组 值类型作为函数的参数执行过程分析： 举个例子： function test1(num){ num = 100; } var num1 = 10; test1(num1); console.log(num1); //10 1 先声明一个变量 var num1 =10; 2 函数如果有形参，会先声明形参。 3 把实参的值复制一份给形参。 4 执行函数体 引用类型作为函数的参数逻辑中断逻辑与 &amp; 找假： 如果参入逻辑运算的的第一个式子能够转换成布尔类型的false那么整个逻辑与表达式的结果就是第一个式子的值，如果第一个式子的值不能转换成布尔类型的false，那么整个逻辑与表达式的结果就是第二个式子的值。 逻辑或 || 找真 如果参入逻辑运算的的第一个式子能够转换成布尔类型的true那么整个逻辑与表达式的结果就是第一个式子的值，如果第一个式子的值不能转换成布尔类型的true，那么整个逻辑与表达式的结果就是第二个式子的值。 delete关键字的使用 删除那些没有用 var 关键字声明的变量 语法： delete 变量 删掉某个元素，后面的那些元素不会自动的往前移动 var arr = [10,20,30,40]; delete arr[0]; console.log(arr);//下标为0 的元素已经被删除，但是位置仍然保留。 移除对象的属性： 语法： delete 对象名.属性名 removeAttribute普通的对象没有removeAttribute()方法，只有dom对象才有这个方法。123//removeAttribute dom对象移除属性//obj.removeAttribute(&quot;age&quot;); //报错，普通的对象没有removeAttribute()方法，只有dom对象才有这个方法。//console.log(obj); 数组操作// arr.pop(); //删掉最后一个 // arr.push(); //往数组的最后一个添加元素 // arr.shift(); //删掉第一个 // arr.unshift(); //往数组的第一个添加元素 异常处理如果程序在某一个地方出了异常，那么这个地方后面的代码都不会执行。 //2.捕获异常，做处理 //语法： try { // 有可能会出现异常的代码 // }catch(e){ // 捕获到异常了之后要执行的处理-代码 // e就是异常信息 // }finally { // 不管有没有发生异常，都要执行的代码 // 释放资源的处理 // } //如果try里面的代码没有发生异常，就执行try里面的代码，不会执行catch里面的代码。 //如果try里面的代码发生了异常，就不执行try里面的代码，会执行catch里面的代码，e是异常信息。 //finally里面的代码不管有没有发生异常都要执行。 逻辑与表达式关键字：找假在一个逻辑与表达式中，如果第一个式子能够转换成false的话，那么第一个式子的值就是整个表达式的值。如果不是那么最后一个式子的值是整个表达式的值。 1234567891011var num1=10,num2=20;var res = num1&gt;0&amp;&amp;num2&gt;0;console.log(res);//truevar num3=10,num4=20;var res = num3&amp;&amp;num4;console.log(res);//20var num5=10,num6=20;var res = num5&lt;0&amp;&amp;num6;console.log(res);//false 逻辑或表达式关键字：找真在一个逻辑或表达式中，如果第一个式子能够转换成true的话，那么第一个式子的值就是整个表达式的值。12345var num1 = 10;var num2 = 20;var res = undefined || num2++;console.log(res); //20console.log(num2); //21 逻辑与 与 逻辑或的应用12345var value1 = document.getElementById(&quot;one&quot;) &amp;&amp; document.getElementById(&quot;one&quot;).value ;分析：如果不存在这个 one这个选择器 那么value1 =null ,如果存在，那么返回这个选择器相对应的值..好处，不至于报错。","categories":[],"tags":[]},{"title":"关于数组的简单总结","slug":"关于数组的简单方法","date":"2017-01-15T17:07:00.000Z","updated":"2018-12-12T04:36:13.346Z","comments":true,"path":"2017/01/16/关于数组的简单方法/","link":"","permalink":"http://suijiafeng.com/2017/01/16/关于数组的简单方法/","excerpt":"","text":"数组方法 数组方法千千万，我们还以在根据需要在它的原型上对它的方法进行扩展。 我们获取dom元素，返回来给我们的是一个伪数组，因为是个伪数组，所以他不能拥有数组的方法。 forEach数组名.forEach(function (参数1（数组中的每个元素），参数2（数组下标），参数3（数组本身） ){}); 数组名.forEach(function (参数1，参数2，参数3 ){}); mappopshiftunshiftpush","categories":[],"tags":[]},{"title":"JS对象的动态特性","slug":"JS-1","date":"2017-01-13T17:09:00.000Z","updated":"2018-12-12T04:36:13.346Z","comments":true,"path":"2017/01/14/JS-1/","link":"","permalink":"http://suijiafeng.com/2017/01/14/JS-1/","excerpt":"","text":"对象的动态特性可以动态地给对象添加属性和方法 添加方法 a 使用点语法 12345var obj =&#123; name :&apos;zs&apos;, age:18&#125;obj.name;// zs b 使用数组的特性 1234567891011121314151617181920212223 obj[&apos;name&apos;];/ zs obj[&#123;&#125;] =&quot;sdsfs&quot;; obj[&quot;[object Object]&quot;]; //why obj[] 里面需要的是一个字符串 //所以会di把调用tostring()方法 obj[&#123;&#125;] ==&gt;中的空对象 &#123; &#125;转换成 object Object 存放起来。## 序列化 var obj = &#123;x:1,y:true,z:[1,2,3],c：null&#125;; JSON.stringify(obj); var obj1 = &#123;val:undefined,a:NaN,b:Infinity,c:new Date()&#125;; JSON.stringify(obj1);#### 把字符串转成对象 var obj3 = JSON.parse(&apos;&#123;&quot;x&quot;:1&#125;&apos;); box3.x;//1#### 自定义 序列化 var obj ={ x:1, y:2, o:{ o1:1, o2:2, toJSON:function(){ return this.o1+this.o2; } } }; JSON.stringify(obj); // &quot;{&quot;x&quot;:1,&quot;y&quot;:2,&quot;o&quot;:3}&quot; 12## 其他对象方法 var obj ={x:1,y:2}; obj.toString();//&quot;[object Object]&quot; //自定义toString 方法 obj.toString = function(){return this.x+this.y}; &quot;result&quot;+obj;//result 3 //自定义valueOf方法 obj.valueOf = function(){ return this.x+this.y+100; } &quot;result&quot;+obj;//103 ```","categories":[],"tags":[]},{"title":"html5+css3画布","slug":"html5画布","date":"2016-10-12T17:26:00.000Z","updated":"2018-12-12T04:36:13.346Z","comments":true,"path":"2016/10/13/html5画布/","link":"","permalink":"http://suijiafeng.com/2016/10/13/html5画布/","excerpt":"","text":"[TOC] 目录画布的概念canvas原意为帆布，在html页面中用于展示绘图效果,所有画图的过程使用js来实现。 画布的用途 绘图 数据可视化(重点) 动画与游戏 banner 广告等。 画布的兼容性 canvas 的兼容性非常强, 只要支持该标签的, 基本功能都一样, 因此不用考虑兼容性问题. canvas 本身就是一张画布. 整个绘图过程是由 JavaScript 来完成， canvas 对象提供了各种绘图用的 api. 如果浏览器不支持 canvas 标签, 那么就会将其解释为 div 标签. 因此常常在 canvas 中嵌入文本, 以提示用户浏览器的能力. 怎么使用 拿到画布 创建画图工具 移动画笔 颜色填充 、描边 绘制基本形状的api的总结 创建画图工具 canvas.getContext(“2d”) 移动画笔 context.moveTo(x, y) 画一条直线 context.lineTo(x, y) 描边 context.stroke(); 填充 context.fill(); 设置描边颜色 context.strokeStyle = “red”; 设置填充颜色 context.fillStyle = “green”; 创建一张新的玻璃纸 context.beginPath(); 闭合路径context.closePath(); 我们可以这样想象：ctx在画图时，并不是直接把线画到画布上，而是画在玻璃纸上 当执行stroke时，把玻璃纸向画布上做一次印刷，再执行一次stoke会再印刷一次 为了避免重复印刷，我们的做法是， 再拿一张新的玻璃纸，在新的玻璃纸上绘制 再次执行stroke就会使用新玻璃纸上的图形 beginPath， 创建一个新玻璃纸的过程， 叫做, 路径就是玻璃纸上的图形元素； closePath，会自动将lineTo的最后一个点和最近的moveTo点连接起来， stroke()和fill() stroke是描边，（素描） fill是填充，（上色） fill会自动执行一次closePath strokeStyle和fillStyle strokeStyle，描边颜色 fillStyle, 填充颜色 路径 路径就是画布上的线条 路径是有方向的 非零填充原则 路径围成的区域内部，任意一点拉一条射线，找到所有与其相交的路径。顺时针为1， 逆时针为-1. 将所有的相交的路径的值相加。 如果不等于零则对该区域进行填充 画矩形​ 只有矩形、圆形的有api ,三角形这些需要自己绘制 用线条连成一个矩形； 最笨，最麻烦 使用ctx.rect()方法； 绘制出一个矩形的路径， 适应性是最强的,使用最为广泛 12345// context.rect(x, y, w, h); 分别代表 x y 坐标 ，矩形 宽 高// context.rect(100, 100, 200, 150);// context.strokeStyle = 'red';// context.fillStyle = 'green';// context.fill(); 使用ctx.fillRect()方法。第三种方法会重新开启一个新的路径 创建一个填充的矩形，只能填充不能描边 // context.fillRect(100, 100, 200, 150); 使用 ctx.strokeRect()方法。 绘制一个描边的矩形，只能描边不能填充 context.strokeRect(100, 100, 200, 150); 注意方法 3 、4 在调用方法的时候就已经描边或者填充了，所以如果想要修改他的边框或者填充色，那就得在它之前修改。 、、、、、、、、、、— webPack 项目打包软件–简书/gitup上有资料，可学习下 、、、、、、、、、、– 画圆形的方式语法： arc(x, y, radius, startAngle, endAngle, anticlockwise), 画一个以（x,y）为圆心的以radius为半径的圆弧（圆），从startAngle开始到endAngle结束，按照anticlockwise`给定的方向（默认为顺时针，其值默认false,通常省去不写。）来生成。 anticlockwise :意思，是否是逆时针，为 true 表示逆时针 ，为false 表示顺时针 注意，在canvas中，所有的角度都必须转成弧度才能使用，角度转弧度公式angle/180*Math.PI [TOC] 目录线条线条粗细12345678&lt;script&gt; var canvas = document.getElementById('canvas'); var context = canvas.getContext('2d'); //设置线条粗细 context.lineWidth = 10; context.moveTo(300, 200); context.lineTo(300, 400);&lt;/script&gt; 虚线的设置(不是很明白)123456789101112131415161718192021&lt;script&gt; var canvas = document.getElementById(\"canvas\"); var context = canvas.getContext(\"2d\"); //先画一条垂直的参考线 context.moveTo(100, 0); context.lineTo(100, 400); context.stroke(); //画虚线 context.beginPath(); context.lineWidth = 10; //设置虚线的样式，循环使用数组里面的长度，虚线的间隔也占一个长度 context.setLineDash([5, 10，15]); //画虚线的一个偏移 context.lineDashOffset = 15; context.moveTo(100, 100); context.lineTo(500, 100); context.stroke(); &lt;/script&gt; 线条的头部 lineCap：默认值：butt round使用的是最多的。 JavaScript 语法：context.lineCap=”butt|round|square”; 阴影123456789101112131415&lt;script&gt; var canvas = document.getElementById(\"canvas\"); var context = canvas.getContext(\"2d\"); //画一个矩形 context.fillStyle = \"yellowgreen\"; //阴影的水平偏移 context.shadowOffsetX = 15; //阴影的垂直偏移 context.shadowOffsetY = 15; //阴影的颜色 context.shadowColor = \"red\"; //阴影的模糊程度，值越大，越模糊 context.shadowBlur = 15; context.fillRect(100, 100, 200, 200);&lt;/script&gt; 渐变线性渐变1234567891011121314&lt;script&gt; var canvas = document.getElementById(\"canvas\"); var context = canvas.getContext(\"2d\"); //1. 创建一个渐变的对象 var gradient = context.createLinearGradient(100, 100, 300, 100); //2. 添加渐变色 gradient.addColorStop(0, \"red\"); gradient.addColorStop(0.5, \"yellow\"); gradient.addColorStop(1, \"green\"); //3. 将渐变对象设为画笔颜色 context.fillStyle = gradient; //4. 填充操作 context.fillRect(100, 100, 300, 200);&lt;/script&gt; 径向渐变 HTML5 canvas createRadialGradient() 方法 context.createRadialGradient(*x0*,*y0*,*r0*,*x1*,*y1*,*r1*); x0 y0 r0 为开始圆的圆心 和半径 x1 y1 r1 为结束圆的圆心 和半径 1234567891011121314151617&lt;script&gt; var canvas = document.getElementById('canvas'); var context = canvas.getContext('2d'); //1 创建径向渐变对象 var gradient = context.createRadialGradient(200, 200, 80, 200, 200, 100); // 2 给gradient渐变对象添加颜色 // 在那个区间会渐变呢？？在两个圆之间的部分 也就是 半径 100-80之间发生渐变 // red -green 占一半 green- yellow 占一半 gradient.addColorStop(0, 'red'); gradient.addColorStop(0.5, 'green'); gradient.addColorStop(1, 'yellow'); // 3 将gradient对象设为填充色 context.fillStyle = gradient; // 4 画圆形 context.arc(200, 200, 100, 0, Math.PI * 2); context.fill(); &lt;/script&gt; 步骤 创建渐变对象 给渐变对象添加渐变色 将渐变对象设为填充颜色/描边颜色 画图并填充（描边） addColorStop(offset, color)offset代表百分比，它是一个小数。color该点的颜色 绘制文本 fillText(text, x, y [, maxWidth]) 在指定的(x,y)位置填充指定的文本，绘制的最大宽度是可选的. 这种比较常见，出来的字体比较好看。 strokeText(text, x, y [, maxWidth]) 在指定的(x,y)位置绘制文本边框，绘制的最大宽度是可选的. 镂空效果。 文本对齐选项 font = value: 当前我们用来绘制文本的样式. 这个字符串使用和 CSS font 属性相同的语法. 默认的字体是 10px sans-serif。 textAlign = value: 文本对齐选项. 可选的值包括：start, end, left, right or center. 默认值是 start。 ​ 文字水平对齐 123456789101112131415161718192021222324252627282930&lt;script&gt; var canvas = document.getElementById('canvas'); var context = canvas.getContext('2d'); //绘制参考线 context.moveTo(300, 0); context.lineTo(300, 400); context.stroke(); //文字部分 //设置字体样式 context.font = '20px 微软雅黑'; // 设置文本对齐方式 context.textAlign = 'center'; //设置文字内容 context.fillText(\"text\", 300, 100); // -------------------- // 设置文本对齐方式 context.textAlign = 'left'; //设置文字内容 context.fillText(\"text\", 300, 150); // -------------------- // 设置文本对齐方式 context.textAlign = 'right'; //设置文字内容 context.fillText(\"text\", 300, 200); //---------设置镂空文字 strokeText 只会对文字进行描边，而不会对文字部分进行颜色的填充。 // 设置文本对齐方式 context.textAlign = 'right'; //设置文字内容 context.strokeText(\"text\", 300, 300); &lt;/script&gt; textBaseline = value: 基线对齐选项. 可选的值包括：top, hanging, middle, alphabetic, ideographic, bottom。默认值是 alphabetic。 ​ 文字垂直对齐 1234567891011121314151617181920212223&lt;script&gt; var canvas = document.getElementById('canvas'); var context = canvas.getContext('2d'); // 1 绘制一条参考线,方便观看 context.moveTo(0, 200); context.lineTo(600, 200); context.stroke(); // 2 文本设置 context.font = '20px 微软雅黑'; // context.textAlign='start | left | center | right |end'; // context.textBaseline='top | hanging | middle | alphabetic | ideographic | bottom'; //--------默认状态下 context.fillText('你妹的', 200, 200); //--------bottom 对齐 context.textBaseline = 'bottom'; context.fillText('你妹的', 300, 200); //--------center 对齐 context.textBaseline = 'center'; context.fillText('你妹的', 400, 200); //--------top 对齐 context.textBaseline = 'top'; context.fillText('你妹的', 500, 200); &lt;/script&gt; direction = value: 文本方向。可能的值包括：ltr, rtl, inherit。默认值是 inherit。 计算文本大小 measureText()： 返回一个 TextMetrics对象的宽度、所在像素 语法：context.measureText(text).width;` text 为要测量的文本 1234567891011&lt;script&gt; var canvas = document.getElementById('canvas'); var context = canvas.getContext('2d'); var txt = \"你妹sdfsdfsdfsdfsdfsdfsdfsdsdf的\" context.font = '30px 微软雅黑'; context.fillText(txt, 300, 200); //这一句代码会把参数设置上，并印刷，所以要改变参数，必须在此之前，如果在这之后修改，不会印刷，不会表现出来，看不到效果。 context.font = '100px 微软雅黑'; // |context.textAlign='start | left | center | right |end'; var width = context.measureText(txt).width; console.log(width); &lt;/script&gt; 图片绘制1.原样 三参模式： 写法： img :图像 x,y 放置的位置 1*context*.drawImage(*img*,*x*,*y*); 2.缩放 五参模式 写法： img :图像 x,y 放置的位置 width,height 图片的宽 高 1*context*.drawImage(*img*,*x*,*y*,*width*,*height*); 3.裁剪 九参模式 写法：img 图像 sx,sy 开始裁剪的坐标位置,swidth,sheight：裁剪图像的宽 高；x,y :裁剪的图像放置的位置，weidth,height,裁剪图像要显示的宽 高。 1*context*.drawImage(*img*,*sx*,*sy*,*swidth*,*sheight*,*x*,*y*,*width*,*height*); 注意的地方：w3c上有说很多参数可以省略，亲测发现，不能省略。 md中代码的输入英文状态下输入 ``` 加 回车,右下角可以选择语言类型。 前天的知识复习更丰富的样式 线条 画线或者是描边时的样式设置 lineWith lineCap = “round” //butt， square setLineDash([5， 10, 15]) lineDashOffset //设置虚线的偏移 阴影 shadowOffsetX shadowOffsetY shadowColor shadowBlur //模糊程度 渐变 创建渐变对象 context.creatLinearGradient(x0, y0, x1, y1) var gra= context.createRadialGradient(x0, y0, r0, x1, y1, r1) 添加渐变色 addColorStop(offset, color) 将渐变对象设为填充色或者是描边色 context.fillStyle = gra 绘制图形并填充 文字的绘制 设置文字的字体 context.font = “20px 微软雅黑” 画描边文字 strokeText(“text”, x, y) 填充文字fillText(“text”, x, y) 水平对齐 textAlign = “left” //right, center, 看线在文字哪一边，就是什么对齐 垂直对齐 textBaseline = “top” //bottom, middle 图片绘制 三参模式 drawImage(image, x, y) //原大小显示 五参模式 drawImage(image, x, y, width, height) //缩放显示 九参模式 draImage(image, x0, y0, width0, height0, x1, y1, width1, height1) //x0, y0, width0, height0从原始图片从哪一个点开始裁剪，多大。后面的四个参数是在画布上的什么位置粘贴 例子 移动的小人 键盘控制小人移动 变形和动画 缩放 scale(x, y) 平移 translate(x, y) 旋转 rotate(raidan) //整个坐标系，围绕坐标原点旋转 动画实现原理 当我们以足够快的速度逐帧播放图片时，会超出人眼的识别的极限，让人错以为整个过程是连续 setInterval(function(){}, 16.7); var animation = window.reqeustAnimationFrame(方法名） 递归调用 性能比较好，可以自动的适应游览器的刷新频率 window.cancelAnimationFrame(animation) 结束动画 原始状态save(原始状态) //平移和旋转坐标系 save（平移和反方向旋转90度的状） restore() save（平移和反方向旋转90度的状） restore() save（平移和反方向旋转90度的状） restore()restore（）","categories":[],"tags":[]},{"title":"css选择器的使用","slug":"css伪元素的使用","date":"2016-09-18T17:13:00.000Z","updated":"2018-12-12T04:36:13.346Z","comments":true,"path":"2016/09/19/css伪元素的使用/","link":"","permalink":"http://suijiafeng.com/2016/09/19/css伪元素的使用/","excerpt":"","text":"#CSS选择器# 交集选择器 （需要满足他的条件。）后代选择器main p只要是 main 的后代 p元素，都会选中 子代选择器并集选择器，即群组选择器以逗号隔开 相邻选择器即同辈选择器也叫毗邻选择器 M+N选择M元素后面的一个兄弟N元素 12345678910111213141516171819特殊情况：&lt;style type=&quot;text/css&quot;&gt; li + li &#123; color:red; &#125;&lt;/style&gt;&lt;div&gt; &lt;ul&gt; &lt;li&gt;List item 1&lt;/li&gt; &lt;li&gt;List item 2&lt;/li&gt; &lt;li&gt;List item 3&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;效果： &lt;li&gt;List item 2&lt;/li&gt; &lt;li&gt;List item 3&lt;/li&gt; 文字变红 同辈组合选择器即兄弟选择器 M~N选择M元素后面的所有兄弟N元素 选择器的权重 在复合选择的时候，权重越高，优先级权重越高。 优选级顺序: 继承性&lt;通配 符&lt;标签选择器&lt;类选择器&lt;ID选择器&lt;行内样式&lt;!important注意：！important影响的只是他的单一属性而已。 伪类选择器li:first-child:控制第一个子元素 (重要)li:last-child：控制最后一个子元素（重要)其它：（了解即可）li:nth-child(2:)控制特定的某一个元素(控制第二个)li:nth-child(odd):控制奇数的子元素li:nth-child(even):控制偶数的子元素li:nth-child(n+2):li:nth-child(2n+1)li:nth-child() link伪类学习 a:hover 当鼠标悬停在a标签上的时候 a:active 当鼠标点下去但没有松开的时候（激活状态） a:link a标签未被访问过的样式（不常用） a:visited a标签访问后的样式。 注意：当四个伪类同事作用在一个a标签上的时候：爱恨原则：love hate:link visited hover active;（顺序是否错了）并不是a标签才能使用伪类，其它的标签一样可以使用。 子盒子所在的区域同时也是父盒子的那个区域。 a:focus ，当表单空间获得焦点的时候","categories":[],"tags":[]},{"title":"html+css 垂直居中的案例","slug":"html-css-垂直居中的案例","date":"2016-05-23T17:17:00.000Z","updated":"2018-12-12T04:36:13.346Z","comments":true,"path":"2016/05/24/html-css-垂直居中的案例/","link":"","permalink":"http://suijiafeng.com/2016/05/24/html-css-垂直居中的案例/","excerpt":"","text":"CSS垂直居中的11种实现方式11种实现方式分别如下： 1. 使用绝对定位和负外边距对块级元素进行垂直居中html代码： 123&lt;div id=&quot;box&quot;&gt; &lt;div id=&quot;child&quot;&gt;我是测试DIV&lt;/div&gt;&lt;/div&gt; css代码： 复制代码 123456789101112131415#box &#123; width: 300px; height: 300px; background: #ddd; position: relative;&#125;#child &#123; width: 150px; height: 100px; background: orange; position: absolute; top: 50%; margin: -50px 0 0 0; line-height: 100px;&#125; 复制代码运行结果如下： 这个方法兼容性不错，但是有一个小缺点：必须提前知道被居中块级元素的尺寸，否则无法准确实现垂直居中。 2. 使用绝对定位和transformhtml代码： 1234&lt;div id=&quot;child&quot;&gt; 我是一串很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长的文本&lt;/div&gt;css代码： 复制代码 123456789101112#box &#123; width: 300px; height: 300px; background: #ddd; position: relative;&#125;#child &#123; background: #93BC49; position: absolute; top: 50%; transform: translate(0, -50%);&#125; 复制代码运行结果如下： 这种方法有一个非常明显的好处就是不必提前知道被居中元素的尺寸了，因为transform中translate偏移的百分比就是相对于元素自身的尺寸而言的。 3. 另外一种使用绝对定位和负外边距进行垂直居中的方式 html代码： 123&lt;div id=&quot;box&quot;&gt; &lt;div id=&quot;child&quot;&gt;我也是个测试DIV&lt;/div&gt;&lt;/div&gt; css代码： 复制代码 1234567891011121314#box &#123; width: 300px; height: 300px; background: #ddd; position: relative;&#125;#child &#123; width: 50%; height: 30%; background: pink; position: absolute; top: 50%; margin: -15% 0 0 0;&#125; 复制代码运行结果如下： 这种方式的原理实质上和前两种相同。补充的一点是：margin的取值也可以是百分比，这时这个值规定了该元素基于父元素尺寸的百分比，可以根据实际的使用场景来决定是用具体的数值还是用百分比。 4. 绝对定位结合margin: autohtml代码： 呆呆今天退役了(。﹏。)css代码： 复制代码 12345678910111213141516#box &#123; width: 300px; height: 300px; background: #ddd; position: relative;&#125;#child &#123; width: 200px; height: 100px; background: #A1CCFE; position: absolute; top: 0; bottom: 0; margin: auto; line-height: 100px;&#125; 复制代码运行结果如下： 这种实现方式的两个核心是：把要垂直居中的元素相对于父元素绝对定位，top和bottom设为相等的值，我这里设成了0，当然你也可以设为99999px或者-99999px无论什么，只要两者相等就行，这一步做完之后再将要居中元素的margin设为auto，这样便可以实现垂直居中了。 被居中元素的宽高也可以不设置，但不设置的话就必须是图片这种自身就包含尺寸的元素，否则无法实现。 5. 使用padding实现子元素的垂直居中html代码： 123&lt;div id=&quot;box&quot;&gt; &lt;div id=&quot;child&quot;&gt;今天西安的霾严重的吓人，刚看了一眼PM2.5是422&lt;/div&gt;&lt;/div&gt; css代码： 复制代码 1234567891011#box &#123; width: 300px; background: #ddd; padding: 100px 0;&#125;#child &#123; width: 200px; height: 100px; background: #F7A750; line-height: 50px;&#125; 复制代码运行结果如下： 这种实现方式非常简单，就是给父元素设置相等的上下内边距，则子元素自然是垂直居中的，当然这时候父元素是不能设置高度的，要让它自动被填充起来，除非设置了一个正好等于上内边距+子元素高度+下内边距的值，否则无法精确的垂直居中。 这种方式看似没有什么技术含量，但其实在某些场景下也是非常好用的。 6. 设置第三方基准html代码： 1234&lt;div id=&quot;box&quot;&gt; &lt;div id=&quot;base&quot;&gt;&lt;/div&gt; &lt;div id=&quot;child&quot;&gt;今天写了第一篇博客，希望可以坚持写下去！&lt;/div&gt;&lt;/div&gt; css代码： 复制代码 123456789101112131415#box &#123; width: 300px; height: 300px; background: #ddd;&#125;#base &#123; height: 50%; background: #AF9BD3;&#125;#child &#123; height: 100px; background: rgba(131, 224, 245, 0.6); line-height: 50px; margin-top: -50px;&#125; 复制代码运行结果如下： 这种方式也非常简单，首先设置一个高度等于父元素高度一半的第三方基准元素，那么此时该基准元素的底边线自然就是父元素纵向上的中分线，做完这些之后再给要垂直居中的元素设置一个margin-top，值的大小是它自身高度的一半取负，则实现垂直居中。 使用flex布局html代码： 1&lt;div id=&quot;box&quot;&gt;雾霾天气，太久没有打球了&lt;/div&gt; css代码： 复制代码 1234567#box &#123; width: 300px; height: 300px; background: #ddd; display: flex; align-items: center;&#125; 复制代码运行结果如下： 这种方式同样适用于块级元素： html代码： 12345&lt;div id=&quot;box&quot;&gt; &lt;div id=&quot;child&quot;&gt; 程序员怎么才能保护好眼睛？ &lt;/div&gt;&lt;/div&gt; css代码： 复制代码 12345678910111213#box &#123; width: 300px; height: 300px; background: #ddd; display: flex; align-items: center;&#125;#child &#123; width: 300px; height: 100px; background: #8194AA; line-height: 100px;&#125; 复制代码运行结果如下： flex布局（弹性布局/伸缩布局）里门道颇多，这里先针对用到的东西简单说一下，想深入学习的小伙伴可以去看阮一峰老师的博客。（http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html） flex也就是flexible，意为灵活的、柔韧的、易弯曲的。 元素可以通过设置display:flex;将其指定为flex布局的容器，指定好了容器之后再为其添加align-items属性，该属性定义项目在交叉轴（这里是纵向轴）上的对齐方式，可能的取值有五个，分别如下： flex-start:：交叉轴的起点对齐； flex-end：交叉轴的终点对齐； center：交叉轴的中点对齐； baseline：项目第一行文字的基线对齐； stretch（该值是默认值）：如果项目没有设置高度或者设为了auto，那么将占满整个容器的高度。 8. 第二种使用弹性布局的方式html代码： 12345&lt;div id=&quot;box&quot;&gt; &lt;div id=&quot;child&quot;&gt; 答案当然是多用绿色的背景哈哈 &lt;/div&gt;&lt;/div&gt; css代码： 复制代码 1234567891011121314#box &#123; width: 300px; height: 300px; background: #ddd; display: flex; flex-direction: column; justify-content: center;&#125;#child &#123; width: 300px; height: 100px; background: #08BC67; line-height: 100px;&#125; 复制代码运行结果如下： 这种方式也是首先给父元素设置display:flex，设置好之后改变主轴的方向flex-direction: column，该属性可能的取值有四个，分别如下： row（该值为默认值）：主轴为水平方向，起点在左端； row-reverse：主轴为水平方向，起点在右端； column：主轴为垂直方向，起点在上沿； column-reverse：主轴为垂直方向，起点在下沿。 justify-content属性定义了项目在主轴上的对齐方式，可能的取值有五个，分别如下（不过具体的对齐方式与主轴的方向有关，以下的值都是假设主轴为从左到右的）： flex-start（该值是默认值）：左对齐； flex-end：右对齐； center：居中对齐； space-between：两端对齐，各个项目之间的间隔均相等； space-around：各个项目两侧的间隔相等。 9. 还有一种在前面已经见到过很多次的方式就是使用 line-height 对单行文本进行垂直居中html代码： 我是一段测试文本css代码： 复制代码 #box{ width: 300px; height: 300px; background: #ddd; line-height: 300px;}复制代码运行结果如下： 这里有一个小坑需要大家注意：line-height(行高) 的值不能设为100%，我们来看看官方文档中给出的关于line-height取值为百分比时候的描述：基于当前字体尺寸的百分比行间距。所以大家就明白了，这里的百分比并不是相对于父元素尺寸而言，而是相对于字体尺寸来讲的。 10. 使用 line-height 和 vertical-align 对图片进行垂直居中html代码： 123&lt;div id=&quot;box&quot;&gt; &lt;img src=&quot;duncan.jpeg&quot;&gt;&lt;/div&gt; css代码： 复制代码 123456789#box&#123; width: 300px; height: 300px; background: #ddd; line-height: 300px;&#125;#box img &#123; vertical-align: middle;&#125; 复制代码运行结果如下： vertical-align并不像看起来那样天真无邪童叟无欺，以后会单独拎出来专门写一篇。 11. 使用 display 和 vertical-align 对容器里的文字进行垂直居中html代码： 123&lt;div id=&quot;box&quot;&gt; &lt;div id=&quot;child&quot;&gt;我也是一段测试文本&lt;/div&gt;&lt;/div&gt; css代码： 复制代码 12345678910#box &#123; width: 300px; height: 300px; background: #ddd; display: table;&#125;#child &#123; display: table-cell; vertical-align: middle;## &#125; 复制代码运行结果如下： 这里关于vertical-align啰嗦两句：vertical-align属性只对拥有valign特性的html元素起作用，例如表格元素中的等等，而像这样的元素是不行的。 valign属性规定单元格中内容的垂直排列方式，语法：，value的可能取值有四种： top：对内容进行上对齐 middle：对内容进行居中对齐 bottom：对内容进行下对齐 baseline：基线对齐 关于baseline值：基线是一条虚构的线。在一行文本中，大多数字母以基线为基准。baseline 值设置行中的所有表格数据都分享相同的基线。该值的效果常常与 bottom 值相同。不过，如果文本的字号各不相同，那么 baseline 的效果会更好。 注：以下demo都只是针对现代浏览器所做，未兼容低版本的IE以及其它非主流浏览器。 感谢原文作者：呆里呆气 参考链接：http://blog.csdn.net/wolinxuebin/article/details/7615098http://blog.csdn.net/qq_14962891/article/details/51783136http://blog.csdn.net/xukai871105/article/details/30115407https://www.cnblogs.com/zhouhuan/p/vertical_center","categories":[],"tags":[]},{"title":"Html盒模型","slug":"Html盒模型","date":"2016-04-02T17:09:00.000Z","updated":"2018-12-12T04:36:13.346Z","comments":true,"path":"2016/04/03/Html盒模型/","link":"","permalink":"http://suijiafeng.com/2016/04/03/Html盒模型/","excerpt":"","text":"定义 在网页中，一个元素占有空间的大小由几个部分构成，其中包括元素的内容(content)，元素的内边距(padding)，元素的边框(border)，元素的外边距(margin)四个部分。这四个部分占有的空间中，有的部分可以显示相应的内容，而有的部分只用来分隔相邻的区域或区域。4个部分一起构成了css中元素的盒模型。 - 要点：在页面中每个元素都可以看做是一个盒子。 contentpaddingborder margin与padding在内嵌的时候，是可以相等的。 border-style:solid /dashed /dotted/double/none()，如果border-style未设置，那么边框不显示。 border 也是可以连写的：bord-color:yellow blue red pink;(表示上、右、下、左的颜色分别是 yellow、blue、red、pink); transparent 透明的 如果不给子盒子设置宽度，则继承父盒子的宽度；但是高度不能继承。 border和padding 对盒子的影响。 margin垂直塌陷、叠压 如果有两个垂直分布的盒子，给他们添加相对的两个margin时，他们之间的距离取决于两者之间最大的margin值 包含塌陷 包含塌陷：在父子盒子中，给子盒子添加一个margin-top时，有可能会带跑父盒子包含塌陷解决方法： 给父盒子加边框 给父盒子加overflow:hidden margin共享 几个并列的盒子，给其中的一个设置margin-top时，其它盒子也会跟着往下走 注意：如果是使用浮动使盒子并排的，则不会有margin 共享 同样的，使用定位使盒子并排的 ，margin 也不会共享 如果使用display:inline-block使盒子并排的，那么margin 会共享 盒模型使用注意事项：行内元素添加垂直padding还有margin————》都不要用 clear 控制元素两边是否有浮动元素 它只能管自己，打不过别人。 不希望我两边有浮动元素，如果有，我走？##伪元素## after before 浮动的其它特性 浮动元素会脱离文档流，不占标准流的位置 浮动元素可以实现模式转换（行内块） 浮动元素的顺序排列(和HTML结构相关) 浮动元素的顶端对齐 子盒子只会在父盒子的区域中浮动 父盒子浮动、会带跑子盒子 浮动元素前面如果是标准流，那么只会在标准流后面浮动。 会进行模式转换，会把行内元素转换成行内块。 清除浮动 给父盒子设置一个高度 优点：最稳定，但是可维护性差。 给父元素加：over:hidden; 解决“塌陷”的办法1、创建一个用来清除浮动的CSS样式类 （.clearfix）2、针对包裹的全是浮动元素的父级容器使用（.clearfix）.clearfix { zoom:1;}.clearfix:after { content:”.”; display:block; visibility:hidden; height:0; clear:both;} 负边距去除默认边距 给行内块去除，给他的父元素加，font-size:0; 给块状元素去除，给他本身加 margin:0; padding:0; 定位静态定位 即标准流。 固定定位 相对浏览器可视区域进行移动。 脱离文档流。但是不占位置。 如果有两个以上盒子，那么他们会发生层叠，叠在一起。这个使用我们可以使用z-index 属性来选择他们的层级 - 实现模式转换:也就是说行内元素会变成块状。 待验证 不随页面滚动而滚动。 相对定位 不能脱离标准流，也不能实现模式转换。 相对定位参照自己原来的位置进行移动。 子绝父相 子绝父绝 子绝父固 绝对定位 相对有有了定位的元素进行移动（除去静态定位） 脱离文档流- 实现模式转换:会将元素转换成块状元素如果有两个以上盒子，那么他们会发生层叠，叠在一起。这个使用我们可以使用z-index 属性来选择他们的层级 层级 z-index 只对定位元素有效 元素的显示模式 display块级元素 bl0ck 特点： 独占一行 可以设置有效的宽、高 行内元素inline一行可以显示多个，不可以设置宽、高。宽、高由内容决定。 行内块状inline-block特点:可以设置有效的宽、高。","categories":[],"tags":[]},{"title":"Markdown 编辑器语法指南","slug":"Markdown-编辑器语法指南","date":"2016-02-20T17:04:00.000Z","updated":"2018-12-12T04:36:13.346Z","comments":true,"path":"2016/02/21/Markdown-编辑器语法指南/","link":"","permalink":"http://suijiafeng.com/2016/02/21/Markdown-编辑器语法指南/","excerpt":"","text":"基本技巧代码如果你只想高亮语句中的某个函数名或关键字，可以使用 function_name() 实现 通常编辑器根据代码片段适配合适的高亮方法，但你也可以用 12345```javascript$(document).ready(function () &#123; alert(&apos;hello world&apos;);&#125;); 支持的语言： 1c, abnf, accesslog, actionscript, ada, apache, applescript, arduino, armasm, asciidoc, aspectj, autohotkey, autoit, avrasm, awk, axapta, bash, basic, bnf, brainfuck, cal, capnproto, ceylon, clean, clojure, clojure-repl, cmake, coffeescript, coq, cos, cpp, crmsh, crystal, cs, csp, css, d, dart, delphi, diff, django, dns, dockerfile, dos, dsconfig, dts, dust, ebnf, elixir, elm, erb, erlang, erlang-repl, excel, fix, flix, fortran, fsharp, gams, gauss, gcode, gherkin, glsl, go, golo, gradle, groovy, haml, handlebars, haskell, haxe, hsp, htmlbars, http, hy, inform7, ini, irpf90, java, javascript, json, julia, kotlin, lasso, ldif, leaf, less, lisp, livecodeserver, livescript, llvm, lsl, lua, makefile, markdown, mathematica, matlab, maxima, mel, mercury, mipsasm, mizar, mojolicious, monkey, moonscript, n1ql, nginx, nimrod, nix, nsis, objectivec, ocaml, openscad, oxygene, parser3, perl, pf, php, pony, powershell, processing, profile, prolog, protobuf, puppet, purebasic, python, q, qml, r, rib, roboconf, rsl, ruby, ruleslanguage, rust, scala, scheme, scilab, scss, smali, smalltalk, sml, sqf, sql, stan, stata, step21, stylus, subunit, swift, taggerscript, tap, tcl, tex, thrift, tp, twig, typescript, vala, vbnet, vbscript, vbscript-html, verilog, vhdl, vim, x86asm, xl, xml, xquery, yaml, zephir 也可以使用 4 空格缩进，再贴上代码，实现相同的的效果 def g(x): yield from range(x, 0, -1) yield from range(x) 如你不需要代码高亮，可以用下面的方法禁用： 1 标题文章内容较多时，可以用标题分段： 标题1 ====== 标题2 ----- ## 大标题 ## ### 小标题 ### 粗斜体 *斜体文本* _斜体文本_ **粗体文本** __粗体文本__ ***粗斜体文本*** ___粗斜体文本___ 链接常用链接方法文字链接 [链接名称](http://链接网址) 网址链接 &lt;http://链接网址&gt; 高级链接技巧这个链接用 1 作为网址变量 [Google][1]. 这个链接用 yahoo 作为网址变量 [Yahoo!][yahoo]. 然后在文档的结尾为变量赋值（网址） [1]: http://www.google.com/ [yahoo]: http://www.yahoo.com/ 列表普通无序列表- 列表文本前使用 [减号+空格] + 列表文本前使用 [加号+空格] * 列表文本前使用 [星号+空格] ###普通有序列表### 1. 列表前使用 [数字+空格] 2. 我们会自动帮你添加数字 7. 不用担心数字不对，显示的时候我们会自动把这行的 7 纠正为 3 列表嵌套1. 列出所有元素： - 无序列表元素 A 1. 元素 A 的有序子列表 - 前面加四个空格 2. 列表里的多段换行： 前面必须加四个空格， 这样换行，整体的格式不会乱 3. 列表里引用： &gt; 前面空一行 &gt; 仍然需要在 &gt; 前面加四个空格 4. 列表里代码段： 1前面四个空格，之后按代码语法 ``` 书写 或者直接空八个，引入代码块 引用普通引用&gt; 引用文本前使用 [大于号+空格] &gt; 折行可以不加，新起一行都要加上哦 引用里嵌套引用&gt; 最外层引用 &gt; &gt; 多一个 &gt; 嵌套一层引用 &gt; &gt; &gt; 可以嵌套很多层 引用里嵌套列表&gt; - 这是引用里嵌套的一个列表 &gt; - 还可以有子列表 &gt; * 子列表需要从 - 之后延后四个空格开始 引用里嵌套代码块&gt; 同样的，在前面加四个空格形成代码块 &gt; &gt; 12&gt; 或者使用 ``` 形成代码块&gt; 图片跟链接的方法区别在于前面加了个感叹号 !，这样是不是觉得好记多了呢？ ![图片名称](http://图片网址) 当然，你也可以像网址那样对图片网址使用变量 这个链接用 1 作为网址变量 [Google][1]. 然后在文档的结尾位变量赋值（网址） [1]: http://www.google.com/logo.png ##换行## 如果另起一行，只需在当前行结尾加 2 个空格 在当前行的结尾加 2 个空格 这行就会新起一行 如果是要起一个新段落，只需要空出一行即可。 分隔符如果你有写分割线的习惯，可以新起一行输入三个减号-。当前后都有段落时，请空出一行： 前面的段落 --- 后面的段落 高级技巧行内 HTML 元素目前只支持部分段内 HTML 元素效果，包括 &lt;kdb&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;，如 键位显示使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 重启电脑 代码块使用 &lt;pre&gt;&lt;/pre&gt; 元素同样可以形成代码块 粗斜体&lt;b&gt; Markdown 在此处同样适用，如 *加粗* &lt;/b&gt; 符号转义如果你的描述中需要用到 markdown 的符号，比如_ # * 等，但又不想它被转义，这时候可以在这些符号前加反斜杠，如\\_ \\# \\* 进行避免。 \\_不想这里的文本变斜体\\_ \\*\\*不想这里的文本被加粗\\*\\* 扩展支持 jsfiddle、gist、runjs、优酷视频，直接填写 url，在其之后会自动添加预览点击会展开相关内容。 http://{url_of_the_fiddle}/embedded/[{tabs}/[{style}]]/ https://gist.github.com/{gist_id} http://runjs.cn/detail/{id} http://v.youku.com/v_show/id_{video_id}.html 公式当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如： $$ x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}. $$ $$ x \\href{why-equal.html}{=} y^2 + 1 $$ 同时也支持 HTML 属性，如： $$ (x+1)^2 = \\class{hidden}{(x+1)(x+1)} $$ $$ (x+1)^2 = \\cssId{step1}{\\style{visibility:hidden}{(x+1)(x+1)}} $$","categories":[],"tags":[]},{"title":"关于预处理less的总结","slug":"关于预处理less的总结","date":"2016-01-21T17:02:00.000Z","updated":"2018-12-12T04:36:13.346Z","comments":true,"path":"2016/01/22/关于预处理less的总结/","link":"","permalink":"http://suijiafeng.com/2016/01/22/关于预处理less的总结/","excerpt":"","text":"css 使用方式行内样式直接写在html 标签里面的 内嵌样式用style 标签包裹着 外联样式另起一个样式表文件 最后通过link 文件连入其中的。 lessless 文件的引入之后，浏览器要以服务器的形式打开，不然效果出不来 要注意表明文件类型，否则不起作用。 123&lt;script id=&quot;template&quot; type=&quot;text/html&quot;&gt;id 必须用双引号，不然会报错 表单表单聚焦时候线条去除 outline z-index这个属性只对定位的元素有效 box-shadowbackground是一个符合属性，它的书写其实是有顺序要求的。如果你在前后者在后又给它设置单个属性，存在着覆盖问题。 白色与透明浮动。列出清除浮动的方法，并说明他们的优缺点。 line-height行高是有继承性的，如果一个父盒子里面有若干个子元素，那么他们都会去继承来自父盒子的行高。这样带来。这一点在是元素垂直居中的时候要 尤其注意 css 样式与模块化思想。base.css 基础样式或者叫做重置样式common.css 全局样式，要让他的权重尽可能的低，方便后续增加需求的时候对他进行覆盖page.css ，页面独立样式，在vue 中，如果是添加了scode ，那么在这个页面上写的样式只会对这个页面有效。 less定义变量循环函数 less的编译原理行内块元素并排时候，他们之间会有间隙，解决办法，1 浮动2 定位3 给父元素加上 font-size :0px; 注意一定是父元素，不然没有效果。 &gt; 子代选择器如果我们只是想选择某个元素的一个后代作为要，那么就可以使用子代选择器。 后代选择器少用，会大范围杀伤！！！ 类名给类名取名字不要太过于随意！！！ 定位定位只是根据元素当前所在的位置进行定位，所以，我们在给元素进行定位的时候一定要把margin 考虑进去。123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div &#123; position: absolute; top: 0px; left: 0px; width: 200px; height: 200px; background-color: pink; padding: 20px; margin: 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[]}]}