<!DOCTYPE html>
<html lang=zh-CN>
  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="description" content="互联网前端学习">
  <meta name="keywords" content="">
  
    <link rel="icon" href="/favicon.ico">
  
    
  <title>我现在新加的内容 | 眭加凤的博客</title>
  <link rel="stylesheet" href="/style.css">
  <link rel="stylesheet" href="/lib/jquery.fancybox.min.css">
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
</head>

<body>
    <div class="website_bg"></div>
  <header>
  <div class="header-container">
    <a class='logo' href="/">
      <span>眭加凤的博客</span>
    </a>
    <ul class="right-header">
      
        <li class="nav-item">
          
            <a href="/" class="item-link">首页</a>
          
        </li>
      
        <li class="nav-item">
          
            <a href="/about" class="item-link">关于</a>
          
        </li>
      
        <li class="nav-item">
          
            <a href="/archives" class="item-link">归档</a>
          
        </li>
      
        <li class="nav-item">
          
            <a href="/tags" class="item-link">标签</a>
          
        </li>
      
    </ul>
  </div>
</header>

  <main id='post'>
  <div class="content">
    <article>
        <section class="content markdown-body">
          <h1>我现在新加的内容</h1>
          <div class='post-meta'>
            <i class="fa fa-calendar" aria-hidden="true"></i> <time>2018年12月11日</time>
            
            
          </div>
          <p>最近在一点一点学习koa源码和深入浅出Node.js那本书，因为现在egg也是基于koa2的，而且自己以前做毕设的时候也用过，async/await真的是太好用了；现在新的中间层用egg搭建，所以想彻底把这部分的东西好好系统看一遍。</p>
<p>从开始看先看到了koa的一个构造函数，然后根据Node原生的写法看，它的真正创建服务的代码在listen()当中:</p>
<a id="more"></a>
<!-- more  -->
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>constructor() {<br>    super();</p>
<pre><code>this.proxy = false;
this.middleware = [];
this.subdomainOffset = 2;
this.env = process.env.NODE_ENV || &apos;development&apos;;
this.context = Object.create(context);
this.request = Object.create(request);
this.response = Object.create(response);
console.log(this)
</code></pre><p>}</p>
<p>listen(…args) {<br>    debug(‘listen’);<br>    const server = http.createServer(this.callback());<br>    return server.listen(…args);<br>}<br>在看深入浅出Node.js那本书里面，知道具体的request和response都是在这个callback里面执行，所以就看这个函数：</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>callback() {<br>   const fn = compose(this.middleware);</p>
<p>   if (!this.listeners(‘error’).length) this.on(‘error’, this.onerror);</p>
<p>   const handleRequest = (req, res) =&gt; {<br>     const ctx = this.createContext(req, res);<br>     return this.handleRequest(ctx, fn);<br>   };</p>
<p>   return handleRequest;<br> }<br>在这里其实就是返回了一个handleRequest(),继续看：</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>handleRequest(ctx, fnMiddleware) {<br>  const res = ctx.res;<br>  res.statusCode = 404;<br>  const onerror = err =&gt; ctx.onerror(err);<br>  const handleResponse = () =&gt; respond(ctx);<br>  onFinished(res, onerror);<br>  return fnMiddleware(ctx).then(handleResponse).catch(onerror);<br>}<br>到这里基本就能看出来它首先执行的就是这个fn，而这个fn又是怎么执行的？</p>
<p>大家都知道它是洋葱式的处理，然后看了一下是放在一个koa-compose的模块当中，这个模块就仅仅几行代码：</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br> function compose (middleware) {<br>  if (!Array.isArray(middleware)) throw new TypeError(‘Middleware stack must be an array!’)<br>  for (const fn of middleware) {<br>    if (typeof fn !== ‘function’) throw new TypeError(‘Middleware must be composed of functions!’)<br>  }</p>
<p>  /**</p>
<ul>
<li>@param {Object} context</li>
<li>@return {Promise}</li>
<li><p>@api public<br>*/</p>
<p>return function (context, next) {<br>// last called middleware #<br>let index = -1<br>return dispatch(0)<br>function dispatch (i) {<br> if (i &lt;= index) return Promise.reject(new Error(‘next() called multiple times’))<br> index = i<br> let fn = middleware[i]<br> if (i === middleware.length) fn = next<br> if (!fn) return Promise.resolve()<br> try {<br>   return Promise.resolve(fn(context, function next () {</p>
<pre><code>return dispatch(i + 1)
</code></pre><p>   }))<br> } catch (err) {<br>   return Promise.reject(err)<br> }<br>}<br>}<br>}<br>上面几行都是异常处理，真正的逻辑都在这个return的dispatch(0)当中，然后你发现它就是第一个中间件，首先先去做完一部分第一个中间件的事情，然后到了await next()就要去执行第二个，最终就是一个类似洋葱的模型：</p>
</li>
</ul>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>Promise.resolve(function(context, next){<br>    //中间件一第一部分代码<br>    await/yield Promise.resolve(function(context, next){<br>        //中间件二第一部分代码<br>        await/yield Promise.resolve(function(context, next){<br>                //中间件三第一部分代码<br>                await/yield next() // …n个<br>                //中间件三第二部分代码<br>        }())<br>         //中间件二第二部分代码<br>    }())<br>    //中间件一第二部分代码<br>}())<br>显而易见这个就是一个洋葱模型，这就是一个简单的koa的中间件调用的实现方式，感觉就可以理解成一个Promise.all()</p>
<p>感觉看完这个，也就对koa的中间件有了一个彻底的认知和理解，那么直接去学习中间件的源码也轻松了很多。</p>

        </section>
    </article>
    <!-- 文末导航 s-->
    <div class="article-nav prev-next-wrap clearfix">
        
        
            <a href="/2018/12/11/hello-world/" class="fr next-post btn btn-default" title='Hello World'>
                <span class="hidden-lg">下一篇</span>
                <span class="hidden-xs">Hello World</span><i class="fa fa-angle-right fa-fw"></i>
            </a>
        
    </div>
 <!-- 文末导航 e -->
 
  <!-- disqus 评论框 start -->
  <div class="comment">
      <div id="disqus_thread" class="disqus-thread">
        <i>加载评论框需要翻墙</i>
      </div>
  </div>
  <!-- disqus 评论框 end -->

    
</div>
<aside>

</aside>
</main>

<!-- disqus 公共JS代码 -->
<script type="text/javascript">
/* * * CONFIGURATION VARIABLES * * */
var disqus_shortname = "suijiafeng";
var disqus_identifier = "http://suijiafeng.com/2018/12/11/我现在新加的内容/";
var disqus_url = "http://suijiafeng.com/2018/12/11/我现在新加的内容/";
isAgent(getDisqus)
// determine user agent in China
function isAgent(cb) {
var url = '//graph.facebook.com/feed?callback=h';
var xhr = new XMLHttpRequest();
var called = false;
xhr.open('GET', url);
xhr.onreadystatechange = function() {
if (xhr.readyState === 4 && xhr.status === 200) {
called = true;
cb(true);
}
};
xhr.send();
// timeout 1s, this facebook API is very fast.
setTimeout(function() {
if (!called) {
xhr.abort();
cb(false)
}
}, 1000);
}
function getDisqus(isAgent) {
var dsq = document.createElement('script'); dsq.type = 'text/javascript'; 
dsq.async = true
dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq)
}
</script>
<!-- disqus 公共JS代码 end -->




  <footer class="footer-bg" style="background: #555; margin: 2px 0;">
  <div class="copyright" >
    <div style="margin: 0 auto">
         Copyright © 2016 - 2018  suijiafeng. All rights reserved.
    </div>
  </div>
</footer>


<script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script src="/lib/in-view.min.js"></script>
<script src="/lib/lodash.min.js"></script>
<script>
  var isDown = true
  var oldY = 0
  inView.offset(50)

  document.body.addEventListener('touchstart', function(){});
  
  window.addEventListener('scroll', _.throttle(e => {
    var currentY = window.scrollY
    if((oldY - currentY) < 0) {
      isDown = true
    } else {
      isDown = false
    }
    oldY = currentY
  }, 250))

  $("article img").each(function() {
      var strA = "<a data-fancybox='gallery' href='" + this.src + "'></a>";
      $(this).wrapAll(strA);
  });

  $('.toc-link').each(function() {
      var href = $(this).attr("href");
      
      inView(href).on('exit', () => {
        if (isDown) {
          handleActive(href)
        }
      })

      inView(href).on('enter', () => {
        if (!isDown) {
          handleActive(href)
        }
      })

      this.onclick = function(e) {
        var pos = $(href).offset().top - 10;
        $("html,body").animate({scrollTop: pos}, 300);
        setTimeout(() => {
          handleActive(href)
        }, 350)
        return false
      }
  })

  function handleActive(href) {
    document.querySelectorAll('.toc-link').forEach(elm => {
      elm.classList.remove('active')
    })
    document.querySelector(".toc [href='"+ href +"']").classList.add('active')
  }
</script>
<script src="/lib/jquery.fancybox.min.js"></script>



</body>
</html>
